<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Pack Opening Game with Mutations</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="apple-touch-icon" href="foot.jpeg">
<meta name="apple-mobile-web-app-title" content="YourAppName">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<link rel="apple-touch-icon" sizes="180x180" href="foot.jpeg">
<link rel="apple-touch-icon" sizes="152x152" href="foot.jpeg">
<link rel="apple-touch-icon" sizes="120x120" href="foot.jpeg">

<style>
    body {
        font-family: 'Inter', sans-serif;
        text-align: center;
        background: #e6f0ff;
        min-height: 100vh;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        padding: 1rem;
        color: #333;
    }
    .login-box, .game-box, #messageBox, #cardDetailsBox, #stealMessageBox {
        margin: 20px auto;
        padding: 20px;
        border-radius: 12px;
        background: white;
        max-width: 480px;
        width: 100%;
        box-shadow: 0 4px 10px rgba(0,0,0,0.2);
    }
    .card-container {
        display: grid;
        gap: 1rem;
        grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
        justify-content: center;
        margin-top: 20px;
    }
    .card {
        padding: 15px;
        width: 100%;
        min-height: 250px;
        border-radius: 12px;
        text-align: center;
        border: 3px solid;
        box-sizing: border-box;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        transition: transform 0.2s ease, box-shadow 0.2s ease;
        cursor: pointer;
        position: relative;
        overflow: hidden;
    }
    .card:hover {
        transform: scale(1.05);
        box-shadow: 0 8px 15px rgba(0,0,0,0.3);
    }
    .mutation-label {
        position: absolute;
        top: 5px;
        left: 5px;
        background: rgba(0, 0, 0, 0.5);
        color: white;
        padding: 2px 6px;
        border-radius: 8px;
        font-size: 0.75rem;
    }
    .mutation-list {
        margin-top: 10px;
        text-align: left;
        width: 100%;
    }
    .mutation-list h4 {
        margin: 0;
        font-size: 0.9rem;
        color: #444;
    }
    .mutation-list ul {
        list-style: none;
        padding: 0;
        margin: 5px 0 0;
    }
    .mutation-list li {
        font-size: 0.8rem;
        margin-bottom: 2px;
    }
    .common-card {
        background: linear-gradient(#ddd, #bbb);
        border-color: #666;
        color: #444;
    }
    .rare-card {
        background: linear-gradient(#a0d4ff, #66aaff);
        border-color: #004488;
        color: white;
        font-weight: bold;
    }
    .epic-card {
        background: linear-gradient(to bottom right, #a020f0, #800080);
        border-color: #663399;
        color: #eee;
        font-weight: bold;
    }
    .legendary-card {
        background: linear-gradient(to bottom right, #ffcc00, #b8860b);
        border-color: #d4af37;
        color: #333;
        font-weight: bold;
    }
    .divine-card {
        background: linear-gradient(to bottom right, #e0e0ff, #c0c0d4);
        border-color: #9999ff;
        color: #1a1a33;
        font-weight: bold;
    }
    .pristimatic-card {
        background: conic-gradient(red, orange, yellow, green, blue, indigo, violet);
        border-color: #000;
        color: white;
        font-weight: bold;
        text-shadow: 1px 1px 2px black;
    }
    .btn {
        padding: 12px 24px;
        margin: 8px;
        border: none;
        background: #444;
        color: white;
        border-radius: 8px;
        cursor: pointer;
        font-size: 16px;
        transition: background 0.2s ease, transform 0.2s ease;
    }
    .btn:hover {
        background: #666;
        transform: translateY(-2px);
    }
    .btn-blue { background: #0077ff; }
    .btn-blue:hover { background: #0055aa; }
    .btn-purple { background: #800080; }
    .btn-purple:hover { background: #6a0dad; }
    .btn-gold { background: #d4af37; }
    .btn-gold:hover { background: #b8860b; }
    .btn-divine { background: #9999ff; }
    .btn-divine:hover { background: #7a7aff; }
    .btn-pristimatic { background: #e66465; }
    .btn-pristimatic:hover { background: #9198e5; }
    .btn-small { padding: 8px 16px; font-size: 14px; margin: 4px; }
    .locked-card {
        box-shadow: 0 0 10px 3px #ff0000;
    }
    .card-buttons {
        display: flex;
        flex-direction: column;
        gap: 5px;
        margin-top: 10px;
        width: 100%;
    }
    #messageBox, #cardDetailsBox, #stealMessageBox {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        z-index: 1000;
        display: none;
        background: white;
        border-radius: 12px;
        padding: 20px;
        box-shadow: 0 4px 10px rgba(0,0,0,0.2);
    }
    #cardDetailsBox .card {
        cursor: default;
        transform: none;
        box-shadow: none;
    }
    .user-select-buttons {
        display: flex;
        justify-content: center;
        gap: 10px;
        margin-bottom: 20px;
    }
    .header-actions {
        display: flex;
        justify-content: space-between;
        align-items: center;
        width: 100%;
        max-width: 480px;
    }
    @media (max-width: 600px) {
        .card-container {
            grid-template-columns: 1fr;
        }
        .game-box, .login-box {
            padding: 10px;
        }
        .btn {
            padding: 10px 20px;
            font-size: 14px;
        }
    }
</style>
</head>
<body>
<div class="login-box" id="loginBox">
  <h2>Login</h2>
  <input id="username" placeholder="Username" style="padding:10px; border-radius:8px; border:1px solid #ccc; width:80%;"><br><br>
  <input id="password" type="password" placeholder="Password" style="padding:10px; border-radius:8px; border:1px solid #ccc; width:80%;"><br><br>
  <label style="display: flex; align-items: center; justify-content: center; margin: 10px 0;">
    <input type="checkbox" id="keepSignedIn" style="margin-right: 5px;"> Keep me signed in
  </label>
  <button class="btn" onclick="login()">Login</button>
  <p id="loginStatus"></p>
</div>

<div class="game-box" id="gameBox" style="display:none;">
  <div class="header-actions">
    <h2>Welcome <span id="userName"></span></h2>
    <button class="btn btn-small" onclick="logout()">Logout</button>
  </div>
  <p>Balance: $<span id="balance">0</span></p>

  <!-- User Selection Buttons for Stealing -->
  <div class="user-select-buttons">
      <button class="btn btn-blue" onclick="showUserCollection('zezo')">Zezo</button>
      <button class="btn btn-blue" onclick="showUserCollection('layan')">Layan</button>
      <button class="btn btn-blue" onclick="showUserCollection('asser')">Asser</button>
      <button class="btn btn-purple" onclick="showMyCollection()">My Base</button>
  </div>

  <div style="display: flex; flex-wrap: wrap; justify-content: center; margin-bottom: 20px;">
    <button class="btn" onclick="openPack('common')">Buy Common Pack (100%) ($100)</button>
    <button class="btn btn-blue" onclick="openPack('rare')">Buy Rare Pack (100%) ($250)</button>
    <button class="btn btn-purple" onclick="openPack('epic')">Buy Epic Pack (100%) ($350)</button>
    <button class="btn btn-gold" onclick="openPack('legendary')">Buy Legendary Pack (100%) ($1500)</button>
    <button class="btn btn-divine" onclick="openPack('divine')">Buy Divine Pack (100%) ($5000)</button>
    <button class="btn btn-pristimatic" onclick="openPack('pristimatic')">Buy Pristimatic Pack (100%) ($7500)</button>
  </div>
  <div id="openedCard"></div>
  <h3>Your Collection</h3>
  <div id="collection" class="card-container"></div>

  <h3><span id="otherUserHeader"></span>'s Collection</h3>
  <div id="otherUserCollection" class="card-container" style="display:none;"></div>
</div>

<div id="messageBox" style="display:none;">
  <p id="messageText"></p>
  <button class="btn" onclick="closeMessage()">OK</button>
</div>

<div id="cardDetailsBox" style="display:none;">
  <div id="cardDetailsContent"></div>
  <button class="btn" onclick="closeCardDetails()">Close</button>
</div>

<div id="stealMessageBox" style="display:none;">
  <h3>Steal Attempt!</h3>
  <p>Solve this equation to steal the card:</p>
  <h2 id="mathQuestion"></h2>
  <p>Time remaining: <span id="stealTimer">5</span>s</p>
  <input type="number" id="mathAnswer" placeholder="Your Answer" style="padding:10px; border-radius:8px; border:1px solid #ccc; width:80%; margin-top: 10px;">
  <button class="btn" onclick="checkStealAnswer()">Submit</button>
</div>

<!-- Firebase -->
<script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-database-compat.js"></script>

<script>
// --- Firebase Setup ---
const firebaseConfig = {
  apiKey: "AIzaSyDclp6rqCZRVreOzTcxv840mXcl6nDKAv8",
  authDomain: "pack-f76c3.firebaseapp.com",
  databaseURL: "https://pack-f76c3-default-rtdb.firebaseio.com/",
  projectId: "pack-f76c3",
  storageBucket: "pack-f76c3.firebasestorage.app",
  messagingSenderId: "694325056042",
  appId: "1:694325056042:web:aae383919a2ce159892953",
  measurementId: "G-07WXQ7YQ4M"
};
firebase.initializeApp(firebaseConfig);
const db = firebase.database();

// --- Timing Constants (editable) ---
const MUTATION_INTERVAL_MS = 1000 * 60 * 1; // 30 minutes for new global mutation
const DISTRIBUTION_INTERVAL_MS = 1000 * 60 * 1; // 7 minutes to distribute the mutation
const PRESENCE_HEARTBEAT_MS = 1000 * 30; // presence update interval
const PRESENCE_ONLINE_THRESHOLD_MS = 1000 * 60 * 10; // consider users online if seen in last 10 minutes

// --- Game Data ---
const accounts = {
  zezo: "000",
  asser: "230",
  lilly: "246",
  layan: "123"
};

const MUTATION_TIERS = {
  common: { name: "Common", chance: 0.50 },
  uncommon: { name: "Uncommon", chance: 0.25 },
  rare: { name: "Rare", chance: 0.15 },
  veryHard: { name: "Very Hard", chance: 0.10 }
};

const MUTATIONS = {
    plasma: { priceIncrease: 500, tier: 'uncommon' },
    bloom: { priceIncrease: 300, tier: 'common' },
    choc: { priceIncrease: 400, tier: 'common' },
    shocked: { priceIncrease: 650, tier: 'rare' },
    rainbow: { priceIncrease: 500, tier: 'uncommon' },
    burnt: { priceIncrease: 350, tier: 'uncommon' },
    chilled: { priceIncrease: 550, tier: 'rare' },
    frozen: { priceIncrease: 350, tier: 'common' },
    brainrot: { priceIncrease: 600, tier: 'veryHard' },
    zezoplot: { priceIncrease: 700, tier: 'veryHard' }
};

let cardPools = {
    common: [
    { name: "asser", quantity: 50, chance: 0.25, price: 110 },
    { name: "asser eat", quantity: 50, chance: 0.15, price: 120 },
    { name: "asser angry", quantity: 50, chance: 0.15, price: 130 },
    { name: "asser cry", quantity: 50, chance: 0.10, price: 150 },
    { name: "asser sad", quantity: 50, chance: 0.10, price: 140 },
    { name: "asser happy", quantity: 50, chance: 0.15, price: 130 },
    { name: "asser sleep", quantity: 50, chance: 0.10, price: 130 }
  ],
  rare: [
    { name: "Blue Asser", quantity: 40, chance: 0.30, price: 260 },
    { name: "Asser Dragon", quantity: 40, chance: 0.25, price: 280 },
    { name: "Asser Galaxy", quantity: 35, chance: 0.20, price: 300 },
    { name: "Asser Legend", quantity: 10, chance: 0.15, price: 350 },
    { name: "Asser Mythic", quantity: 15, chance: 0.10, price: 400 }
  ],
  epic: [
    { name: "lilly eat", quantity: 50, chance: 0.15, price: 360 },
    { name: "lilly angry", quantity: 50, chance: 0.15, price: 365 },
    { name: "lilly sad", quantity: 50, chance: 0.10, price: 360 },
    { name: "lilly happy", quantity: 50, chance: 0.15, price: 380 },
    { name: "lilly sleep", quantity: 50, chance: 0.10, price: 370 },
    { name: "lilly", quantity: 50, chance: 0.25, price: 355 },
    { name: "Lilly Bomba", quantity: 10, chance: 0.10, price: 600 }
  ],
  legendary: [
      { name: "Lilly laugh", quantity: 10, chance: 0.40, price: 1550 },
      { name: "Lilly Queen", quantity: 10, chance: 0.40, price: 1550 },
      { name: "Lilly Dragon", quantity: 7, chance: 0.10, price: 1700 },
      { name: "Lilly Hero", quantity: 4, chance: 0.10, price: 1500 }
  ],
  divine: [
      { name: "Zezo laugh", quantity: 15, chance: 0.10, price: 5600 },
      { name: "Zezo sad", quantity: 15, chance: 0.10, price: 5650 },
      { name: "Zezo angry", quantity: 10, chance: 0.10, price: 5800 },
      { name: "Zezo ps5", quantity: 10, chance: 0.20, price: 5700 },
      { name: "Zezo happy", quantity: 15, chance: 0.10, price: 5600 },
      { name: "Zezo smile", quantity: 5, chance: 0.10, price: 5620 },
      { name: "Zezo roblox", quantity: 5, chance: 0.10, price: 5750 },
      { name: "Zezo fart", quantity: 6, chance: 0.05, price: 6000 },
      { name: "normal zezo full", quantity: 3, chance: 0.15, price: 5850 }
  ],
  pristimatic: [
      { name: "Zezo Prismatic", quantity: 2, chance: 0.40, price: 7500 },
      { name: "Zezo Rainbow", quantity: 2, chance: 0.40, price: 7800 },
      { name: "Asser colotinni fasatennee", quantity: 2, chance: 0.40, price: 8000 },
      { name: "zezo big bomba fart", quantity: 2, chance: 0.40, price: 12000 },
      { name: "lilly kowaferr", quantity: 2, chance: 0.40, price: 8000 },
      { name: "Zezo shower", quantity: 2, chance: 0.20, price: 8500 }
  ]
};

// --- Game State Variables ---
let currentUser = null;
let balance = 0;
let collection = {}; 
let lockedCards = {};
let currentHourlyMutation = null;
let stealData = {};
let stealTimerInterval = null;
let lastSeenMutationTimestamp = 0;
let presenceInterval = null;

// --- Firebase refs for mutation/distribution/presence ---
const mutationRef = db.ref("game/currentMutation");
const distributionRef = db.ref("game/lastDistribution");
const presenceRefRoot = db.ref("presence");

// --- Utility Functions ---
function generateCardId() {
  return Date.now().toString() + Math.random().toString().substr(2, 6);
}

function getCardType(cardName) {
  if (cardPools.common.some(c => c.name === cardName)) return 'common';
  if (cardPools.rare.some(c => c.name === cardName)) return 'rare';
  if (cardPools.epic.some(c => c.name === cardName)) return 'epic';
  if (cardPools.legendary.some(c => c.name === cardName)) return 'legendary';
  if (cardPools.divine.some(c => c.name === cardName)) return 'divine';
  if (cardPools.pristimatic.some(c => c.name === cardName)) return 'pristimatic';
  return '';
}

function getBaseCardPrice(cardName) {
  const allCards = [...cardPools.common, ...cardPools.rare, ...cardPools.epic, ...cardPools.legendary, ...cardPools.divine, ...cardPools.pristimatic];
  const card = allCards.find(c => c.name === cardName);
  return card ? card.price : 0;
}

function getCardQuantity(cardName) {
  const allCards = [...cardPools.common, ...cardPools.rare, ...cardPools.epic, ...cardPools.legendary, ...cardPools.divine, ...cardPools.pristimatic];
  const card = allCards.find(c => c.name === cardName);
  return card ? card.quantity : 0;
}

function showMessage(message) {
  document.getElementById('messageText').innerText = message;
  document.getElementById('messageBox').style.display = 'block';
}

function closeMessage() {
  document.getElementById('messageBox').style.display = 'none';
}

function showCardDetails(cardId) {
  const card = collection[cardId] || lockedCards[cardId];
  if (!card) return;

  const mutationListHtml = card.mutations && card.mutations.length > 0
    ? `<div class="mutation-list">
         <h4>Mutations:</h4>
         <ul>
           ${card.mutations.map(m => `<li>${m.name} (+${m.priceIncrease || m.priceIncrease === 0 ? m.priceIncrease : ''})</li>`).join('')}
         </ul>
       </div>`
    : `<p>This card has no mutations yet.</p>`;

  const cardHtml = `
    <div class="card ${getCardType(card.name)}-card" data-card-id="${cardId}">
      <h3>${card.name}</h3>
      <p>Base Value: $${getBaseCardPrice(card.name)}</p>
      <p>Current Value: $${card.currentPrice}</p>
      ${mutationListHtml}
    </div>
  `;
  document.getElementById('cardDetailsContent').innerHTML = cardHtml;
  document.getElementById('cardDetailsBox').style.display = 'block';
}

function closeCardDetails() {
  document.getElementById('cardDetailsBox').style.display = 'none';
}


// --- User & Data Management ---
window.onload = function() {
  const lastUser = localStorage.getItem("lastLoggedInUser");
  const keepSignedIn = localStorage.getItem("keepSignedIn");
  if (lastUser && keepSignedIn === "true") {
    document.getElementById("username").value = lastUser;
    document.getElementById("keepSignedIn").checked = true;
    const pass = accounts[lastUser];
    if (pass) {
        document.getElementById("password").value = pass;
        login();
    }
  }

  // Ensure there's a current mutation (reads, and if expired, updates it) but DO NOT distribute immediately on page load.
  ensureCurrentMutation().then(mut => {
    currentHourlyMutation = mut;
    if (currentHourlyMutation && currentHourlyMutation.timestamp) lastSeenMutationTimestamp = currentHourlyMutation.timestamp;
    console.log("Initial mutation (ensured):", currentHourlyMutation);
    // NOTE: we intentionally DO NOT call distributeMutation() here so refresh/open doesn't trigger a distribution.
  }).catch(err => console.error("Error ensuring mutation on load:", err));

  // Periodically ensure mutation exists & is fresh (every MUTATION_INTERVAL_MS)
  setInterval(() => {
    ensureCurrentMutation().then(mut => {
      currentHourlyMutation = mut;
      if (currentHourlyMutation && currentHourlyMutation.timestamp && currentUser && currentHourlyMutation.timestamp > lastSeenMutationTimestamp) {
        lastSeenMutationTimestamp = currentHourlyMutation.timestamp;
        showMessage(`New mutation is active: ${currentHourlyMutation.name}`);
        updateUI();
      }
    }).catch(err => console.error("Error in scheduled ensureCurrentMutation:", err));
  }, MUTATION_INTERVAL_MS);

  // Distribution cycle: attempt to claim the distribution slot every DISTRIBUTION_INTERVAL_MS.
  setInterval(() => {
    tryClaimAndDistribute();
  }, DISTRIBUTION_INTERVAL_MS);
};

function login() {
  const u = document.getElementById("username").value.trim();
  const p = document.getElementById("password").value.trim();
  const keepSignedIn = document.getElementById("keepSignedIn").checked;

  if (accounts[u] && accounts[u] === p) {
    currentUser = u;
    if (keepSignedIn) {
        localStorage.setItem("lastLoggedInUser", u);
        localStorage.setItem("keepSignedIn", "true");
    } else {
        localStorage.removeItem("lastLoggedInUser");
        localStorage.removeItem("keepSignedIn");
    }
    document.getElementById("loginBox").style.display = "none";
    document.getElementById("gameBox").style.display = "block";
    document.getElementById("userName").innerText = u;
    loadUserData();
    startPresence(); // mark user online
  } else {
    document.getElementById("loginStatus").innerText = "Invalid credentials!";
  }
}

function logout() {
    stopPresence();
    currentUser = null;
    balance = 0;
    collection = {};
    lockedCards = {};
    localStorage.removeItem("lastLoggedInUser");
    localStorage.removeItem("keepSignedIn");
    document.getElementById("gameBox").style.display = "none";
    document.getElementById("loginBox").style.display = "block";
    document.getElementById("username").value = "";
    document.getElementById("password").value = "";
    document.getElementById("loginStatus").innerText = "";
    document.getElementById("keepSignedIn").checked = false;
    updateUI();
}

function startPresence() {
  if (!currentUser) return;
  const pRef = db.ref(`presence/${currentUser}`);
  pRef.set({ lastSeen: Date.now() }).catch(err => console.error('presence set err', err));
  presenceInterval = setInterval(() => {
    pRef.update({ lastSeen: Date.now() }).catch(err => console.error('presence update err', err));
  }, PRESENCE_HEARTBEAT_MS);
  // try to remove presence on unload
  window.addEventListener('beforeunload', () => {
    try { pRef.remove(); } catch (e) {}
  });
}

function stopPresence() {
  if (!currentUser) return;
  const pRef = db.ref(`presence/${currentUser}`);
  pRef.remove().catch(err => console.error('presence remove err', err));
  if (presenceInterval) {
    clearInterval(presenceInterval);
    presenceInterval = null;
  }
}

function loadUserData() {
  db.ref("users/" + currentUser).once("value").then(snap => {
    if (snap.exists()) {
      const userData = snap.val();
      balance = userData.balance || 100;
      collection = userData.collection || {};
      lockedCards = userData.lockedCards || {};
    } else {
      balance = 100;
      collection = {};
      lockedCards = {};
      saveUser();
    }
    loadCardQuantities();
  });
  checkNotifications();
}

function loadCardQuantities() {
  db.ref("cardQuantities").once("value").then(snap => {
    if (snap.exists()) {
      const dbQuantities = snap.val();
      for (const packType in cardPools) {
        cardPools[packType].forEach(card => {
          if (dbQuantities[card.name] !== undefined) {
            card.quantity = dbQuantities[card.name];
          }
        });
      }
    } else {
      saveCardQuantities();
    }
    updateUI();
    updatePackChances();
  });
}

function saveUser() {
  return db.ref("users/" + currentUser).set({
    balance: balance,
    collection: collection,
    lockedCards: lockedCards
  });
}

function saveCardQuantities() {
  const quantities = {};
  for (const packType in cardPools) {
    cardPools[packType].forEach(card => {
      quantities[card.name] = card.quantity;
    });
  }
  return db.ref("cardQuantities").set(quantities);
}

function checkNotifications() {
  const notificationsRef = db.ref(`notifications/${currentUser}`);
  notificationsRef.once("value").then(snap => {
    if (snap.exists()) {
      const notifications = snap.val();
      for (const key in notifications) {
        showMessage(notifications[key]);
      }
      notificationsRef.remove();
    }
  });
}

// --- Core Game Logic ---
function updateUI() {
  document.getElementById("balance").innerText = balance;
  document.getElementById("collection").innerHTML = renderCollection(collection, lockedCards, true);
  document.getElementById("otherUserCollection").style.display = 'none';
  document.getElementById("otherUserHeader").style.display = 'none';
}

function showMyCollection() {
    document.getElementById("collection").style.display = 'block';
    document.getElementById("otherUserCollection").style.display = 'none';
    document.getElementById("otherUserHeader").style.display = 'none';
}

function renderCollection(cardCollection, lockedCards, isMyCollection = false, victimId = null) {
  let collHTML = "";
  const allCards = { ...cardCollection, ...lockedCards };

  if (Object.keys(allCards).length === 0) {
    return "This user has no cards yet.";
  }

  for (let cardId in allCards) {
    const card = allCards[cardId];
    if (card) {
      const cardType = getCardType(card.name);
      const isLocked = !!lockedCards[cardId];
      const cardClass = isLocked ? 'locked-card' : '';
      const mutationsCount = (card.mutations && card.mutations.length) || 0;
      const mutationLabel = mutationsCount > 0 ? `<span class="mutation-label">${mutationsCount}x Mutated</span>` : '';
      
      let buttonsHtml = '';
      if (isMyCollection) {
        buttonsHtml = `
          <button class="btn btn-small" onclick="event.stopPropagation(); ${isLocked ? `unlockCard('${cardId}')` : `lockCard('${cardId}')`}">${isLocked ? 'Unlock' : 'Lock'}</button>
          <button class="btn btn-small" onclick="event.stopPropagation(); sellCard('${cardId}')" ${isLocked ? 'disabled' : ''}>Sell ($${card.currentPrice})</button>
        `;
      } else {
        buttonsHtml = `
          <button class="btn btn-small btn-gold" onclick="event.stopPropagation(); startStealAttempt('${cardId}', '${victimId}')">Steal</button>
        `;
      }

      collHTML += `
      <div class="card ${cardType}-card ${cardClass}" onclick="showCardDetails('${cardId}')">
        ${mutationLabel}
        <h3>${card.name}</h3>
        <p>Value: $${card.currentPrice}</p>
        <div class="card-buttons">
            ${buttonsHtml}
        </div>
      </div>`;
    }
  }
  return collHTML;
}

function showUserCollection(targetUser) {
    if (targetUser === currentUser) {
      showMessage("You can't steal from yourself! Use 'My Base' instead.");
      return;
    }

    document.getElementById("collection").style.display = 'none';
    document.getElementById("otherUserCollection").style.display = 'block';
    document.getElementById("otherUserHeader").innerText = targetUser;
    document.getElementById("otherUserHeader").style.display = 'block';
    
    db.ref("users/" + targetUser).once("value").then(snap => {
        if (!snap.exists()) {
            document.getElementById("otherUserCollection").innerHTML = `<p>${targetUser} isn't playing this game!</p>`;
            return;
        }

        const userData = snap.val();
        const otherCollection = userData.collection || {};
        const otherLockedCards = userData.lockedCards || {};
        
        document.getElementById("otherUserCollection").innerHTML = renderCollection(otherCollection, otherLockedCards, false, targetUser);
    }).catch(error => {
        console.error("Error loading user data:", error);
        document.getElementById("otherUserCollection").innerHTML = `<p>Error loading ${targetUser}'s data.</p>`;
    });
}

function lockCard(cardId) {
  const cardToLock = collection[cardId];
  if (!cardToLock) return showMessage("Card not found in collection.");
  
  cardToLock.isLocked = true;
  cardToLock.lockTime = Date.now();
  cardToLock.lastMutationTime = Date.now();
  cardToLock.mutations = cardToLock.mutations || [];

  lockedCards[cardId] = cardToLock;
  delete collection[cardId];

  saveUser();
  updateUI();
  showMessage(`Card "${cardToLock.name}" has been locked.`);
}

function unlockCard(cardId) {
  const cardToUnlock = lockedCards[cardId];
  if (!cardToUnlock) return showMessage("Card not found in locked cards.");

  cardToUnlock.isLocked = false;
  cardToUnlock.lockTime = 0;

  collection[cardId] = cardToUnlock;
  delete lockedCards[cardId];

  saveUser();
  updateUI();
  showMessage(`Card "${cardToUnlock.name}" has been unlocked.`);
}

function openPack(type) {
  let packPrice = 0;
  let pool = [];

    if (type === "common") {
    packPrice = 100;
    pool = cardPools.common;
  } else if (type === "rare") {
    packPrice = 250;
    pool = cardPools.rare;
  } else if (type === "epic") {
    packPrice = 350;
    pool = cardPools.epic;
  } else if (type === "legendary") {
    packPrice = 1500;
    pool = cardPools.legendary;
  } else if (type === "divine") {
    packPrice = 5000;
    pool = cardPools.divine;
  } else if (type === "pristimatic") {
    packPrice = 7500;
    pool = cardPools.pristimatic;
  }

  if (balance < packPrice) {
    showMessage("Not enough money!");
    return;
  }

  balance -= packPrice;

  let available = pool.filter(c => c.quantity > 0);
  if (available.length === 0) {
      showMessage("This pack is sold out!");
      return;
  }
  
  let rand = Math.random();
  let sum = 0;
  let chosenCardTemplate = available[0];
  for (let card of available) {
    sum += card.chance;
    if (rand <= sum) { 
      chosenCardTemplate = card; 
      break; 
    }
  }

  const chosenCardInPool = pool.find(card => card.name === chosenCardTemplate.name);
  if (chosenCardInPool) {
      chosenCardInPool.quantity--;
  }

  const newCardId = generateCardId();
  const newCard = {
    id: newCardId,
    name: chosenCardTemplate.name,
    basePrice: chosenCardTemplate.price,
    currentPrice: chosenCardTemplate.price,
    isLocked: false,
    lockTime: 0,
    lastMutationTime: Date.now(),
    mutations: []
  };

  collection[newCardId] = newCard;
  
  saveUser();
  saveCardQuantities();
  updateUI();
  
  document.getElementById("openedCard").innerHTML = `
    <div class="card ${getCardType(newCard.name)}-card">
      <h3>${newCard.name}</h3>
      <p>Value: $${newCard.currentPrice}</p>
      <p>Added to your collection!</p>
    </div>`;
}

function sellCard(cardId) {
  const cardToSell = collection[cardId];
  if (!cardToSell) {
    showMessage("Card not found!");
    return;
  }

  balance += cardToSell.currentPrice;
  delete collection[cardId];
  
  saveUser();
  updateUI();
  showMessage(`Sold card "${cardToSell.name}" for $${cardToSell.currentPrice}.`);
}

function updatePackChances() {
  const packs = [
    { type: 'common', pool: cardPools.common, button: document.querySelector('.btn') },
    { type: 'rare', pool: cardPools.rare, button: document.querySelector('.btn-blue') },
    { type: 'epic', pool: cardPools.epic, button: document.querySelector('.btn-purple') },
    { type: 'legendary', pool: cardPools.legendary, button: document.querySelector('.btn-gold') },
    { type: 'divine', pool: cardPools.divine, button: document.querySelector('.btn-divine') },
    { type: 'pristimatic', pool: cardPools.pristimatic, button: document.querySelector('.btn-pristimatic') }
  ];

  packs.forEach(pack => {
    let totalChance = 0;
    const availableCards = pack.pool.filter(card => getCardQuantity(card.name) > 0);
    availableCards.forEach(card => totalChance += card.chance);

    let chanceText = `(${Math.round(totalChance * 100)}%)`;
    const packPrice = pack.type === 'common' ? 100 : pack.type === 'rare' ? 250 : pack.type === 'epic' ? 350 : pack.type === 'legendary' ? 1500 : pack.type === 'divine' ? 5000 : 7500;
    if (pack.button) pack.button.innerText = `Buy ${pack.type.charAt(0).toUpperCase() + pack.type.slice(1)} Pack ${chanceText} ($${packPrice})`;
  });
}

// --- MUTATION / FIREBASE SYNC ---
// listen for realtime updates (keeps clients synced and can notify logged-in users)
mutationRef.on("value", snap => {
  const m = snap.val();
  if (!m) return;
  currentHourlyMutation = { name: m.name, priceIncrease: m.priceIncrease, timestamp: m.timestamp || 0 };
  console.log("Mutation updated from Firebase (on value):", currentHourlyMutation);
  if (currentHourlyMutation.timestamp > lastSeenMutationTimestamp) {
    lastSeenMutationTimestamp = currentHourlyMutation.timestamp;
    if (currentUser) {
      showMessage(`New mutation is active: ${currentHourlyMutation.name}`);
      updateUI();
    }
  }
});

// Ensure there is a current mutation; if missing or expired, create one then return the (new) current mutation.
function ensureCurrentMutation() {
  return new Promise(async (resolve, reject) => {
    try {
      const snap = await mutationRef.once('value');
      const now = Date.now();
      const current = snap.val();

      // If no mutation or it's stale -> transaction to try set a new one
      if (!current || (now - (current.timestamp || 0)) > MUTATION_INTERVAL_MS) {
        mutationRef.transaction(curr => {
          const then = Date.now();
          if (!curr || (then - (curr.timestamp || 0)) > MUTATION_INTERVAL_MS) {
            const newMut = getRandomMutation();
            return { name: newMut.name, priceIncrease: newMut.priceIncrease, timestamp: then };
          }
          return; // someone else already set a fresh mutation
        }, async (error, committed, snapshot) => {
          if (error) {
            console.error('Transaction error ensuring mutation:', error);
            return reject(error);
          }
          try {
            const finalSnap = await mutationRef.once('value');
            const finalVal = finalSnap.val();
            resolve(finalVal);
          } catch (e) {
            reject(e);
          }
        });
      } else {
        // current exists and is fresh
        resolve(current);
      }
    } catch (err) {
      reject(err);
    }
  });
}

// Attempt to claim the distribution slot with a transaction. Only the client that succeeds will call distributeMutation().
function tryClaimAndDistribute() {
  const now = Date.now();
  distributionRef.transaction(curr => {
    if (!curr || (now - (curr.timestamp || 0)) > DISTRIBUTION_INTERVAL_MS) {
      // claim this distribution slot
      return { timestamp: now, by: currentUser || 'anonymous' };
    }
    return; // someone else already claimed within the interval
  }, async (error, committed, snapshot) => {
    if (error) {
      console.error('Distribution claim transaction error:', error);
      return;
    }
    if (!committed) {
      console.log('Distribution slot already claimed by another client. Skipping.');
      return;
    }
    // we successfully claimed the slot; now apply the mutation once
    console.log('Distribution slot claimed — proceeding to mutate one locked card from online users.');
    await distributeMutation();
  });
}

// Distribution will *read* the canonical mutation from Firebase before mutating cards.
// It will only mutate ONE locked card across all online users.
async function distributeMutation() {
  try {
    const mutSnap = await mutationRef.once("value");
    const mutObj = mutSnap.val();
    if (!mutObj) {
      console.log("No current mutation available in Firebase. Skipping distribution.");
      return;
    }

    // Build the mutation object we'll append to cards
    const mutationToApply = { name: mutObj.name, priceIncrease: mutObj.priceIncrease, appliedAt: Date.now() };

    // Read presence to filter online users only
    const presenceSnap = await presenceRefRoot.once('value');
    const presenceData = presenceSnap.val() || {};
    const now = Date.now();

    const allUsersSnapshot = await db.ref("users").once("value");
    const allUsersData = allUsersSnapshot.val();
    if (!allUsersData) {
      console.log("No user data found. Cannot distribute mutation.");
      return;
    }

    let candidateLockedCards = [];
    for (const userId in allUsersData) {
      // skip users that are not "online" according to presence
      const pres = presenceData[userId];
      if (!pres) continue;
      if ((now - pres.lastSeen) > PRESENCE_ONLINE_THRESHOLD_MS) continue; // not online recently

      const userData = allUsersData[userId];
      const lockedCardsForUser = userData.lockedCards || {};
      for (const cardId in lockedCardsForUser) {
        const card = lockedCardsForUser[cardId];
        if ((card.mutations || []).length < 5) {
          candidateLockedCards.push({ userId, cardId, card });
        }
      }
    }

    if (candidateLockedCards.length === 0) {
      console.log("No locked cards from online users available to mutate.");
      return;
    }

    // Randomly pick one locked card to mutate among online users
    const randomIndex = Math.floor(Math.random() * candidateLockedCards.length);
    const cardToMutate = candidateLockedCards[randomIndex];
    const { userId, cardId, card } = cardToMutate;

    card.mutations = card.mutations || [];
    card.mutations.push(mutationToApply);
    card.currentPrice = (card.currentPrice || card.basePrice || 0) + mutationToApply.priceIncrease;
    card.lastMutationTime = Date.now();

    // Save mutated card back to that user's lockedCards
    await db.ref(`users/${userId}/lockedCards/${cardId}`).set(card);

    console.log(`Successfully applied mutation "${mutationToApply.name}" to card "${card.name}" for user "${userId}".`);

    if (userId === currentUser) {
      lockedCards[cardId] = card;
      updateUI();
      showMessage(`Your card "${card.name}" received mutation: ${mutationToApply.name}`);
    }
  } catch (error) {
    console.error("Error distributing mutation:", error);
  }
}

function getRandomMutation() {
  const mutationsWithChances = Object.keys(MUTATIONS).map(key => {
    const mutation = MUTATIONS[key];
    const tierChance = MUTATION_TIERS[mutation.tier].chance;
    return {
      name: key,
      priceIncrease: mutation.priceIncrease,
      chance: tierChance
    };
  });

  const totalChance = mutationsWithChances.reduce((sum, m) => sum + m.chance, 0);
  let rand = Math.random() * totalChance;
  let sum = 0;

  for (const mutation of mutationsWithChances) {
    sum += mutation.chance;
    if (rand <= sum) {
      return { name: mutation.name, priceIncrease: mutation.priceIncrease };
    }
  }

  return { name: 'bloom', priceIncrease: 300 };
}

// --- Steal Logic (unchanged) ---
async function startStealAttempt(cardId, victimId) {
    document.getElementById('cardDetailsBox').style.display = 'none';
    document.getElementById('messageBox').style.display = 'none';
    
    const victimRef = db.ref(`users/${victimId}`);
    const victimSnapshot = await victimRef.once('value');
    if (!victimSnapshot.exists()) {
        showMessage("The victim's account no longer exists!");
        return;
    }

    const victimData = victimSnapshot.val();
    const allVictimCards = {...(victimData.collection || {}), ...(victimData.lockedCards || {})};
    const cardToSteal = allVictimCards[cardId];

    if (!cardToSteal) {
        showMessage("This card is no longer available to steal!");
        showUserCollection(victimId);
        return;
    }

    const num1 = Math.floor(Math.random() * 10) + 1;
    const num2 = Math.floor(Math.random() * 10) + 1;
    const operator = Math.random() < 0.5 ? '+' : '-';
    const question = `${num1} ${operator} ${num2}`;
    const answer = operator === '+' ? num1 + num2 : num1 - num2;

    stealData = {
        cardToSteal: cardToSteal,
        cardId: cardId,
        victimId: victimId,
        answer: answer,
        startTime: Date.now()
    };

    document.getElementById('mathQuestion').innerText = question;
    document.getElementById('mathAnswer').value = '';
    document.getElementById('stealMessageBox').style.display = 'block';
    
    let timeRemaining = 5;
    document.getElementById('stealTimer').innerText = timeRemaining;
    
    if (stealTimerInterval) {
        clearInterval(stealTimerInterval);
    }
    
    stealTimerInterval = setInterval(() => {
        timeRemaining--;
        document.getElementById('stealTimer').innerText = timeRemaining;
        if (timeRemaining <= 0) {
            clearInterval(stealTimerInterval);
            document.getElementById('stealMessageBox').style.display = 'none';
            showMessage(`Time's up! You failed to steal ${cardToSteal.name}.`);
        }
    }, 1000);
}

async function checkStealAnswer() {
    const userAnswer = parseInt(document.getElementById('mathAnswer').value);
    
    if (isNaN(userAnswer)) {
        showMessage("Please enter a valid number!");
        return;
    }

    clearInterval(stealTimerInterval);
    document.getElementById('stealMessageBox').style.display = 'none';
    
    if (userAnswer === stealData.answer) {
        await finalizeSteal(stealData.cardId, stealData.victimId, stealData.cardToSteal);
    } else {
        showMessage(`Wrong answer! You failed to steal ${stealData.cardToSteal.name}.`);
    }
}

async function finalizeSteal(cardId, victimId, cardToSteal) {
    try {
        const victimRef = db.ref(`users/${victimId}`);
        const thiefRef = db.ref(`users/${currentUser}`);

        const victimSnapshot = await victimRef.once('value');
        if (!victimSnapshot.exists()) {
            showMessage("The victim's account no longer exists!");
            return;
        }
        const victimData = victimSnapshot.val();

        let cardFound = false;
        if (victimData.collection && victimData.collection[cardId]) {
            delete victimData.collection[cardId];
            cardFound = true;
        } else if (victimData.lockedCards && victimData.lockedCards[cardId]) {
            delete victimData.lockedCards[cardId];
            cardFound = true;
        }

        if (!cardFound) {
            showMessage("The card was not found in the victim's collection. It might have already been stolen.");
            return;
        }

        cardToSteal.isLocked = false;
        cardToSteal.lockTime = 0;
        collection[cardId] = cardToSteal;

        await victimRef.child('collection').set(victimData.collection || {});
        await victimRef.child('lockedCards').set(victimData.lockedCards || {});
        await saveUser();

        await db.ref(`notifications/${victimId}`).push().set(`Your card "${cardToSteal.name}" was stolen by ${currentUser}!`);
        
        showMessage(`Success! You have stolen ${cardToSteal.name} from ${victimId}!`);
        updateUI();

    } catch (error) {
        console.error("Error finalizing steal:", error);
        showMessage("An error occurred while stealing the card.");
    }
}
</script>

<!-- Centered Welcome Button + Brainrot Audio -->
<div id="welcome-container" style="
  position: fixed;
  top: 0; left: 0;
  width: 100%; height: 100%;
  display: flex;
  align-items: center;
  justify-content: center;
  background: rgba(0,0,0,0.7);
  z-index: 9999;">
  
  <button id="welcome-btn" style="
    font-size: 24px;
    padding: 20px 40px;
    border: none;
    border-radius: 12px;
    background: #6a0dad;
    color: white;
    cursor: pointer;
    box-shadow: 0 4px 12px rgba(0,0,0,0.3);">
    Welcome
  </button>
</div>

<audio id="brainrot-audio" src="brainrot.mp3" preload="auto"></audio>

<script>
  document.getElementById("welcome-btn").addEventListener("click", () => {
    const audio = document.getElementById("brainrot-audio");
    audio.play().catch(err => console.log("Audio play failed:", err));
    document.getElementById("welcome-container").style.display = "none";
  });
</script>

<!-- Refresh Button (Top Right) -->
<button id="refresh-btn" style="
  position: fixed;
  top: 20px;
  right: 20px;
  padding: 12px 20px;
  font-size: 18px;
  border: none;
  border-radius: 10px;
  background: #2196f3;
  color: white;
  cursor: pointer;
  box-shadow: 0 4px 10px rgba(0,0,0,0.3);
  z-index: 9999;">
  🔄 Refresh
</button>

<script>
  document.getElementById("refresh-btn").addEventListener("click", () => {
    location.reload();
  });
</script>

</body>
</html>
