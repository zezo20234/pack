<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Mini Tournament — Semifinal (#2 vs #3) + Final vs #1 (AHLY)</title>
<style>
  :root{
    --bg:#071027; --card:#071827; --muted:#9aa7bf; --accent:#3b82f6;
    --glass: rgba(255,255,255,0.03);
    --win:#16a34a; --lose:#ef4444; --neutral:#e6eef8;
  }
  *{box-sizing:border-box;font-family:Inter,system-ui,Segoe UI,Roboto,Arial;}
  body{margin:0;background:linear-gradient(180deg,#041025 0%, #06102a 100%);color:var(--neutral);-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;}
  .wrap{max-width:1100px;margin:0 auto;padding:20px;}
  header{display:flex;align-items:center;justify-content:space-between;margin-bottom:18px;}
  h1{margin:0;font-size:20px;}
  .lead{color:var(--muted);font-size:13px;margin-top:6px;}
  .grid{display:grid;grid-template-columns:1fr 380px;gap:18px;align-items:start;}
  .card{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));border-radius:12px;padding:14px;border:1px solid rgba(255,255,255,0.03);}
  table{width:100%;border-collapse:collapse;font-size:14px;}
  th,td{padding:10px 8px;text-align:left;}
  thead th{font-size:12px;color:var(--muted);text-transform:uppercase;}
  tbody tr{border-top:1px dashed rgba(255,255,255,0.03);}
  .team{font-weight:700;}
  .btn{padding:8px 10px;border-radius:8px;border:0;font-weight:700;cursor:pointer;}
  .btn-start{background:linear-gradient(90deg,var(--accent),#6cb1ff);color:#04203d;}
  .btn-reset{background:transparent;border:1px solid rgba(255,255,255,0.06);color:var(--muted);}
  .small{font-size:13px;color:var(--muted);}
  .score-display{font-weight:900;font-size:16px;}
  .status{font-size:12px;color:var(--muted);}

  /* Fullscreen modal styles */
  .modal-backdrop{position:fixed;inset:0;background:rgba(0,0,0,0.6);display:none;align-items:flex-start;justify-content:center;z-index:60;overflow:auto;}
  .modal{background:var(--card);width:100vw;height:100vh;border-radius:0;padding:28px;display:grid;grid-template-columns:1fr 1fr;gap:18px;align-items:center;}
  .modal-top{grid-column:1 / -1;display:flex;justify-content:space-between;align-items:center;}
  #modalTimer{font-weight:900;font-size:32px;text-align:center;padding:8px 14px;border-radius:10px;background:rgba(255,255,255,0.02);min-width:220px;}
  .team-block{text-align:center;padding:18px;border-radius:10px;background:rgba(255,255,255,0.02);display:flex;flex-direction:column;align-items:center;justify-content:center;height:calc(100vh - 160px);}
  .team-name{font-weight:900;font-size:26px;margin-bottom:12px;}
  .goals{font-size:96px;font-weight:900;margin:10px 0;min-height:1em;}
  .goal-btns{display:flex;gap:12px;justify-content:center;}
  .goal-btn{width:56px;height:56px;border-radius:12px;border:0;font-size:28px;font-weight:800;cursor:pointer;background:rgba(255,255,255,0.04);color:var(--neutral);}
  .controls{grid-column:1 / -1;display:flex;gap:12px;align-items:center;justify-content:center;margin-top:6px;}
  .time-label{font-size:14px;color:var(--muted);margin-right:8px;}
  .timer-controls{display:flex;gap:8px;align-items:center;}
  .btn-end{background:linear-gradient(90deg,#ff6b6b,#ff9393);color:#2a0a0a;}
  .winner{color:var(--win);}
  .loser{color:var(--lose);}

  @media (max-width:1000px){
    .grid{grid-template-columns:1fr;}
    .modal{grid-template-columns:1fr; padding:18px;}
    .team-block{height:auto; padding:16px;}
    .goals{font-size:64px;}
    .team-name{font-size:20px;}
    #modalTimer{font-size:28px;}
  }
</style>
</head>
<body>
<div class="wrap">
  <header>
    <div>
      <h1>Mini Tournament — Semifinal (#2 vs #3) + Final vs #1</h1>
      <div class="lead">Teams: <strong>Barca</strong>, <strong>Man City</strong>, <strong>AHLY</strong>. Regular season (15 matches total). After that: Semifinal (#2 vs #3) → winner plays #1 in Final. Use the fullscreen controller to run/save matches (admin code required).</div>
    </div>
    <div style="text-align:right">
      <div class="status">DB status: <span id="dbStatus">connecting…</span></div>
    </div>
  </header>

  <div class="grid">
    <main>
      <div class="card">
        <h2 style="margin:0 0 12px">Regular Matches (15)</h2>
        <div id="daysContainer"></div>
      </div>

      <div class="card" style="margin-top:12px;">
        <h2 style="margin:0 0 8px">Playoffs</h2>

        <div style="margin-bottom:10px">
          <strong>Semifinal — #2 vs #3 (from leaderboard)</strong>
          <div class="small" style="margin-top:6px">This will automatically pick the current leaderboard 2nd and 3rd teams.</div>
          <div style="display:flex;gap:8px;align-items:center;margin-top:8px;">
            <button class="btn btn-start" id="startSemiBtn">Start Semifinal</button>
            <button class="btn btn-reset" id="resetSemiBtn">Reset Semifinal</button>
            <div style="margin-left:auto" class="small" id="semiResult">No semifinal played yet</div>
          </div>
        </div>

        <hr style="border:none;border-top:1px solid rgba(255,255,255,0.03);margin:12px 0" />

        <div>
          <strong>Final — #1 vs Semifinal Winner</strong>
          <div class="small" style="margin-top:6px">After semifinal finishes, start the final — top #1 vs semifinal winner.</div>
          <div style="display:flex;gap:8px;align-items:center;margin-top:8px;">
            <button class="btn btn-start" id="startFinalBtn">Start Final</button>
            <button class="btn btn-reset" id="resetFinalBtn">Reset Final</button>
            <div style="margin-left:auto" class="small" id="finalResult">No final played yet</div>
          </div>
        </div>
      </div>
    </main>

    <aside>
      <div class="card">
        <h3 style="margin:0 0 8px">Leaderboard</h3>
        <div id="leaderboardWrap"></div>
        <div class="small" style="margin-top:8px">Sorted by points → goal difference → goals for → name.</div>
      </div>
    </aside>
  </div>

  <footer style="margin-top:14px;color:var(--muted);font-size:13px">Copy this `index.html` into your repo. Notes at the end show DB rules and admin code.</footer>
</div>

<!-- Fullscreen modal -->
<div id="matchModalBackdrop" class="modal-backdrop" role="dialog" aria-hidden="true">
  <div class="modal" role="document" aria-labelledby="modalTitle">
    <div class="modal-top">
      <div style="font-weight:700;color:var(--muted)">Live match controller</div>
      <div id="modalTimer">00:00</div>
      <div style="text-align:right;color:var(--muted)">Press <strong>End Match</strong> to save (admin code required)</div>
    </div>

    <div class="team-block" id="modalHomeBlock">
      <div class="team-name" id="modalHomeName">Home</div>
      <div class="goals" id="modalHomeGoals">0</div>
      <div class="goal-btns">
        <button class="goal-btn" id="homeDec">−</button>
        <button class="goal-btn" id="homeInc">+</button>
      </div>
    </div>

    <div class="team-block" id="modalAwayBlock">
      <div class="team-name" id="modalAwayName">Away</div>
      <div class="goals" id="modalAwayGoals">0</div>
      <div class="goal-btns">
        <button class="goal-btn" id="awayDec">−</button>
        <button class="goal-btn" id="awayInc">+</button>
      </div>
    </div>

    <div class="controls">
      <div class="timer-controls">
        <span class="time-label">Timer:</span>
        <button class="btn btn-start" id="startTimerBtn">Start</button>
        <button class="btn btn-start" id="pauseTimerBtn">Pause</button>
        <button class="btn btn-reset" id="resetTimerBtn">Reset</button>
      </div>

      <div style="display:flex;gap:8px;align-items:center">
        <button class="btn btn-end" id="endMatchBtn">End Match (save)</button>
        <button class="btn btn-reset" id="closeModalBtn">Close (cancel)</button>
      </div>
    </div>
  </div>
</div>

<!-- Firebase compat -->
<script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-database-compat.js"></script>

<script>
/* ===== Firebase config (your project) ===== */
const firebaseConfig = {
  apiKey: "AIzaSyBClhOYxDhLpQKPwurk1V3vsPXJ1Csew6E",
  authDomain: "project-add05.firebaseapp.com",
  databaseURL: "https://project-add05-default-rtdb.firebaseio.com",
  projectId: "project-add05",
  storageBucket: "project-add05.firebasestorage.app",
  messagingSenderId: "321491234235",
  appId: "1:321491234235:web:1f674625d9f129f2ef689e",
  measurementId: "G-87M4WVB5Z8"
};

/* ===== Tournament: 3 teams, each plays 10 matches => 15 matches.
   Each pair meets 5 times. Scheduling across 5 days (3 matches per day). ===== */
const TEAMS = ['Barca','Man City','AHLY'];
const MATCHES = [
  // Day 1
  { id: 'm1', day: 1, home: 'Barca',     away: 'Man City' },
  { id: 'm2', day: 1, home: 'AHLY', away: 'Man City' },
  { id: 'm3', day: 1, home: 'Barca',     away: 'AHLY' },

  // Day 2
  { id: 'm4', day: 2, home: 'Man City',  away: 'Barca' },
  { id: 'm5', day: 2, home: 'AHLY', away: 'Barca' },
  { id: 'm6', day: 2, home: 'Man City',  away: 'AHLY' },

  // Day 3
  { id: 'm7', day: 3, home: 'Barca',     away: 'Man City' },
  { id: 'm8', day: 3, home: 'AHLY', away: 'Barca' },
  { id: 'm9', day: 3, home: 'Man City',  away: 'AHLY' },

  // Day 4
  { id: 'm10', day: 4, home: 'Barca',    away: 'Man City' },
  { id: 'm11', day: 4, home: 'AHLY',away: 'Man City' },
  { id: 'm12', day: 4, home: 'Barca',    away: 'AHLY' },

  // Day 5
  { id: 'm13', day: 5, home: 'Man City', away: 'Barca' },
  { id: 'm14', day: 5, home: 'AHLY',away: 'Barca' },
  { id: 'm15', day: 5, home: 'Man City', away: 'AHLY' }
];

/* ===== DOM refs ===== */
const daysContainer = document.getElementById('daysContainer');
const leaderboardWrap = document.getElementById('leaderboardWrap');
const dbStatusEl = document.getElementById('dbStatus');

const matchModalBackdrop = document.getElementById('matchModalBackdrop');
const modalTimer = document.getElementById('modalTimer');
const modalHomeName = document.getElementById('modalHomeName');
const modalAwayName = document.getElementById('modalAwayName');
const modalHomeGoals = document.getElementById('modalHomeGoals');
const modalAwayGoals = document.getElementById('modalAwayGoals');
const modalHomeBlock = document.getElementById('modalHomeBlock');
const modalAwayBlock = document.getElementById('modalAwayBlock');

const homeDec = document.getElementById('homeDec');
const homeInc = document.getElementById('homeInc');
const awayDec = document.getElementById('awayDec');
const awayInc = document.getElementById('awayInc');

const startTimerBtn = document.getElementById('startTimerBtn');
const pauseTimerBtn = document.getElementById('pauseTimerBtn');
const resetTimerBtn = document.getElementById('resetTimerBtn');
const endMatchBtn = document.getElementById('endMatchBtn');
const closeModalBtn = document.getElementById('closeModalBtn');

const startSemiBtn = document.getElementById('startSemiBtn');
const resetSemiBtn = document.getElementById('resetSemiBtn');
const semiResultEl = document.getElementById('semiResult');

const startFinalBtn = document.getElementById('startFinalBtn');
const resetFinalBtn = document.getElementById('resetFinalBtn');
const finalResultEl = document.getElementById('finalResult');

let db = null;
let savedMatches = {}; // mirror /matches
let savedSemi = null;  // mirror /semi
let savedFinal = null; // mirror /final

/* active match & timer state */
let activeMatchId = null;               // match id (e.g. 'm1') or 'semi' or 'final'
let activeHome = 0;
let activeAway = 0;
let activeTimeSeconds = 0; // integer seconds
let timerInterval = null;

/* ===== Firebase init & listeners ===== */
function initFirebase(){
  try{
    firebase.initializeApp(firebaseConfig);
    db = firebase.database();
    dbStatusEl.textContent = 'connected';

    db.ref('matches').on('value', snap=>{
      savedMatches = snap.val() || {};
      renderAll();
      if(activeMatchId && activeMatchId !== 'semi' && activeMatchId !== 'final') syncModalTimerFromDB();
    }, err=>{ console.warn('matches listen', err); dbStatusEl.textContent='error'; });

    db.ref('semi').on('value', snap=>{
      savedSemi = snap.val();
      renderSemi();
      if(activeMatchId === 'semi') syncModalTimerFromDB();
    }, err=>{ console.warn('semi listen', err); dbStatusEl.textContent='error'; });

    db.ref('final').on('value', snap=>{
      savedFinal = snap.val();
      renderFinal();
      if(activeMatchId === 'final') syncModalTimerFromDB();
    }, err=>{ console.warn('final listen', err); dbStatusEl.textContent='error'; });

    db.ref('.info/connected').on('value', snap=>{
      dbStatusEl.textContent = snap.val() ? 'online' : 'offline';
    });

  }catch(e){
    console.error('Firebase init failed', e); dbStatusEl.textContent='init-failed';
  }
}

/* ===== Render schedule & attach handlers ===== */
function groupByDay(list){
  const days = {};
  for(const m of list){ if(!days[m.day]) days[m.day]=[]; days[m.day].push(m); }
  return days;
}

function renderDays(){
  const grouped = groupByDay(MATCHES);
  let html = '';
  const days = Object.keys(grouped).sort((a,b)=>a-b);
  for(const d of days){
    html += `<div class="small" style="margin-bottom:8px;font-weight:800">Day ${d}</div>`;
    html += `<table aria-label="Day ${d} matches"><thead><tr><th>Home</th><th style="width:150px">Score (time)</th><th>Away</th><th style="width:170px"></th></tr></thead><tbody>`;
    for(const m of grouped[d]){
      const s = savedMatches[m.id];
      let scoreText = '—';
      if(s && s.homeScore !== undefined && s.awayScore !== undefined){
        const t = (s.timePlayedSeconds !== undefined && s.timePlayedSeconds !== null) ? formatSeconds(s.timePlayedSeconds) : '';
        scoreText = `${s.homeScore} — ${s.awayScore}` + (t ? ` (${t})` : '');
      }
      html += `<tr data-match-id="${m.id}">
        <td class="team">${escapeHtml(m.home)}</td>
        <td class="score-display">${escapeHtml(scoreText)}</td>
        <td class="team">${escapeHtml(m.away)}</td>
        <td style="text-align:right">
          <button class="btn btn-start" data-action="start">Start Match</button>
          <button class="btn btn-reset" data-action="reset">Reset</button>
        </td>
      </tr>`;
    }
    html += `</tbody></table><div style="height:8px"></div>`;
  }
  daysContainer.innerHTML = html;

  // handlers
  daysContainer.querySelectorAll('button[data-action="start"]').forEach(btn=>{
    btn.addEventListener('click', e=>{
      const tr = e.target.closest('tr');
      openMatchController(tr.getAttribute('data-match-id'));
    });
  });
  daysContainer.querySelectorAll('button[data-action="reset"]').forEach(btn=>{
    btn.addEventListener('click', e=>{
      const tr = e.target.closest('tr');
      const id = tr.getAttribute('data-match-id');
      if(confirm('Reset this match (remove saved score & timer)?')) {
        if(db) db.ref('matches/' + id).remove();
      }
    });
  });
}

/* ===== Leaderboard ===== */
function computeStats(){
  const stats = {};
  for(const t of TEAMS) stats[t] = { team:t, played:0, wins:0, draws:0, losses:0, gf:0, ga:0, pts:0 };
  for(const m of MATCHES){
    const s = savedMatches[m.id];
    if(!s || s.homeScore===undefined || s.awayScore===undefined) continue;
    const a = parseInt(s.homeScore,10), b = parseInt(s.awayScore,10);
    if(Number.isNaN(a) || Number.isNaN(b)) continue;
    const home = m.home, away = m.away;
    stats[home].played++; stats[away].played++;
    stats[home].gf += a; stats[home].ga += b;
    stats[away].gf += b; stats[away].ga += a;
    if(a > b){ stats[home].wins++; stats[home].pts += 3; stats[away].losses++; }
    else if(a === b){ stats[home].draws++; stats[away].draws++; stats[home].pts++; stats[away].pts++; }
    else { stats[away].wins++; stats[away].pts += 3; stats[home].losses++; }
  }
  return stats;
}

function renderLeaderboard(){
  const stats = computeStats();
  const arr = Object.values(stats);
  arr.sort((A,B)=>{
    if(B.pts !== A.pts) return B.pts - A.pts;
    const gdA = A.gf - A.ga, gdB = B.gf - B.ga;
    if(gdB !== gdA) return gdB - gdA;
    if(B.gf !== A.gf) return B.gf - A.gf;
    return A.team.localeCompare(B.team);
  });

  let html = `<table><thead><tr><th>#</th><th>Team</th><th>P</th><th>W</th><th>D</th><th>L</th><th>GF</th><th>GA</th><th>GD</th><th>Pts</th></tr></thead><tbody>`;
  for(let i=0;i<arr.length;i++){
    const r = arr[i]; const gd = r.gf - r.ga;
    html += `<tr><td style="font-weight:800">${i+1}</td><td>${escapeHtml(r.team)}</td><td>${r.played}</td><td>${r.wins}</td><td>${r.draws}</td><td>${r.losses}</td><td>${r.gf}</td><td>${r.ga}</td><td>${gd>=0? '+'+gd: gd}</td><td style="font-weight:800">${r.pts}</td></tr>`;
  }
  html += `</tbody></table>`;
  leaderboardWrap.innerHTML = html;
}

/* ===== Semifinal & Final rendering ===== */
function renderSemi(){
  if(savedSemi && savedSemi.homeScore !== undefined && savedSemi.awayScore !== undefined){
    const home = savedSemi.home || '?', away = savedSemi.away || '?';
    const h = savedSemi.homeScore, a = savedSemi.awayScore;
    let txt = `${home} ${h} — ${a} ${away}`;
    if(h > a) txt += ` — Winner: ${home}`;
    else if(a > h) txt += ` — Winner: ${away}`;
    else if(savedSemi.winner) txt += ` — Winner: ${savedSemi.winner}`;
    else txt += ` — Draw (no winner saved)`;
    semiResultEl.textContent = txt;
  } else {
    semiResultEl.textContent = 'No semifinal played yet';
  }
}

function renderFinal(){
  if(savedFinal && savedFinal.homeScore !== undefined && savedFinal.awayScore !== undefined){
    const home = savedFinal.home || (getLeaderboardArray()[0] || '?');
    const away = savedFinal.away || (savedSemi && savedSemi.winner) || (getLeaderboardArray()[1] || '?');
    const h = savedFinal.homeScore, a = savedFinal.awayScore;
    let txt = `${home} ${h} — ${a} ${away}`;
    if(h > a) txt += ` — Champion: ${home}`;
    else if(a > h) txt += ` — Champion: ${away}`;
    else txt += ' — Draw';
    finalResultEl.textContent = txt;
  } else {
    finalResultEl.textContent = 'No final played yet';
  }
}

/* ===== Modal controller & timer sync (works for matches, semi, final) ===== */

/** Helper: get DB ref path for current active match **/
function activeNodeRef(){
  if(!db) return null;
  if(activeMatchId === 'semi') return db.ref('semi');
  if(activeMatchId === 'final') return db.ref('final');
  return db.ref('matches/' + activeMatchId);
}

/** When opening controller for either a match or playoff node **/
function openMatchController(matchId){
  activeMatchId = matchId;

  let matchNames = { home: 'Home', away: 'Away' };
  let saved = null;
  if(matchId === 'final'){
    // final: home = #1, away = semifinal winner if present else #2
    const top = getLeaderboardArray();
    matchNames.home = top[0] || 'Team 1';
    matchNames.away = (savedSemi && savedSemi.winner) ? savedSemi.winner : (top[1] || 'Team 2');
    saved = savedFinal || {};
  } else if(matchId === 'semi'){
    // semifinal: #2 vs #3 from leaderboard
    const top = getLeaderboardArray();
    matchNames.home = top[1] || 'Team 2'; // #2
    matchNames.away = top[2] || (TEAMS.find(t => t !== matchNames.home) || 'Team'); // #3 or fallback
    saved = savedSemi || {};
  } else {
    const match = MATCHES.find(m=>m.id===matchId);
    if(!match) return;
    matchNames.home = match.home;
    matchNames.away = match.away;
    saved = savedMatches[matchId] || {};
  }

  // load existing score/time if present
  activeHome = (saved.homeScore !== undefined && saved.homeScore !== null) ? parseInt(saved.homeScore,10) : 0;
  activeAway = (saved.awayScore !== undefined && saved.awayScore !== null) ? parseInt(saved.awayScore,10) : 0;
  activeTimeSeconds = (saved.timePlayedSeconds !== undefined && saved.timePlayedSeconds !== null) ? parseInt(saved.timePlayedSeconds,10) : 0;

  modalHomeName.textContent = matchNames.home;
  modalAwayName.textContent = matchNames.away;
  updateModalScores();
  updateModalTimerDisplay();

  // If DB indicates timerRunning for the node, start local timer; otherwise ensure stopped
  const nodeSaved = (matchId === 'final') ? (savedFinal || {}) : (matchId === 'semi' ? (savedSemi || {}) : (savedMatches[matchId] || {}));
  if(nodeSaved.timerRunning){
    startTimerLocal();
  } else {
    stopTimerLocal(false);
  }

  matchModalBackdrop.style.display = 'flex';
  matchModalBackdrop.setAttribute('aria-hidden','false');
}

/** Close modal (does not auto-save) **/
function closeMatchController(){
  stopTimerLocal(false);
  activeMatchId = null;
  matchModalBackdrop.style.display = 'none';
  matchModalBackdrop.setAttribute('aria-hidden','true');
}

/* Score UI */
function updateModalScores(){
  modalHomeGoals.textContent = String(activeHome);
  modalAwayGoals.textContent = String(activeAway);
  modalHomeBlock.classList.remove('winner','loser');
  modalAwayBlock.classList.remove('winner','loser');
  if(activeHome > activeAway){ modalHomeBlock.classList.add('winner'); modalAwayBlock.classList.add('loser'); }
  else if(activeAway > activeHome){ modalAwayBlock.classList.add('winner'); modalHomeBlock.classList.add('loser'); }
}

/* Timer helpers */
function formatSeconds(sec){
  sec = Math.max(0, Math.floor(Number(sec) || 0));
  const mm = String(Math.floor(sec/60)).padStart(2,'0');
  const ss = String(sec % 60).padStart(2,'0');
  return `${mm}:${ss}`;
}
function updateModalTimerDisplay(){ modalTimer.textContent = formatSeconds(activeTimeSeconds); }

/* Local timer control — writes to DB using activeNodeRef() when running */
function startTimerLocal(){
  if(timerInterval) return;
  timerInterval = setInterval(()=>{
    activeTimeSeconds++;
    updateModalTimerDisplay();
    const ref = activeNodeRef();
    if(ref) ref.update({ timePlayedSeconds: activeTimeSeconds, timerRunning: true }).catch(e=>console.warn('timer write', e));
  }, 1000);
}
function stopTimerLocal(writeToDB = true){
  if(timerInterval){ clearInterval(timerInterval); timerInterval = null; }
  const ref = activeNodeRef();
  if(writeToDB && ref) ref.update({ timerRunning: false, timePlayedSeconds: activeTimeSeconds }).catch(e=>console.warn('timer stop write', e));
}
function resetTimerLocal(){
  activeTimeSeconds = 0;
  updateModalTimerDisplay();
  const ref = activeNodeRef();
  if(ref) ref.update({ timePlayedSeconds: activeTimeSeconds }).catch(e=>console.warn('timer reset write', e));
}

/* Sync local modal state to DB content when DB updates (for active node) */
function syncModalTimerFromDB(){
  if(!activeMatchId) return;
  const nodeSaved = (activeMatchId === 'final') ? (savedFinal || {}) : (activeMatchId === 'semi' ? (savedSemi || {}) : (savedMatches[activeMatchId] || {}));
  const dbTime = (nodeSaved.timePlayedSeconds !== undefined && nodeSaved.timePlayedSeconds !== null) ? parseInt(nodeSaved.timePlayedSeconds,10) : 0;
  const dbRunning = Boolean(nodeSaved.timerRunning);

  // If not running locally, reflect DB time
  if(!timerInterval){
    activeTimeSeconds = dbTime;
    updateModalTimerDisplay();
  }
  // If DB says running and we aren't local-running, start local
  if(dbRunning && !timerInterval){
    startTimerLocal();
  }
  // If DB says stopped and we are running locally, stop local without overwriting DB (we're reflecting)
  if(!dbRunning && timerInterval){
    stopTimerLocal(false);
  }
}

/* goal buttons */
homeInc.addEventListener('click', ()=>{ activeHome++; updateModalScores(); });
homeDec.addEventListener('click', ()=>{ if(activeHome>0) activeHome--; updateModalScores(); });
awayInc.addEventListener('click', ()=>{ activeAway++; updateModalScores(); });
awayDec.addEventListener('click', ()=>{ if(activeAway>0) activeAway--; updateModalScores(); });

/* timer buttons */
startTimerBtn.addEventListener('click', ()=>{
  if(!activeMatchId){ alert('No active match'); return; }
  const ref = activeNodeRef();
  if(ref) ref.update({ timerRunning: true, timePlayedSeconds: activeTimeSeconds }).catch(e=>console.warn('start timer write', e));
  startTimerLocal();
});
pauseTimerBtn.addEventListener('click', ()=>{ stopTimerLocal(true); });
resetTimerBtn.addEventListener('click', ()=>{ if(confirm('Reset timer to 00:00 for this match?')) resetTimerLocal(); });

/* End match: prompt admin code and write final state to DB at the node (matches/{id}, /semi, or /final) */
endMatchBtn.addEventListener('click', async ()=>{
  if(!activeMatchId) return;
  const code = prompt('Enter admin code to save score:');
  if(code === null) return;
  if(String(code).trim() !== '246'){ alert('Invalid admin code.'); return; }
  const h = activeHome, a = activeAway;
  if(h < 0 || a < 0){ alert('Invalid goals'); return; }
  if(!db){ alert('Database not initialized'); return; }

  if(timerInterval) stopTimerLocal(true);
  const payload = { homeScore: h, awayScore: a, timePlayedSeconds: activeTimeSeconds, savedAt: Date.now(), timerRunning: false };

  const nodeRef = activeNodeRef();
  if(!nodeRef){ alert('DB not ready'); return; }

  try{
    // Semifinal: determine winner (if draw ask to pick)
    if(activeMatchId === 'semi'){
      let winner = null;
      const homeName = modalHomeName.textContent;
      const awayName = modalAwayName.textContent;
      if(h > a) winner = homeName;
      else if(a > h) winner = awayName;
      else {
        // tie -> ask who advances
        const pick = prompt(`Semifinal ended ${h}—${a}. Type the winner's exact name to advance (${homeName} or ${awayName}), or Cancel to abort save:`);
        if(pick === null) return;
        const trimmed = String(pick).trim();
        if(trimmed !== homeName && trimmed !== awayName){
          alert('Invalid name entered. Save cancelled. Enter exactly one of the two team names shown.');
          return;
        }
        winner = trimmed;
      }
      payload.home = homeName;
      payload.away = awayName;
      payload.winner = winner;
      await nodeRef.set(payload);
      // keep convenience winner at /semi/winner
      await db.ref('semi/winner').set(winner);
      savedSemi = (await db.ref('semi').get()).val();
      renderSemi();
      closeMatchController();
      return;
    }

    // Final: save with home/away names
    if(activeMatchId === 'final'){
      payload.home = modalHomeName.textContent;
      payload.away = modalAwayName.textContent;
      await nodeRef.set(payload);
      savedFinal = (await db.ref('final').get()).val();
      renderFinal();
      closeMatchController();
      return;
    }

    // Regular match
    payload.home = modalHomeName.textContent;
    payload.away = modalAwayName.textContent;
    await nodeRef.set(payload);
    savedMatches[activeMatchId] = payload;
    renderAll();
    closeMatchController();
  }catch(err){
    console.error('save match', err);
    alert('Failed to save match: ' + (err && err.message ? err.message : String(err)));
  }
});

/* close modal */
closeModalBtn.addEventListener('click', ()=>{ if(confirm('Close without saving? Running timer will be paused locally (DB unchanged).')){ stopTimerLocal(false); closeMatchController(); } });

/* Start Semifinal: open modal for node 'semi' (uses leaderboard #2 vs #3) */
startSemiBtn.addEventListener('click', ()=>{
  const top = getLeaderboardArray();
  if(top.length < 3 || !top[1] || !top[2]){ alert('Not enough ranked teams to start semifinal.'); return; }
  openMatchController('semi');
});
resetSemiBtn.addEventListener('click', ()=>{ if(confirm('Reset semifinal (remove saved semifinal & winner)?')) db.ref('semi').remove(); });

/* Start Final: open modal for node 'final' (requires semi winner ideally) */
startFinalBtn.addEventListener('click', ()=>{
  const semiWinner = savedSemi && savedSemi.winner;
  const top = getLeaderboardArray();
  const top1 = top[0];
  if(!top1){ alert('Leaderboard not ready (no top team).'); return; }
  if(!semiWinner){
    if(!confirm('No semifinal winner found. Start final using current #1 vs current #2 instead? (Cancel to run semifinal)')) return;
    // The modal's logic will set away to top[1] if no semi winner exists.
  }
  openMatchController('final');
});
resetFinalBtn.addEventListener('click', ()=>{ if(confirm('Reset final (remove saved final & timer)?')) db.ref('final').remove(); });

/* ===== Utility & render glue ===== */
function getLeaderboardArray(){
  const stats = computeStats();
  const arr = Object.values(stats);
  arr.sort((A,B)=>{
    if(B.pts !== A.pts) return B.pts - A.pts;
    const gdA = A.gf - A.ga, gdB = B.gf - B.ga;
    if(gdB !== gdA) return gdB - gdA;
    if(B.gf !== A.gf) return B.gf - A.gf;
    return A.team.localeCompare(B.team);
  });
  return arr.map(r => r.team);
}

/* top-level rendering */
function renderAll(){
  renderDays();
  renderLeaderboard();
  // also refresh playoff cards
  renderSemi();
  renderFinal();
}

/* helper: format seconds to mm:ss */
function formatSeconds(sec){
  sec = Math.max(0, Math.floor(Number(sec) || 0));
  const mm = String(Math.floor(sec/60)).padStart(2,'0');
  const ss = String(sec % 60).padStart(2,'0');
  return `${mm}:${ss}`;
}

/* helper: escape HTML */
function escapeHtml(s){ return String(s).replace(/[&<>"']/g, c=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c])); }

/* Kickoff */
initFirebase();

/* Close modal on Esc */
document.addEventListener('keydown', (e)=>{
  if(e.key === 'Escape' && matchModalBackdrop.style.display === 'flex'){
    if(confirm('Close without saving? Running timer will be paused locally (DB unchanged).')){ stopTimerLocal(false); closeMatchController(); }
  }
});
</script>

<!-- Notes:
  - Semifinal stored at /semi (also /semi/winner contains the winner string).
  - Final stored at /final.
  - Regular matches stored at /matches/{matchId}.
  - Timer syncs to Firebase every second while running. Change frequency to reduce writes if needed.
  - Admin code to save is '246' (client-side). For production use Firebase Auth + rules.
  - For testing temporarily set Realtime DB rules to:
      { "rules": { ".read": true, ".write": true } }
    (UNSAFE). Secure your DB for production.
-->
</body>
</html>
