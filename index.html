<head>
<meta charset="UTF-8">
<title>Pack Opening Game with Mutations + Protect</title>


<meta name="format-detection" content="telephone=no">
<link rel="apple-touch-icon" href="trala.png">
<meta name="apple-mobile-web-app-title" content="YourAppName">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<link rel="apple-touch-icon" sizes="180x180" href="trala.png">
<link rel="apple-touch-icon" sizes="152x152" href="trala.png">
<link rel="apple-touch-icon" sizes="120x120" href="trala.png">


<style>

  body {
    font-family: 'Inter', sans-serif;
    text-align: center;
    background: #ff0000;
    min-height: 100vh;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    padding: 1rem;
    color: #333;
  }
  .login-box, .game-box, #messageBox, #cardDetailsBox, #sendModal, #stealModal {
    margin: 20px auto;
    padding: 20px;
    border-radius: 12px;
    background: white;
    max-width: 480px;
    width: 100%;
    box-shadow: 0 4px 10px rgba(0,0,0,0.2);
  }
  .card-container {
    display: grid;
    gap: 1rem;
    grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
    justify-content: center;
    margin-top: 20px;
  }
  .card {
    padding: 15px;
    width: 100%;
    min-height: 250px;
    border-radius: 12px;
    text-align: center;
    border: 3px solid;
    box-sizing: border-box;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    transition: transform 0.2s ease, box-shadow 0.2s ease;
    cursor: pointer;
    position: relative;
    overflow: hidden;
  }
  .card:hover { transform: scale(1.05); box-shadow: 0 8px 15px rgba(0,0,0,0.3); }
  .mutation-label { position: absolute; top: 5px; left: 5px; background: rgba(0,0,0,0.5); color: white; padding: 2px 6px; border-radius: 8px; font-size: 0.75rem; }
  .quantity-label { position: absolute; top: 5px; right: 5px; background: rgba(255,255,255,0.95); color: #111; padding: 4px 8px; border-radius: 10px; font-size: 0.75rem; font-weight: 600; box-shadow: 0 2px 6px rgba(0,0,0,0.12); }
  .protected-label { position: absolute; bottom: 6px; left: 6px; background: rgba(0,128,0,0.85); color: white; padding: 4px 8px; border-radius: 10px; font-size: 0.75rem; font-weight: 700; }
  .protection-countdown { position: absolute; bottom: 6px; right: 6px; background: rgba(255,255,255,0.95); color: #111; padding: 3px 6px; border-radius: 8px; font-size: 0.75rem; }
  .mutation-list { margin-top: 10px; text-align: left; width: 100%; }
  .mutation-list h4 { margin: 0; font-size: 0.9rem; color: #444; }
  .mutation-list ul { list-style: none; padding: 0; margin: 5px 0 0; }
  .mutation-list li { font-size: 0.8rem; margin-bottom: 2px; }
  .common-card { background: linear-gradient(#ddd, #bbb); border-color: #666; color: #444; }
  .rare-card { background: linear-gradient(#a0d4ff, #66aaff); border-color: #004488; color: white; font-weight: bold; }
  .epic-card { background: linear-gradient(to bottom right, #a020f0, #800080); border-color: #663399; color: #eee; font-weight: bold; }
  .legendary-card { background: linear-gradient(to bottom right, #ffcc00, #b8860b); border-color: #d4af37; color: #333; font-weight: bold; }
  .divine-card { background: linear-gradient(to bottom right, #e0e0ff, #c0c0d4); border-color: #9999ff; color: #1a1a33; font-weight: bold; }
  .pristimatic-card { background: conic-gradient(red, orange, yellow, green, blue, indigo, violet); border-color: #000; color: white; font-weight: bold; text-shadow: 1px 1px 2px black; }

  .mythical-card { background: linear-gradient(135deg, #fff7d6 0%, #ffefb5 20%, #ffd54b 50%, #f2c200 70%, #ffd94d 100%); border-color: #ffd700; color: #2b1f00; font-weight: 800; position: relative; overflow: hidden; }
  .mythical-card::after { content: ""; position: absolute; top: -50%; left: -50%; width: 200%; height: 200%; background: linear-gradient(120deg, rgba(255,255,255,0.0) 0%, rgba(255,255,255,0.45) 50%, rgba(255,255,255,0.0) 100%); transform: rotate(25deg); animation: shimmer 3.5s linear infinite; pointer-events: none; }
  @keyframes shimmer { 0% { transform: translateX(-60%) rotate(25deg);} 100% { transform: translateX(60%) rotate(25deg);} }

  .btn { padding: 12px 24px; margin: 8px; border: none; background: #444; color: white; border-radius: 8px; cursor: pointer; font-size: 16px; transition: background 0.2s ease, transform 0.2s ease; }
  .btn:hover { background: #666; transform: translateY(-2px); }
  .btn-blue { background: #0077ff; }
  .btn-blue:hover { background: #0055aa; }
  .btn-purple { background: #800080; }
  .btn-purple:hover { background: #6a0dad; }
  .btn-gold { background: #d4af37; }
  .btn-gold:hover { background: #b8860b; }
  .btn-divine { background: #9999ff; }
  .btn-divine:hover { background: #7a7aff; }
  .btn-pristimatic { background: #e66465; }
  .btn-pristimatic:hover { background: #9198e5; }
  .btn-small { padding: 8px 16px; font-size: 14px; margin: 4px; }
  .locked-card { box-shadow: 0 0 10px 3px #ff0000; }
  .card-buttons { display: flex; flex-direction: column; gap: 5px; margin-top: 10px; width: 100%; }
  #messageBox, #cardDetailsBox, #sendModal, #stealModal { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); z-index: 1000; display: none; }
  #cardDetailsBox .card { cursor: default; transform: none; box-shadow: none; }
  .user-select-buttons { display: flex; justify-content: center; gap: 10px; margin-bottom: 20px; }
  .header-actions { display: flex; justify-content: space-between; align-items: center; width: 100%; max-width: 480px; }
  .header-right { display:flex; flex-direction:column; gap:6px; align-items:flex-end; }
  #nextDistribution { font-size: 0.9rem; color: #333; margin-top: 6px; opacity: 0.9; }
  @media (max-width: 600px) { .card-container { grid-template-columns: 1fr; } .game-box, .login-box { padding: 10px; } .btn { padding: 10px 20px; font-size: 14px; } }
  #stealModal .question { font-size: 1.2rem; margin-bottom: 12px; }
  #stealModal .small { font-size: 0.85rem; color: #666; margin-top:8px; }

  /* --- SECRET pack styles --- */
  .btn-secret {
    background:
      radial-gradient(2px 2px at 10% 10%, rgba(255,255,255,0.95) 0, rgba(255,255,255,0.0) 40%),
      radial-gradient(1.5px 1.5px at 40% 30%, rgba(255,255,255,0.9) 0, rgba(255,255,255,0.0) 40%),
      radial-gradient(1.2px 1.2px at 70% 60%, rgba(255,255,255,0.85) 0, rgba(255,255,255,0.0) 40%),
      linear-gradient(180deg, #0b1530 0%, #071026 40%, #050417 100%);
    color: #f8f8ff;
    border: 1px solid rgba(255,255,255,0.06);
    box-shadow: 0 6px 18px rgba(3,10,23,0.6), inset 0 -2px 6px rgba(255,255,255,0.02);
    text-shadow: 0 1px 0 rgba(0,0,0,0.5);
  }
  .secret-card {
    background:
      radial-gradient(1px 1px at 10% 12%, rgba(255,255,255,0.95) 0, rgba(255,255,255,0) 30%),
      radial-gradient(1px 1px at 40% 30%, rgba(255,255,255,0.85) 0, rgba(255,255,255,0) 30%),
      radial-gradient(1px 1px at 70% 60%, rgba(255,255,255,0.9) 0, rgba(255,255,255,0) 30%),
      linear-gradient(180deg, #071022 0%, #050218 60%, #03000a 100%);
    color: #fff;
    border: 1px solid rgba(255,255,255,0.06);
    box-shadow: 0 6px 20px rgba(2,6,15,0.6);
  }

  /* ---------- Bloodmoon CARD: light-blue, water-like moving effect ---------- */
  .Bloodmoon-card {
    background: linear-gradient(180deg, #ff0000 0%, #821010 35%, #ff0000 60%, #821010 100%);
    border-color: #ffffff;
    color: #ff0000;
    box-shadow: inset 0 -6px 30px rgba(157, 5, 228, 0.06), 0 10px 30px rgba(193, 1, 246, 0.08);
    position: relative;
    overflow: hidden;
    transition: transform 0.25s ease, box-shadow 0.25s ease;
  }

  /* subtle flowing highlight layer */
  .Bloodmoon-card::before {
    content: "";
    position: absolute;
    inset: 0;
    pointer-events: none;
    mix-blend-mode: overlay;
    background-image:
      radial-gradient(1200px 400px at 10% 20%, rgba(255,255,255,0.45), rgba(255,255,255,0.00) 20%),
      radial-gradient(800px 300px at 80% 60%, rgba(255,255,255,0.20), rgba(255,255,255,0.00) 18%),
      linear-gradient(180deg, rgba(255,255,255,0.06), rgba(255,255,255,0.00));
    opacity: 0.98;
    transform: translate3d(0,0,0);
    animation: waterShift 6.8s linear infinite;
  }

  /* moving wave stripe for water flow */
  .Bloodmoon-card::after {
    content: "";
    position: absolute;
    left: -60%;
    top: -30%;
    width: 220%;
    height: 220%;
    pointer-events: none;
    mix-blend-mode: screen;
    background-image:
      repeating-linear-gradient(
        -25deg,
        rgba(255,255,255,0.07) 0 8px,
        rgba(255,255,255,0.00) 8px 20px
      ),
      linear-gradient(90deg, rgba(255,255,255,0.03), rgba(255,255,255,0.00));
    opacity: 0.9;
    filter: blur(6px) contrast(1.02);
    animation: waveMove 8.5s linear infinite;
  }

  /* text polish for headings inside an Bloodmoon card */
  .Bloodmoon-card h3,
  .Bloodmoon-card .card-title {
    color: #022c3a;
    text-shadow: 0 1px 0 rgba(255,255,255,0.5);
    font-weight: 800;
  }

  /* optional little floating bubbles to add life */
  .Bloodmoon-card .Bloodmoon-bubble {
    position: absolute;
    border-radius: 50%;
    background: rgba(255,255,255,0.14);
    pointer-events: none;
    animation: bubbleRise 9s linear infinite;
    mix-blend-mode: screen;
  }

  /* animate the "water" movement */
  @keyframes waterShift {
    0%   { transform: translate3d(0,0,0) scale(1); }
    50%  { transform: translate3d(6%, 1.5%, 0) scale(1.02); }
    100% { transform: translate3d(0,0,0) scale(1); }
  }
  @keyframes waveMove {
    0%   { transform: translateX(-25%) translateY(0) rotate(-2deg); }
    50%  { transform: translateX(10%) translateY(4%) rotate(1deg); }
    100% { transform: translateX(-25%) translateY(0) rotate(-2deg); }
  }
  @keyframes bubbleRise {
    0% { transform: translateY(0) scale(0.8); opacity: 0.0; }
    10% { opacity: 0.6; }
    50% { transform: translateY(-40%) scale(1); opacity: 0.4; }
    100% { transform: translateY(-110%) scale(1.2); opacity: 0; }
  }

  @media (prefers-reduced-motion: reduce) {
    .Bloodmoon-card::before,
    .Bloodmoon-card::after,
    .Bloodmoon-card .Bloodmoon-bubble {
      animation: none !important;
    }
  }
</style>

<script>
/**
 * markBloodmoonCardsByName(names)
 * - names: string or array of strings (exact card name match, case-insensitive)
 * Adds the .Bloodmoon-card class to matching card DOM nodes and adds decorative bubbles.
 *
 * This script is safe to include in <head> — it waits for DOMContentLoaded before acting.
 */
(function(){
  function isMatch(cardName, targetNames) {
    if (!cardName) return false;
    const n = String(cardName).trim().toLowerCase();
    return targetNames.some(t => n === t);
  }

  function addBubbles(cardEl, count) {
    // avoid duplicate bubble groups
    if (cardEl.querySelector('.Bloodmoon-bubble')) return;
    for (let i = 0; i < count; i++) {
      const b = document.createElement('div');
      b.className = 'Bloodmoon-bubble';
      const size = 8 + Math.round(Math.random() * 26);
      b.style.width = b.style.height = size + 'px';
      b.style.left = (8 + Math.random() * 84) + '%';
      b.style.top = (30 + Math.random() * 50) + '%';
      b.style.opacity = (0.3 + Math.random() * 0.6).toFixed(2);
      b.style.animationDelay = (Math.random() * 4) + 's';
      cardEl.appendChild(b);
    }
  }

  window.markBloodmoonCardsByName = function(names, bubbleCount = 3) {
    if (!names) return;
    const arr = Array.isArray(names) ? names.slice() : [names];
    const targets = arr.map(s => String(s || '').trim().toLowerCase());
    document.querySelectorAll('.card').forEach(card => {
      const h3 = card.querySelector('h3');
      const name = h3 ? String(h3.innerText || '').trim().toLowerCase() : '';
      if (isMatch(name, targets)) {
        card.classList.add('Bloodmoon-card');
        addBubbles(card, bubbleCount || 2);
      } else {
        // remove Bloodmoon visuals if present and not matched
        card.classList.remove('Bloodmoon-card');
        card.querySelectorAll('.Bloodmoon-bubble').forEach(n => n.remove());
      }
    });
  };

  // convenience: mark a default name on load if present in the DOM
  document.addEventListener('DOMContentLoaded', function(){
    // auto-mark cards named "Bloodmoon CARD" and "Bloodmoon" (case-insensitive)
    markBloodmoonCardsByName(['Bloodmoon card','Bloodmoon']);
  }, { once: true });
})();
</script>

<!-- No-zoom / pinch-prevent script -->
<script>
(function(){
  // Prevent multi-touch pinch zooms and double-tap zooms on mobile,
  // and block ctrl/meta + wheel or +/-, 0 on desktops.
  // Note: these listeners are non-passive to allow preventDefault.

  // block pinch by preventing touchstart/touchmove with >1 touches
  function onTouchStart(e) {
    if (e.touches && e.touches.length > 1) {
      e.preventDefault();
    }
  }
  function onTouchMove(e) {
    if (e.touches && e.touches.length > 1) {
      e.preventDefault();
    }
    // some browsers set e.scale for gesture events
    if (typeof e.scale === 'number' && e.scale !== 1) {
      e.preventDefault();
    }
  }

  // prevent double-tap zoom (simple heuristic)
  let lastTouchTime = 0;
  function onTouchEnd(e) {
    const now = Date.now();
    if (now - lastTouchTime <= 300) {
      e.preventDefault();
    }
    lastTouchTime = now;
  }

  // iOS gesturestart
  function onGestureStart(e) {
    e.preventDefault();
  }

  // prevent ctrl/cmd + wheel zoom
  function onWheel(e) {
    if (e.ctrlKey || e.metaKey) {
      e.preventDefault();
    }
  }

  // prevent keyboard zoom (Ctrl/Cmd + + / - / = / 0)
  function onKeyDown(e) {
    if ((e.ctrlKey || e.metaKey) && (e.key === '+' || e.key === '-' || e.key === '=' || e.key === '0')) {
      e.preventDefault();
    }
  }

  // attach listeners with passive:false so preventDefault works
  document.addEventListener('touchstart', onTouchStart, { passive: false });
  document.addEventListener('touchmove', onTouchMove, { passive: false });
  document.addEventListener('touchend', onTouchEnd, { passive: false });
  document.addEventListener('gesturestart', onGestureStart, { passive: false });
  window.addEventListener('wheel', onWheel, { passive: false });
  window.addEventListener('keydown', onKeyDown, { passive: false });
})();
</script>

</head>



<body>

<div class="login-box" id="loginBox">
  <h2>Login</h2>
  <input id="username" placeholder="Username" style="padding:10px; border-radius:8px; border:1px solid #ccc; width:80%;"><br><br>
  <input id="password" type="password" placeholder="Password" style="padding:10px; border-radius:8px; border:1px solid #ccc; width:80%;"><br><br>
  <label style="display:flex; align-items:center; justify-content:center; margin:10px 0;">
    <input type="checkbox" id="keepSignedIn" style="margin-right:5px;"> Keep me signed in
  </label>
  <button class="btn" onclick="login()">Login</button>
  <p id="loginStatus"></p>
</div>

<div class="game-box" id="gameBox" style="display:none;">
  <div class="header-actions">
    <div style="text-align:left;">
      <h2>Welcome <span id="userName"></span></h2>
      <div id="nextDistribution">Next distribution in: --</div>
    </div>
    <div class="header-right">
      <button class="btn btn-small" onclick="logout()">Logout</button>
      <button class="btn btn-small" onclick="refillStocksPrompt()">Refill Stocks</button>
    </div>
  </div>

  <p>Balance: $<span id="balance">0</span></p>

  <div class="user-select-buttons">
    <button class="btn btn-blue" onclick="showUserCollection('zezo')">Zezo</button>
    <button class="btn btn-blue" onclick="showUserCollection('lilly')">lilly</button>
    <button class="btn btn-blue" onclick="showUserCollection('asser')">Asser</button>
    <button class="btn btn-blue" onclick="showUserCollection('ab')">AB</button>
    <button class="btn btn-purple" onclick="showMyCollection()">My Base</button>
  </div>

  <div style="display:flex; flex-wrap:wrap; justify-content:center; margin-bottom:20px;">
    <button id="buyCommonBtn" class="btn" onclick="openPack('common')">Buy Common Pack (100%) ($100)</button>
    <button id="buyRareBtn" class="btn btn-blue" onclick="openPack('rare')">Buy Rare Pack (100%) ($250)</button>
    <button id="buyEpicBtn" class="btn btn-purple" onclick="openPack('epic')">Buy Epic Pack (100%) ($350)</button>
    <button id="buyLegendaryBtn" class="btn btn-gold" onclick="openPack('legendary')">Buy Legendary Pack (100%) ($1500)</button>
    <button id="buyMythicalBtn" class="btn btn-gold" onclick="openPack('mythical')">Buy Mythical Pack (??%) ($3000)</button>
    <button id="buyDivineBtn" class="btn btn-divine" onclick="openPack('divine')">Buy Divine Pack (100%) ($5000)</button>
    <button id="buyPristimaticBtn" class="btn btn-pristimatic" onclick="openPack('pristimatic')">Buy Pristimatic Pack (100%) ($7500)</button>
    <!-- SECRET pack button (50,000) -->
    <button id="buySecretBtn" class="btn btn-secret" onclick="openPack('secret')">Buy SECRET Pack (0%) ($50,000)</button>
    <button id="buyBloodmoonBtn" class="btn btn-Bloodmoon" onclick="openPack('Bloodmoon')">Buy Bloodmoon Pack (0%) ($1000000)</button>
  </div>

  <div id="openedCard"></div>

  <h3>Your Collection</h3>
  <div id="collection" class="card-container"></div>

  <h3><span id="otherUserHeader"></span>'s Collection</h3>
  <div id="otherUserCollection" class="card-container" style="display:none;"></div>
</div>

<div id="messageBox"><p id="messageText"></p><button class="btn" onclick="closeMessage()">OK</button></div>

<div id="cardDetailsBox"><div id="cardDetailsContent"></div><button class="btn" onclick="closeCardDetails()">Close</button></div>

<div id="sendModal">
  <h3>Send Card</h3>
  <p>Send "<strong id="sendCardName"></strong>" to:</p>
  <div style="display:flex; justify-content:center; gap:10px; margin-top:8px;">
    <button class="btn btn-blue" onclick="sendCardToRecipient(currentSendCardId,'asser')">Asser</button>
    <button class="btn btn-blue" onclick="sendCardToRecipient(currentSendCardId,'lilly')">Lilly</button>
    <button class="btn btn-blue" onclick="sendCardToRecipient(currentSendCardId,'zezo')">Zezo</button>
  </div>
  <div style="margin-top:12px;"><button class="btn" onclick="closeSendModal()">Cancel</button></div>
</div>

<div id="stealModal">
  <h3 id="stealModalTitle">Steal Attempt</h3>
  <div class="question" id="stealQuestion">Question will appear here</div>
  <input id="stealAnswerInput" placeholder="Enter answer" style="padding:10px; border-radius:8px; border:1px solid #ccc; width:80%;"><br><br>
  <div style="display:flex; justify-content:center; gap:10px;">
    <button class="btn btn-blue" id="submitStealAnswerBtn" onclick="submitStealAnswer()">Submit</button>
    <button class="btn" onclick="closeStealModal()">Cancel</button>
  </div>
  <div class="small" id="stealModalHint"></div>
</div>

<div id="welcome-container" style="position:fixed; top:0; left:0; width:100%; height:100%; display:flex; align-items:center; justify-content:center; background: rgba(0,0,0,0.7); z-index:9999;">
  <button id="welcome-btn" style="font-size:24px; padding:20px 40px; border:none; border-radius:12px; background:#6a0dad; color:white; cursor:pointer; box-shadow:0 4px 12px rgba(0,0,0,0.3);">Welcome</button>
</div>

<!-- Firebase compat libs -->
<script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-database-compat.js"></script>

<script>
/* --------------------
   Firebase + Game Data
   -------------------- */
const firebaseConfig = {
  apiKey: "AIzaSyDclp6rqCZRVreOzTcxv840mXcl6nDKAv8",
  authDomain: "pack-f76c3.firebaseapp.com",
  databaseURL: "https://pack-f76c3-default-rtdb.firebaseio.com/",
  projectId: "pack-f76c3",
  storageBucket: "pack-f76c3.firebasestorage.app",
  messagingSenderId: "694325056042",
  appId: "1:694325056042:web:aae383919a2ce159892953",
  measurementId: "G-07WXQ7YQ4M"
};
firebase.initializeApp(firebaseConfig);
const db = firebase.database();

// --- Helpers ---
function toKey(name) { return String(name).replace(/[.#$\[\]\/]/g, '_'); }
function generateCardId() { return Date.now().toString() + Math.random().toString().substr(2,6); }

/* --------------------
   Game data
   -------------------- */
const accounts = { zezo: "000", asser: "67", lilly: "678", ab: "123", layan: "123" };

const MUTATION_TIERS = { common: {chance:0.5}, uncommon:{chance:0.24}, rare:{chance:0.15}, veryHard:{chance:0.08}, ultra:{chance:0.03} };
const MUTATIONS = { plasma:{priceIncrease:20000,tier:'uncommon'},
 bloom:{priceIncrease:20000,tier:'common'},
  choc:{priceIncrease:35000,tier:'common'},
   shocked:{priceIncrease:45000,tier:'rare'},
    rainbow:{priceIncrease:40000,tier:'uncommon'},
     burnt:{priceIncrease:40000,tier:'uncommon'},
      chilled:{priceIncrease:45000,tier:'rare'},
       CHOCOLATE:{priceIncrease:45000,tier:'rare'},
        frozen:{priceIncrease:30000,tier:'common'},
         Bloodmoon:{priceIncrease:100000,tier:'veryHard'},
          zezopilot:{priceIncrease:120000,tier:'veryHard'},
          TACO:{priceIncrease:200000,tier:'veryHard'},
           KHALTO:{priceIncrease:120500,tier:'veryHard'},
            aurora:{priceIncrease:150000,tier:'ultra'},
             EGYPT:{priceIncrease:160000,tier:'ultra'} };

let cardPools = {
  common: [
    { name: "asser", quantity: 100, chance: 0.25, price: 110 },
    { name: "asser eat", quantity: 100, chance: 0.15, price: 120 },
    { name: "asser angry", quantity: 100, chance: 0.15, price: 130 },
    { name: "asser cry", quantity: 100, chance: 0.10, price: 150 },
    { name: "asser sad", quantity: 100, chance: 0.10, price: 140 },
    { name: "asser happy", quantity: 100, chance: 0.15, price: 130 },
    { name: "asser sleep", quantity: 100, chance: 0.10, price: 130 }
  ],
  rare: [
    { name: "Blue Asser", quantity: 70, chance: 0.30, price: 260 },
    { name: "Asser Dragon", quantity: 50, chance: 0.25, price: 280 },
    { name: "Asser Bloodmoon", quantity: 40, chance: 0.20, price: 300 },
    { name: "Asser Legend", quantity: 40, chance: 0.15, price: 350 },
    { name: "Asser Mythic", quantity: 40, chance: 0.10, price: 400 }
  ],
  epic: [
    { name: "lilly eat", quantity: 50, chance: 0.15, price: 360 },
    { name: "lilly angry", quantity: 50, chance: 0.15, price: 365 },
    { name: "lilly sad", quantity: 50, chance: 0.10, price: 360 },
    { name: "lilly happy", quantity: 50, chance: 0.15, price: 380 },
    { name: "lilly sleep", quantity: 50, chance: 0.10, price: 370 },
    { name: "lilly", quantity: 50, chance: 0.25, price: 355 },
    { name: "Lilly Bomba", quantity: 12, chance: 0.10, price: 600 }
  ],
  legendary: [
    { name: "Lilly laugh", quantity: 20, chance: 0.40, price: 1550 },
    { name: "Lilly Queen", quantity: 15, chance: 0.40, price: 1550 },
    { name: "Lilly Dragon", quantity: 17, chance: 0.10, price: 1700 },
    { name: "Lilly Hero", quantity: 14, chance: 0.10, price: 1500 }
  ],
  mythical: [
    { name: "lilly PS5", quantity: 17, chance: 0.25, price: 3500 },
    { name: "asser bomba", quantity: 15, chance: 0.25, price: 4000 },
    { name: "asser gamer", quantity: 17, chance: 0.25, price: 4500 },
    { name: "PS5 CONTROLLER", quantity: 15, chance: 0.15, price: 5000 },
    { name: "asser farted", quantity: 15, chance: 0.10, price: 5000 }
  ],
  divine: [
    { name: "Zezo laugh", quantity: 15, chance: 0.10, price: 5600 },
    { name: "Zezo sad", quantity: 15, chance: 0.10, price: 5650 },
    { name: "Zezo angry", quantity: 10, chance: 0.10, price: 5800 },
    { name: "Zezo ps5", quantity: 10, chance: 0.20, price: 5700 },
    { name: "Zezo happy", quantity: 15, chance: 0.10, price: 5600 },
    { name: "Zezo smile", quantity: 15, chance: 0.10, price: 5620 },
    { name: "Zezo roblox", quantity: 15, chance: 0.10, price: 5750 },
    { name: "Zezo fart", quantity: 16, chance: 0.05, price: 6000 },
    { name: "normal zezo full", quantity: 3, chance: 0.15, price: 5850 }
  ],
  pristimatic: [
    { name: "Zezo Prismatic", quantity: 4, chance: 0.25, price: 7500 },
    { name: "Zezo Rainbow", quantity: 18, chance: 0.25, price: 7800 },
    { name: "Asser colotinni fasatennee", quantity: 7, chance: 0.20, price: 8000 },
    { name: "zezo big bomba fart", quantity: 8, chance: 0.10, price: 9000 },
    { name: "lilly kowaferr", quantity: 7, chance: 0.15, price: 8000 },
    { name: "LUCKY BLOCK", quantity: 1, chance: 0.01, price: 0 },
    { name: "Zezo SECRET", quantity: 10, chance: 0.05, price: 13500 }
  ],

  /* NEW: Bloodmoon pack — very low quantities, extremely rare */
  Bloodmoon: [
    { name: "Bloodmoon GARAMA AND MADUNG", quantity: 1, chance: 0.02, price: 2000000 },
    { name: "Bloodmoon MEOWL", quantity: 0, chance: 0.02, price: 90000000 },
    { name: "Bloodmoon 67", quantity: 0, chance: 0.02, price: 70000000 },
    { name: "Bloodmoon LOS TRALALITOS", quantity: 0, chance: 0.02, price: 75000000 },
    { name: "Bloodmoon LOS BROS", quantity: 0, chance: 0.02, price: 80000000 },
    { name: "Bloodmoon LOS TUNGTUNGCITOS", quantity: 0, chance: 0.02, price: 80000000 },
    { name: "Bloodmoon MADRID VS BARCA", quantity: 0, chance: 0.02, price: 35000000 },
    { name: "Bloodmoon JOB JOB JOB SAHUR!", quantity: 0, chance: 0.02, price: 70000000 },
    { name: "Bloodmoon LOS JOB SAUHUR!", quantity: 0, chance: 0.02, price: 100000000 },
    { name: "Bloodmoon LOS 67", quantity: 0, chance: 0.02, price: 150000000 },
    { name: "Bloodmoon LOS ZEZOS", quantity: 0, chance: 0.02, price: 100000000 },
    
  ],

  /* SECRET pack placeholders — slots intentionally left with 0 quantity so you can fill later.
     Names are placeholder keys so DB paths remain valid. Replace names/quantities/chances later as desired.
  */
  secret: [
    { name: "SECRET PEPSI", quantity: 0, chance: 0.20, price: 55000 },
    { name: "SECRET ASSER", quantity: 0, chance: 0.20, price: 55000 },
    { name: "SECRET PS5", quantity: 0, chance: 0.15, price: 54000 },
    { name: "SECRET PHONE", quantity: 0, chance: 0.15, price: 54000 },
    { name: "SECRET TWINKIES", quantity: 1, chance: 0.15, price: 58000 },
    { name: "SECRET HOHOS", quantity: 0, chance: 0.15, price: 59000 }
  ]
};

const INITIAL_QUANTITIES = {};
(function captureInitialQuantities() {
  for (const packType in cardPools) {
    cardPools[packType].forEach(card => { INITIAL_QUANTITIES[card.name] = card.quantity; });
  }
})();

/* --------------------
   State
   -------------------- */
let currentUser = null;
let balance = 0;
let collection = {};
let lockedCards = {};
let currentHourlyMutation = null;
let mutationInterval = null;
let distributionInterval = null;
let distributionDelayMs = 1000 * 60 * 5; // 5 minutes
let nextDistributionTimestamp = null;
let distributionCountdownInterval = null;
let currentSendCardId = null;
const STEAL_COOLDOWN_MS = 2 * 60 * 1000; // 15 minutes
let activeStealSession = null;
let stealRequestsListenerRef = null;
let myCollectionRef = null;
let myLockedRef = null;
let myBalanceRef = null;
let otherUserRef = null;
let nextDistributionRef = null;
let protectionNormalizationInterval = null;

/* --------------------
   Utility & UI
   -------------------- */
function getCardType(cardName) {
  if (cardPools.common.some(c=>c.name===cardName)) return 'common';
  if (cardPools.rare.some(c=>c.name===cardName)) return 'rare';
  if (cardPools.epic.some(c=>c.name===cardName)) return 'epic';
  if (cardPools.legendary.some(c=>c.name===cardName)) return 'legendary';
  if (cardPools.mythical && cardPools.mythical.some(c=>c.name===cardName)) return 'mythical';
  if (cardPools.divine.some(c=>c.name===cardName)) return 'divine';
  if (cardPools.pristimatic.some(c=>c.name===cardName)) return 'pristimatic';
  if (cardPools.Bloodmoon && cardPools.Bloodmoon.some(c=>c.name===cardName)) return 'Bloodmoon';
  if (cardPools.secret && cardPools.secret.some(c=>c.name===cardName)) return 'secret';
  return '';
}
function getBaseCardPrice(cardName) {
  const all = [
    ...cardPools.common,
    ...cardPools.rare,
    ...cardPools.epic,
    ...cardPools.legendary,
    ...(cardPools.mythical||[]),
    ...cardPools.divine,
    ...cardPools.pristimatic,
    ...(cardPools.Bloodmoon||[]),
    ...(cardPools.secret||[])
  ];
  const c = all.find(x=>x.name===cardName);
  return c?c.price:0;
}
function getCardQuantity(cardName) {
  const all = [
    ...cardPools.common,
    ...cardPools.rare,
    ...cardPools.epic,
    ...cardPools.legendary,
    ...(cardPools.mythical||[]),
    ...cardPools.divine,
    ...cardPools.pristimatic,
    ...(cardPools.Bloodmoon||[]),
    ...(cardPools.secret||[])
  ];
  const c = all.find(x=>x.name===cardName);
  return c?c.quantity:0;
}

function showMessage(message) { document.getElementById('messageText').innerText = message; document.getElementById('messageBox').style.display = 'block'; }
function closeMessage() { document.getElementById('messageBox').style.display = 'none'; }

function showCardDetails(cardId) {
  const card = collection[cardId] || lockedCards[cardId];
  if (!card) return;
  const mutationListHtml = card.mutations && card.mutations.length>0 ? `<div class="mutation-list"><h4>Mutations:</h4><ul>${card.mutations.map(m=>`<li>${m.name} (+${m.priceIncrease})</li>`).join('')}</ul></div>` : `<p>This card has no mutations yet.</p>`;
  const qty = getCardQuantity(card.name);
  const prot = card.protectedUntil && card.protectedUntil > Date.now();
  const protHtml = prot ? `<div class="protected-label">Protected</div><div class="protection-countdown">${formatTimeRemaining(card.protectedUntil - Date.now())}</div>` : '';
  const cardClass = getCardType(card.name) + '-card';
  const cardHtml = `<div class="card ${cardClass}" data-card-id="${cardId}">${protHtml}<span class="quantity-label">x${qty}</span><h3>${card.name}</h3><p>Base Value: $${getBaseCardPrice(card.name)}</p><p>Current Value: $${card.currentPrice}</p>${mutationListHtml}</div>`;
  document.getElementById('cardDetailsContent').innerHTML = cardHtml;
  document.getElementById('cardDetailsBox').style.display = 'block';
}
function closeCardDetails() { document.getElementById('cardDetailsBox').style.display = 'none'; }

function updateDistributionCountdownUI() {
  const el = document.getElementById('nextDistribution');
  if (!el) return;
  if (!nextDistributionTimestamp) { el.innerText = 'Next distribution in: --'; return; }
  const now = Date.now();
  let diff = nextDistributionTimestamp - now;
  if (diff <= 0) { el.innerText = 'Next distribution: distributing now...'; return; }
  const mins = Math.floor(diff / 60000);
  const secs = Math.floor((diff % 60000) / 1000);
  el.innerText = mins>0 ? `Next distribution in: ${mins}m ${secs}s` : `Next distribution in: ${secs}s`;
}

function formatTimeRemaining(ms) {
  if (!ms || ms <= 0) return '0s';
  const mins = Math.floor(ms/60000); const secs = Math.floor((ms%60000)/1000);
  return mins>0? `${mins}m ${secs}s` : `${secs}s`;
}

/* --------------------
   Presence & Steal Requests
   -------------------- */
function setOnlinePresence() { if (!currentUser) return; const ref = db.ref(`presence/${currentUser}`); ref.onDisconnect().remove(); ref.set(true).catch(()=>{}); }
function clearOnlinePresence() { if (!currentUser) return; db.ref(`presence/${currentUser}`).remove().catch(()=>{}); }

function listenForStealRequests() {
  if (!currentUser) return;
  if (stealRequestsListenerRef) { stealRequestsListenerRef.off(); stealRequestsListenerRef = null; }
  const requestsRef = db.ref(`stealRequests/${currentUser}`);
  stealRequestsListenerRef = requestsRef;
  requestsRef.on('child_added', async snap => {
    const session = snap.val();
    const sessionId = snap.key;
    if (!session) return;
    let full = session;
    if (!session.question) {
      const central = await db.ref(`stealSessions/${sessionId}`).once('value'); full = central.val();
    }
    if (!full) { requestsRef.child(sessionId).remove().catch(()=>{}); return; }
    showIncomingSteal(sessionId, full);
  });
}
function stopListeningForStealRequests() { if (stealRequestsListenerRef) { stealRequestsListenerRef.off(); stealRequestsListenerRef = null; } }

/* --------------------
   Realtime listeners for instant UI updates
   -------------------- */
function attachMyRealtimeListeners() {
  if (!currentUser) return; detachMyRealtimeListeners();

  myCollectionRef = db.ref(`users/${currentUser}/collection`);
  myCollectionRef.on('value', snap => { collection = snap.val() || {}; updateUI(); });

  myLockedRef = db.ref(`users/${currentUser}/lockedCards`);
  myLockedRef.on('value', snap => { lockedCards = snap.val() || {}; updateUI(); });

  myBalanceRef = db.ref(`users/${currentUser}/balance`);
  myBalanceRef.on('value', snap => { const v = snap.val(); if (v !== null && v !== undefined) balance = v; updateUI(); });
}
function detachMyRealtimeListeners() { try { if (myCollectionRef) { myCollectionRef.off(); myCollectionRef = null; } if (myLockedRef) { myLockedRef.off(); myLockedRef = null; } if (myBalanceRef) { myBalanceRef.off(); myBalanceRef = null; } } catch (e) { console.error("detachMyRealtimeListeners err", e); } }

function attachOtherUserListener(targetUser) {
  detachOtherUserListener();
  otherUserRef = db.ref(`users/${targetUser}`);
  otherUserRef.on('value', snap => {
    if (!snap.exists()) { document.getElementById("otherUserCollection").innerHTML = `<p>${targetUser} isn't playing this game!</p>`; return; }
    const d = snap.val(); const otherCollection = d.collection || {}; const otherLocked = d.lockedCards || {};
    document.getElementById("otherUserCollection").innerHTML = renderCollection(otherCollection, otherLocked, false, targetUser);
    document.getElementById("otherUserCollection").style.display = 'block';
    document.getElementById("collection").style.display = 'none';
    document.getElementById("otherUserHeader").innerText = targetUser;
    document.getElementById("otherUserHeader").style.display = 'block';
  });
}
function detachOtherUserListener() { if (otherUserRef) { otherUserRef.off(); otherUserRef = null; } document.getElementById("otherUserCollection").innerHTML = ''; document.getElementById("otherUserCollection").style.display = 'none'; document.getElementById("collection").style.display = 'block'; document.getElementById("otherUserHeader").style.display = 'none'; }

/* --------------------
   Auth / Load / Save
   -------------------- */
window.onload = function() {
  const lastUser = localStorage.getItem("lastLoggedInUser");
  const keepSignedIn = localStorage.getItem("keepSignedIn");
  if (lastUser && keepSignedIn === "true") {
    document.getElementById("username").value = lastUser;
    document.getElementById("keepSignedIn").checked = true;
    const pass = accounts[lastUser];
    if (pass) { document.getElementById("password").value = pass; login(); }
  }

  nextDistributionRef = db.ref('nextDistribution');
  nextDistributionRef.on('value', snap => { const v = snap.val(); if (v) nextDistributionTimestamp = Number(v); else nextDistributionTimestamp = null; updateDistributionCountdownUI(); });
};

async function login() {
  const u = document.getElementById("username").value.trim();
  const p = document.getElementById("password").value.trim();
  const keep = document.getElementById("keepSignedIn").checked;
  if (accounts[u] && accounts[u] === p) {
    currentUser = u;
    if (keep) { localStorage.setItem("lastLoggedInUser", u); localStorage.setItem("keepSignedIn","true"); } else { localStorage.removeItem("lastLoggedInUser"); localStorage.removeItem("keepSignedIn"); }
    document.getElementById("loginBox").style.display = "none";
    document.getElementById("gameBox").style.display = "block";
    document.getElementById("userName").innerText = u;
    await loadUserData();
    setOnlinePresence();
    listenForStealRequests();
    attachMyRealtimeListeners();

    if (!mutationInterval) { mutationInterval = setInterval(applyMutations, 1000 * 60 * 30); applyMutations(); }

    if (!distributionInterval) {
      distributionInterval = setInterval(async () => {
        if (!nextDistributionTimestamp) {
          const newTs = Date.now() + distributionDelayMs;
          await db.ref('nextDistribution').set(newTs);
          nextDistributionTimestamp = newTs; updateDistributionCountdownUI(); return;
        }
        if (Date.now() >= nextDistributionTimestamp) {
          try { await distributeMutation(); } catch(e) { console.error("distributeMutation call err", e); }
          const newTs = Date.now() + distributionDelayMs;
          await db.ref('nextDistribution').set(newTs);
          nextDistributionTimestamp = newTs; updateDistributionCountdownUI();
        }
      }, 1000);
    }

    if (!distributionCountdownInterval) { distributionCountdownInterval = setInterval(updateDistributionCountdownUI, 1000); updateDistributionCountdownUI(); }

    // protection normalization: ensure expired protections turn into cooldowns (persisted)
    if (!protectionNormalizationInterval) {
      protectionNormalizationInterval = setInterval(() => { normalizeProtectionStatesForUser().catch(()=>{}); }, 30 * 1000);
      normalizeProtectionStatesForUser().catch(()=>{});
    }

  } else { document.getElementById("loginStatus").innerText = "Invalid credentials!"; }
}

function logout() {
  currentUser = null; balance = 0; collection = {}; lockedCards = {};
  localStorage.removeItem("lastLoggedInUser"); localStorage.removeItem("keepSignedIn");
  document.getElementById("gameBox").style.display = "none"; document.getElementById("loginBox").style.display = "block";
  document.getElementById("username").value = ""; document.getElementById("password").value = ""; document.getElementById("loginStatus").innerText = ""; document.getElementById("keepSignedIn").checked = false;
  updateUI();
  if (mutationInterval) { clearInterval(mutationInterval); mutationInterval = null; }
  if (distributionInterval) { clearInterval(distributionInterval); distributionInterval = null; }
  if (distributionCountdownInterval) { clearInterval(distributionCountdownInterval); distributionCountdownInterval = null; }
  if (protectionNormalizationInterval) { clearInterval(protectionNormalizationInterval); protectionNormalizationInterval = null; }
  nextDistributionTimestamp = null; updateDistributionCountdownUI();
  clearOnlinePresence(); stopListeningForStealRequests(); detachMyRealtimeListeners(); detachOtherUserListener();
}

/* --------------------
   Load user + quantities
   -------------------- */
async function loadUserData() {
  try {
    const snap = await db.ref("users/" + currentUser).once("value");
    if (snap.exists()) {
      const data = snap.val(); balance = data.balance || 100; collection = data.collection || {}; lockedCards = data.lockedCards || {};
    } else { balance = 100; collection = {}; lockedCards = {}; await saveUser(); }
    await loadCardQuantities();
    await normalizeProtectionStatesForUser();
  } catch (e) {
    console.error("loadUserData err", e);
  }
  checkNotifications();
}

function loadCardQuantities() {
  return db.ref("cardQuantities").once("value").then(snap=>{
    const dbQty = snap.val() || {};
    for (const packType in cardPools) { cardPools[packType].forEach(card=>{ const k = toKey(card.name); if (dbQty[k] !== undefined) card.quantity = dbQty[k]; }); }
    updateUI(); updatePackChances();
  }).catch(err => { console.error("loadCardQuantities err", err); updateUI(); });
}

function saveUser() { if (!currentUser) return Promise.resolve(); return db.ref("users/" + currentUser).set({ balance: balance, collection: collection, lockedCards: lockedCards }).catch(err => { console.error("saveUser err", err); throw err; }); }

function saveCardQuantities() { const q = {}; for (const packType in cardPools) { cardPools[packType].forEach(card => { q[toKey(card.name)] = card.quantity; }); } return db.ref("cardQuantities").update(q).catch(err => console.error("saveCardQuantities err", err)); }

function checkNotifications() { const ref = db.ref(`notifications/${currentUser}`); ref.once("value").then(snap=>{ if (snap.exists()) { const notes = snap.val(); for (const k in notes) showMessage(notes[k]); ref.remove(); } }); }

/* --------------------
   Protection normalization
   -------------------- */
async function normalizeProtectionStatesForUser() {
  if (!currentUser) return;
  try {
    const userRef = db.ref(`users/${currentUser}`);
    const snap = await userRef.once('value');
    if (!snap.exists()) return;
    const u = snap.val();
    const updates = {};
    const now = Date.now();
    const COOLDOWN_AFTER_UNPROTECT_MS = 5 * 60 * 1000;

    const checkPlace = (placeName) => {
      const cards = (u[placeName] || {});
      for (const id in cards) {
        const card = cards[id];
        if (!card) continue;
        // expiration handling
        if (card.protectedUntil && card.protectedUntil > 0 && card.protectedUntil <= now) {
          updates[`users/${currentUser}/${placeName}/${id}/protectedUntil`] = 0;
          const existingAvail = card.protectAvailableAt || 0;
          if (!existingAvail || existingAvail <= now) {
            updates[`users/${currentUser}/${placeName}/${id}/protectAvailableAt`] = now + COOLDOWN_AFTER_UNPROTECT_MS;
          }
        }
      }
    };

    checkPlace('collection');
    checkPlace('lockedCards');

    if (Object.keys(updates).length > 0) {
      await db.ref().update(updates);
    }
  } catch (e) {
    console.error("normalizeProtectionStatesForUser err", e);
  }
}

/* --------------------
   UI / Collection Rendering
   -------------------- */
function updateUI() {
  document.getElementById("balance").innerText = balance;
  document.getElementById("collection").innerHTML = renderCollection(collection, lockedCards, true);
  document.getElementById("otherUserCollection").style.display = 'none';
  document.getElementById("otherUserHeader").style.display = 'none';
  updatePackChances();
}

function showMyCollection() { detachOtherUserListener(); document.getElementById("collection").style.display='block'; document.getElementById("otherUserCollection").style.display='none'; document.getElementById("otherUserHeader").style.display='none'; }

function renderCollection(cardCollection, lockedCardsObj, isMyCollection = false, ownerId = null) {
  let collHTML = "";
  const all = { ...cardCollection, ...lockedCardsObj };
  if (Object.keys(all).length === 0) return "This user has no cards yet.";
  for (let id in all) {
    const card = all[id];
    if (!card) continue;
    const cardType = getCardType(card.name);
    const isLocked = !!lockedCardsObj[id];
    const cls = isLocked ? 'locked-card' : '';
    const mutationsCount = (card.mutations && card.mutations.length) || 0;
    const mutationLabel = mutationsCount>0 ? `<span class="mutation-label">${mutationsCount}x Mutated</span>` : '';
    const qty = getCardQuantity(card.name);
    const qtyHtml = `<span class="quantity-label">x${qty}</span>`;
    const isProtected = card.protectedUntil && card.protectedUntil > Date.now();
    const protectionHtml = isProtected ? `<div class="protected-label">Protected</div><div class="protection-countdown">${formatTimeRemaining(card.protectedUntil - Date.now())}</div>` : '';

    let buttons = '';
    if (isMyCollection) {
      const availableAt = card.protectAvailableAt || 0;
      const protectDisabled = (!isProtected && availableAt && Date.now() < availableAt);
      let protButton = '';
      if (isProtected) {
        protButton = `<button class="btn btn-small" onclick="event.stopPropagation(); toggleProtect('${id}')">Unprotect</button>`;
      } else {
        protButton = `<button class="btn btn-small" onclick="event.stopPropagation(); toggleProtect('${id}')" ${protectDisabled ? 'disabled' : ''}>Protect</button>`;
      }

      buttons = `<button class="btn btn-small" onclick="event.stopPropagation(); ${isLocked ? `unlockCard('${id}')` : `lockCard('${id}')`}">${isLocked ? 'Unlock' : 'Lock'}</button>
                 <button class="btn btn-small" onclick="event.stopPropagation(); sellCard('${id}')" ${isLocked?'disabled':''}>Sell ($${card.currentPrice})</button>
                 <button class="btn btn-small btn-blue" onclick="event.stopPropagation(); openSendModal('${id}','${escapeHtml(card.name)}')">Send</button>
                 ${protButton}`;

      if (availableAt && Date.now() < availableAt) {
        buttons += `<div style="font-size:0.8rem; color:#666; margin-top:6px;">Protect available in: ${formatTimeRemaining(availableAt - Date.now())}</div>`;
      }
    } else {
      const owner = ownerId || 'player';
      const stealDisabled = isProtected ? 'disabled' : '';
      buttons = `<div style="opacity:0.85; font-size:0.9rem; margin-top:6px;">Owner: ${owner}</div>
                 <button class="btn btn-small btn-gold" onclick="event.stopPropagation(); attemptSteal('${id}','${owner}')" ${stealDisabled}>${isProtected? 'Protected' : 'Steal'}</button>`;
    }

    const cardClass = `${cardType}-card`;
    collHTML += `<div class="card ${cardClass} ${cls}" onclick="showCardDetails('${id}')">${protectionHtml}${mutationLabel}${qtyHtml}<h3>${card.name}</h3><p>Value: $${card.currentPrice}</p><div class="card-buttons">${buttons}</div></div>`;
  }
  return collHTML;
}

function showUserCollection(targetUser) {
  if (targetUser === currentUser) { showMessage("This is your account. Use 'My Base' to manage your cards."); return; }
  attachOtherUserListener(targetUser);
}

/* --------------------
   Lock / Unlock / Sell
   -------------------- */
function lockCard(cardId) {
  const c = collection[cardId];
  if (!c) return showMessage("Card not found in collection.");
  c.isLocked = true; c.lockTime = Date.now(); c.lastMutationTime = Date.now(); c.mutations = c.mutations||[];
  lockedCards[cardId] = c; delete collection[cardId];
  saveUser(); updateUI(); showMessage(`Card "${c.name}" has been locked.`);
}
function unlockCard(cardId) {
  const c = lockedCards[cardId];
  if (!c) return showMessage("Card not found in locked cards.");
  c.isLocked = false; c.lockTime = 0;
  collection[cardId] = c; delete lockedCards[cardId];
  saveUser(); updateUI(); showMessage(`Card "${c.name}" has been unlocked.`);
}
function sellCard(cardId) {
  const c = collection[cardId];
  if (!c) return showMessage("Card not found!");
  balance += c.currentPrice; delete collection[cardId];
  saveUser(); updateUI(); showMessage(`Sold card "${c.name}" for $${c.currentPrice}.`);
}

/* --------------------
   Pack buying / chances
   -------------------- */
function updatePackChances() {
  const packs = [
    { type: 'common', pool: cardPools.common, buttonId: 'buyCommonBtn' },
    { type: 'rare', pool: cardPools.rare, buttonId: 'buyRareBtn' },
    { type: 'epic', pool: cardPools.epic, buttonId: 'buyEpicBtn' },
    { type: 'legendary', pool: cardPools.legendary, buttonId: 'buyLegendaryBtn' },
    { type: 'mythical', pool: cardPools.mythical, buttonId: 'buyMythicalBtn' },
    { type: 'divine', pool: cardPools.divine, buttonId: 'buyDivineBtn' },
    { type: 'pristimatic', pool: cardPools.pristimatic, buttonId: 'buyPristimaticBtn' },
    { type: 'Bloodmoon', pool: cardPools.Bloodmoon, buttonId: 'buyBloodmoonBtn' }, // <-- Bloodmoon added
    { type: 'secret', pool: cardPools.secret, buttonId: 'buySecretBtn' }
  ];
  packs.forEach(pack=>{
    let totalChance = 0;
    const availableCards = (pack.pool || []).filter(card => getCardQuantity(card.name) > 0);
    availableCards.forEach(card => totalChance += card.chance);
    const chanceText = `(${Math.round(totalChance*100)}%)`;
    const packPrice = pack.type==='common'?100:pack.type==='rare'?250:pack.type==='epic'?350:pack.type==='legendary'?1500:pack.type==='mythical'?3000:pack.type==='divine'?5000:pack.type==='pristimatic'?7500:(pack.type==='secret'?50000:(pack.type==='Bloodmoon'?1000000:0));
    const btn = document.getElementById(pack.buttonId);
    if (btn) {
      btn.innerText = `Buy ${pack.type.charAt(0).toUpperCase()+pack.type.slice(1)} Pack ${chanceText} ($${packPrice})`;
      btn.disabled = (balance < packPrice) || (availableCards.length === 0);
      btn.style.opacity = btn.disabled ? 0.5 : 1;
      btn.style.cursor = btn.disabled ? 'not-allowed' : 'pointer';
    }
  });
}

/* --------------------
   Mutations & Distribution
   -------------------- */
function applyMutations() { if (!currentUser) return; currentHourlyMutation = getRandomMutation(); }
function getRandomMutation() { const arr = Object.keys(MUTATIONS).map(k=>({name:k,priceIncrease:MUTATIONS[k].priceIncrease, chance: MUTATION_TIERS[MUTATIONS[k].tier]?MUTATION_TIERS[MUTATIONS[k].tier].chance:0})); const total = arr.reduce((s,i)=>s+i.chance,0); let r = Math.random()*total; let s=0; for (const it of arr) { s+=it.chance; if (r<=s) return {name:it.name, priceIncrease:it.priceIncrease}; } return {name:'bloom', priceIncrease:300}; }
function getRandomMutationExcluding(excludeNames=[]) { const keys = Object.keys(MUTATIONS).filter(k=>!excludeNames.includes(k)); if (!keys.length) return null; const list = keys.map(k=>{ const m=MUTATIONS[k]; return {name:k, priceIncrease:m.priceIncrease, weight: MUTATION_TIERS[m.tier]?MUTATION_TIERS[m.tier].chance:0}; }); const total = list.reduce((s,i)=>s+i.weight,0); if (total<=0) return null; let r=Math.random()*total, s=0; for (const it of list) { s+=it.weight; if (r<=s) return {name:it.name, priceIncrease:it.priceIncrease}; } return {name:list[0].name, priceIncrease:list[0].priceIncrease}; }

async function distributeMutation() {
  if (!currentHourlyMutation || !currentUser) return;
  try {
    const userSnap = await db.ref(`users/${currentUser}`).once("value");
    if (!userSnap.exists()) return;
    const ud = userSnap.val(); const uLocked = ud.lockedCards||{};
    const eligible = [];
    for (const id in uLocked) { const c = uLocked[id]; if ((c.mutations||[]).length < 10) eligible.push({cardId:id, card:c}); }
    if (eligible.length===0) return;
    const chosen = eligible[Math.floor(Math.random()*eligible.length)];
    chosen.card.mutations = chosen.card.mutations||[];
    const existing = chosen.card.mutations.map(m=>m.name);
    let mutationToApply = null;
    if (!existing.includes(currentHourlyMutation.name)) mutationToApply = currentHourlyMutation;
    else mutationToApply = getRandomMutationExcluding(existing);
    if (!mutationToApply || existing.includes(mutationToApply.name)) { console.log("no mutation available"); return; }
    chosen.card.mutations.push(mutationToApply);
    chosen.card.currentPrice = (chosen.card.currentPrice||chosen.card.basePrice||0) + mutationToApply.priceIncrease;
    chosen.card.lastMutationTime = Date.now();
    await db.ref(`users/${currentUser}/lockedCards/${chosen.cardId}`).set(chosen.card);
    showMessage(`Your card "${chosen.card.name}" gained a mutation: ${mutationToApply.name}!`);
  } catch (err) { console.error("distributeMutation err", err); }
}

/* --------------------
   Open pack
   -------------------- */
async function openPack(type) {
  let packPrice = 0; let pool = [];
  if (type === "common") { packPrice = 100; pool = cardPools.common; }
  else if (type === "rare") { packPrice = 250; pool = cardPools.rare; }
  else if (type === "epic") { packPrice = 350; pool = cardPools.epic; }
  else if (type === "legendary") { packPrice = 1500; pool = cardPools.legendary; }
  else if (type === "mythical") { packPrice = 3000; pool = cardPools.mythical; }
  else if (type === "divine") { packPrice = 5000; pool = cardPools.divine; }
  else if (type === "pristimatic") { packPrice = 7500; pool = cardPools.pristimatic; }
  else if (type === "Bloodmoon") { packPrice = 1000000; pool = cardPools.Bloodmoon; } // <-- Bloodmoon support
  else if (type === "secret") { packPrice = 50000; pool = cardPools.secret; }

  if (balance < packPrice) { showMessage("You don't have enough money to buy this pack."); return; }
  balance -= packPrice; await saveUser(); updateUI();

  try {
    const snap = await db.ref('cardQuantities').once('value'); const dbQty = snap.val() || {};
    pool.forEach(card => { const k = toKey(card.name); if (dbQty[k] !== undefined) card.quantity = dbQty[k]; });
    const available = pool.filter(c => c.quantity > 0);
    if (available.length === 0) { balance += packPrice; await saveUser(); updateUI(); showMessage("This pack is sold out!"); return; }
    let rand = Math.random(); let s = 0; let chosenTemplate = available[0]; for (const c of available) { s += c.chance; if (rand <= s) { chosenTemplate = c; break; } }
    const chosenName = chosenTemplate.name; const safeKey = toKey(chosenName); const qtyRef = db.ref(`cardQuantities/${safeKey}`);

    const txnResult = await qtyRef.transaction(current => {
      if (current === null || current === undefined) { if (!chosenTemplate.quantity || chosenTemplate.quantity <= 0) return; return chosenTemplate.quantity - 1; }
      if (current > 0) return current - 1; return;
    }, false);

    if (!txnResult || !txnResult.committed) {
      balance += packPrice; await saveUser(); updateUI(); showMessage(`Sorry — "${chosenName}" sold out. You were refunded $${packPrice}.`); loadCardQuantities(); return;
    }

    let newQty = txnResult.snapshot.val(); if (newQty === null || newQty === undefined) newQty = 0;
    const newCardId = generateCardId();
    // protection: protectAvailableAt set to now + 5 minutes so protection isn't available immediately after opening
    const protectAvailableAt = Date.now() + (5 * 60 * 1000);
    const newCard = { id: newCardId, name: chosenName, basePrice: chosenTemplate.price || 0, currentPrice: chosenTemplate.price || 0, isLocked: false, lockTime: 0, lastMutationTime: Date.now(), mutations: [], protectAvailableAt: protectAvailableAt, protectedUntil: 0 };
    collection[newCardId] = newCard;

    const poolCard = pool.find(x=>x.name===chosenName); if (poolCard) poolCard.quantity = newQty;
    await saveUser(); await db.ref('purchases').push({ card: chosenName, user: currentUser, time: Date.now() }); updateUI();

    const cardClass = getCardType(newCard.name) + '-card';
    document.getElementById("openedCard").innerHTML = `<div class="card ${cardClass}"><span class="quantity-label">x${newQty}</span><h3>${newCard.name}</h3><p>Value: $${newCard.currentPrice}</p><p>Added to your collection!</p><p style=\"font-size:0.9rem;color:#666;margin-top:8px;\">Protection available in: ${formatTimeRemaining(protectAvailableAt - Date.now())}</p></div>`;

  } catch (err) {
    console.error("openPack error:", err);
    balance += packPrice; await saveUser(); updateUI(); showMessage("An error occurred while buying the pack — you were refunded."); loadCardQuantities();
  }
}

/* --------------------
   Protect / Unprotect
   -------------------- */
async function toggleProtect(cardId) {
  if (!currentUser) return showMessage('You must be logged in to protect cards.');
  // find card either in collection or lockedCards
  let card = collection[cardId] || lockedCards[cardId];
  if (!card) return showMessage('Card not found.');
  const now = Date.now();
  const availableAt = card.protectAvailableAt || 0;
  const isProtected = card.protectedUntil && card.protectedUntil > now;

  if (isProtected) {
    // unprotect -> clear protectedUntil and set protectAvailableAt = now + 5min (persisted)
    const newAvail = now + (5 * 60 * 1000);
    card.protectedUntil = 0;
    card.protectAvailableAt = newAvail;
    await saveCardNode(cardId, card);
    showMessage(`Protection removed from "${card.name}". You can protect it again in 5 minutes.`);
    return;
  }

  // protecting: check availability (protectAvailableAt must be <= now)
  if (availableAt && now < availableAt) {
    const left = availableAt - now;
    showMessage(`Protection will be available in ${formatTimeRemaining(left)}.`);
    return;
  }

  const protectedUntil = now + (10 * 60 * 1000); // 10 minutes
  card.protectedUntil = protectedUntil;
  // clear available marker because it's now protected
  card.protectAvailableAt = 0;
  await saveCardNode(cardId, card);
  showMessage(`"${card.name}" is protected for 10 minutes.`);
}

/* --------------------
   saveCardNode
   -------------------- */
async function saveCardNode(cardId, card) {
  // Determine where card logically lives by reading DB: safer to attempt both updates
  // Write to both paths to ensure data persists (collection or lockedCards)
  const updates = {};
  updates[`users/${currentUser}/collection/${cardId}`] = collection[cardId] ? card : null;
  updates[`users/${currentUser}/lockedCards/${cardId}`] = lockedCards[cardId] ? card : null;

  // if card isn't present in local maps, write to both places where it might be (safe)
  if (!collection[cardId] && !lockedCards[cardId]) {
    updates[`users/${currentUser}/collection/${cardId}`] = card;
    updates[`users/${currentUser}/lockedCards/${cardId}`] = card;
  }
  try {
    await db.ref().update(updates);
    // local saveUser to keep local state consistent
    await saveUser();
  } catch (e) {
    console.error("saveCardNode err", e);
    // fallback: try individual writes
    try { await db.ref(`users/${currentUser}/collection/${cardId}`).set(card).catch(()=>{}); await db.ref(`users/${currentUser}/lockedCards/${cardId}`).set(card).catch(()=>{}); } catch(e2) { console.error("saveCardNode fallback err", e2); }
  }
}

/* --------------------
   Send Card Flow
   -------------------- */
function escapeHtml(str) { return String(str || '').replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;').replace(/'/g,'&#039;'); }
function openSendModal(cardId, cardName) { currentSendCardId = cardId; document.getElementById('sendCardName').innerText = cardName || (collection[cardId] && collection[cardId].name) || ''; document.getElementById('sendModal').style.display = 'block'; }
function closeSendModal() { currentSendCardId = null; document.getElementById('sendModal').style.display = 'none'; }

async function sendCardToRecipient(cardId, recipient) {
  try {
    if (!currentUser) { showMessage("You must be logged in to send cards."); return; }
    if (!cardId) { showMessage("No card selected."); return; }
    if (!recipient || recipient === currentUser) { showMessage("Select a valid recipient."); return; }

    const rRef = db.ref(`users/${recipient}`);
    const rSnap = await rRef.once('value');
    if (!rSnap.exists()) { showMessage("Recipient does not exist."); return; }

    let cardData = null;
    if (collection[cardId]) { cardData = collection[cardId]; delete collection[cardId]; }
    else if (lockedCards[cardId]) { cardData = lockedCards[cardId]; delete lockedCards[cardId]; }
    else { showMessage("You no longer own that card."); return; }

    cardData.isLocked = false; cardData.lockTime = 0; cardData.lastMutationTime = Date.now();

    await db.ref(`users/${currentUser}/collection`).set(collection || {});
    await db.ref(`users/${currentUser}/lockedCards`).set(lockedCards || {});
    await db.ref(`users/${recipient}/collection/${cardId}`).set(cardData);
    await db.ref(`notifications/${recipient}`).push().set(`${currentUser} sent you a card: "${cardData.name}".`);
    await saveUser(); updateUI(); closeSendModal(); showMessage(`Sent "${cardData.name}" to ${recipient}.`);
  } catch (err) { console.error("sendCardToRecipient err", err); showMessage("Error sending card. Check console."); }
}

/* --------------------
   Steal Flow (protected check)
   -------------------- */
async function getLastStealTimestamp(user) { const snap = await db.ref(`stealCooldowns/${user}`).once('value'); const v = snap.val(); return v || 0; }

async function attemptSteal(cardId, owner) {
  try {
    if (!currentUser) { showMessage("You must be logged in to attempt a steal."); return; }
    if (!cardId) return;
    if (owner === currentUser) { showMessage("You cannot steal your own card."); return; }

    const last = await getLastStealTimestamp(currentUser);
    const now = Date.now();
    if (now - last < STEAL_COOLDOWN_MS) { const remain = Math.ceil((STEAL_COOLDOWN_MS - (now - last)) / 60000); showMessage(`You are on steal cooldown. Try again in ~${remain} minute(s).`); return; }

    const presSnap = await db.ref(`presence/${owner}`).once('value');
    if (!presSnap.exists()) { showMessage(`${owner} is offline — you can only steal from online players.`); return; }

    // Check collection first, then lockedCards
    let ownerCardSnap = await db.ref(`users/${owner}/collection/${cardId}`).once('value');
    let cardData = null; let cardLocation = 'collection';
    if (ownerCardSnap.exists()) { cardData = ownerCardSnap.val(); cardLocation = 'collection'; }
    else { const lockedSnap = await db.ref(`users/${owner}/lockedCards/${cardId}`).once('value'); if (lockedSnap.exists()) { cardData = lockedSnap.val(); cardLocation = 'lockedCards'; } else { showMessage("That card is not available (owner doesn't have it)."); return; } }

    // PROTECTION CHECK
    if (cardData.protectedUntil && cardData.protectedUntil > Date.now()) {
      showMessage(`This card is protected until ${new Date(cardData.protectedUntil).toLocaleString()}.`);
      return;
    }

    // Build math question
    const a = Math.floor(Math.random()*20)+1; const b = Math.floor(Math.random()*20)+1; const op = Math.random() < 0.5 ? '+' : '-';

    const sessionId = generateCardId();
    const session = {
      sessionId, cardId, cardName: cardData.name, attacker: currentUser, defender: owner, cardSnapshot: cardData, cardLocation, question: { a, b, op }, createdAt: Date.now(), winner: null, resolved: false
    };

    await db.ref(`stealSessions/${sessionId}`).set(session);
    await db.ref(`stealRequests/${currentUser}/${sessionId}`).set(session);
    await db.ref(`stealRequests/${owner}/${sessionId}`).set(session);

    showIncomingSteal(sessionId, session, true);

  } catch (err) { console.error("attemptSteal err", err); showMessage("Error starting steal. Check console."); }
}

function showIncomingSteal(sessionId, session, isInitiator=false) {
  activeStealSession = { sessionId, session };
  const q = session.question; const questionText = `${q.a} ${q.op} ${q.b} = ?`;
  const title = (session.attacker === currentUser) ? `You are stealing "${session.cardName}" from ${session.defender}` : `${session.attacker} is attempting to steal "${session.cardName}" from you!`;
  document.getElementById('stealModalTitle').innerText = title;
  document.getElementById('stealQuestion').innerText = questionText;
  document.getElementById('stealAnswerInput').value = '';
  document.getElementById('stealModalHint').innerText = `Solve the question correctly as fast as you can. First correct answer wins.`;
  document.getElementById('stealModal').style.display = 'block';
  if (session.defender === currentUser) { const audio = new Audio('steal.mp3'); audio.play().catch(()=>{}); }
  setTimeout(()=>{ try { document.getElementById('stealAnswerInput').focus(); } catch(e){} }, 200);
}

function closeStealModal() { activeStealSession = null; document.getElementById('stealModal').style.display = 'none'; }

async function submitStealAnswer() {
  try {
    if (!activeStealSession) { closeStealModal(); return; }
    const sessionId = activeStealSession.sessionId; const session = activeStealSession.session;
    const raw = document.getElementById('stealAnswerInput').value.trim(); if (raw === '') { document.getElementById('stealModalHint').innerText = 'Enter an answer.'; return; }
    const num = Number(raw); if (isNaN(num)) { document.getElementById('stealModalHint').innerText = 'Enter a numeric answer.'; return; }

    const correct = (() => { const q = session.question; return q.op === '+' ? (q.a + q.b) === num : (q.a - q.b) === num; })();
    if (!correct) { document.getElementById('stealModalHint').innerText = 'Wrong answer — try again quickly!'; return; }

    await db.ref(`stealSessions/${sessionId}/answers/${currentUser}`).set({ time: Date.now(), correct: true });

    const winnerRef = db.ref(`stealSessions/${sessionId}/winner`);
    winnerRef.transaction(current => { if (current === null) return currentUser; return; }, async (err, committed, snap) => {
      if (err) { console.error("winner transaction err", err); return; }
      if (!committed) {
        const winner = snap && snap.val();
        if (winner === currentUser) { document.getElementById('stealModalHint').innerText = 'Too late — someone else solved it first.'; }
        else { document.getElementById('stealModalHint').innerText = `Too late — ${winner} claimed the win.`; }
        finalizeSteal(sessionId, winner);
      } else { finalizeSteal(sessionId, currentUser); }
    });

  } catch (err) { console.error("submitStealAnswer err", err); document.getElementById('stealModalHint').innerText = 'Error submitting answer.'; }
}

async function finalizeSteal(sessionId, winnerId) {
  try {
    const snap = await db.ref(`stealSessions/${sessionId}`).once('value'); const sess = snap.val(); if (!sess) return;
    if (sess.resolved) { await cleanupStealSession(sessionId); if (document.getElementById('stealModal').style.display === 'block') closeStealModal(); return; }

    const attacker = sess.attacker; const defender = sess.defender; const cardId = sess.cardId; const cardSnapshot = sess.cardSnapshot || {}; const cardLocation = sess.cardLocation || 'collection';

    await db.ref(`stealSessions/${sessionId}/resolved`).set(true);
    await db.ref(`stealSessions/${sessionId}/winner`).set(winnerId);
    await db.ref(`stealCooldowns/${attacker}`).set(Date.now());

    if (winnerId === attacker) {
      const lockRef = db.ref(`cardLocks/${cardId}`);
      const lockResult = await lockRef.transaction(current => { if (current === null) return attacker; return; }, false);

      if (!lockResult || !lockResult.committed) {
        await db.ref(`stealSessions/${sessionId}/result`).set({ success: false, message: "Card is already being processed." });
        await notifyUsersOfStealResult(sessionId, false, attacker, defender);
        await cleanupStealSession(sessionId);
        if (document.getElementById('stealModal').style.display === 'block') closeStealModal();
        return;
      }

      // move card atomically (preserve protection props)
      const updates = {};
      updates[`users/${attacker}/collection/${cardId}`] = cardSnapshot;
      updates[`users/${defender}/collection/${cardId}`] = null;
      updates[`users/${defender}/lockedCards/${cardId}`] = null;

      try {
        await db.ref().update(updates);
        await db.ref(`stealSessions/${sessionId}/result`).set({ success: true, message: `${attacker} stole "${cardSnapshot.name}" from ${defender}` });
        await notifyUsersOfStealResult(sessionId, true, attacker, defender);
      } catch (e) {
        console.error("atomic move failed", e);
        await db.ref(`stealSessions/${sessionId}/result`).set({ success: false, message: "Error transferring card." });
        await notifyUsersOfStealResult(sessionId, false, attacker, defender);
      } finally {
        await lockRef.remove().catch(()=>{});
        await cleanupStealSession(sessionId);
        if (currentUser === attacker || currentUser === defender) loadUserData();
        if (document.getElementById('stealModal').style.display === 'block') closeStealModal();
      }

    } else {
      await db.ref(`stealSessions/${sessionId}/result`).set({ success: false, message: `${winnerId} defended the card.` });
      await notifyUsersOfStealResult(sessionId, false, attacker, defender);
      await cleanupStealSession(sessionId);
      if (document.getElementById('stealModal').style.display === 'block') closeStealModal();
      return;
    }

  } catch (err) {
    console.error("finalizeSteal err", err);
    await db.ref(`stealSessions/${sessionId}/result`).set({ success: false, message: "Error finalizing steal." });
    await cleanupStealSession(sessionId);
    if (document.getElementById('stealModal').style.display === 'block') closeStealModal();
  }
}

async function notifyUsersOfStealResult(sessionId, success, attacker, defender) {
  try {
    const resSnap = await db.ref(`stealSessions/${sessionId}/result`).once('value'); const res = resSnap.val();
    const msgToAttacker = success ? `You successfully stole a card` : `Steal attempt result: ${res && res.message ? res.message : 'Failed'}`;
    const msgToDefender = success ? `${attacker} stole a card from you: ${res && res.message ? res.message : ''}` : `You defended the steal attempt.`;
    await db.ref(`notifications/${attacker}`).push(msgToAttacker);
    await db.ref(`notifications/${defender}`).push(msgToDefender);
  } catch (e) { console.error("notifyUsersOfStealResult err", e); }
}

/* --------------------
   cleanupStealSession (from your second part)
   -------------------- */
async function cleanupStealSession(sessionId) {
  try {
    const sessSnap = await db.ref(`stealSessions/${sessionId}`).once('value'); const sess = sessSnap.val();
    if (!sess) { await db.ref(`stealRequests/${currentUser}/${sessionId}`).remove().catch(()=>{}); return; }
    const attacker = sess.attacker; const defender = sess.defender;
    await db.ref(`stealRequests/${attacker}/${sessionId}`).remove().catch(()=>{});
    await db.ref(`stealRequests/${defender}/${sessionId}`).remove().catch(()=>{});
  } catch (e) { console.error("cleanupStealSession err", e); }
}

/* --------------------
   Admin / Refill
   -------------------- */
function refillStocksPrompt() { const code = prompt("Enter refill code:"); if (code === null) return; if (String(code).trim() === "555") { refillStocks().then(() => { showMessage("Stocks refilled to initial quantities."); }).catch(err => { console.error("refillStocks error:", err); showMessage("Refill failed — check console."); }); } else { showMessage("Incorrect code."); } }
async function refillStocks() { const payload = {}; for (const name in INITIAL_QUANTITIES) payload[toKey(name)] = INITIAL_QUANTITIES[name]; await db.ref('cardQuantities').set(payload); for (const packType in cardPools) { cardPools[packType].forEach(card => { if (INITIAL_QUANTITIES[card.name] !== undefined) card.quantity = INITIAL_QUANTITIES[card.name]; }); } updateUI(); updatePackChances(); await db.ref('adminActions').push({ action: 'refillStocks', by: currentUser || 'unknown', time: Date.now() }); }

/* --------------------
   Small helpers / UI hooks
   -------------------- */
document.getElementById("welcome-btn").addEventListener("click", () => {
  document.getElementById("welcome-container").style.display = "none";
  if (!window.gAudio) { window.gAudio = new Audio('rot.mp3'); window.gAudio.loop = true; window.gAudio.preload = 'auto'; window.gAudio.volume = 0.9; }
  if (window.gAudio.paused) window.gAudio.play().catch(()=>{});
});

const refreshBtn = document.createElement('button');
refreshBtn.id = 'refresh-btn';
refreshBtn.style = "position:fixed; top:20px; right:20px; padding:12px 20px; font-size:18px; border:none; border-radius:10px; background:#2196f3; color:white; cursor:pointer; box-shadow:0 4px 10px rgba(0,0,0,0.3); z-index:9999;";
refreshBtn.innerText = "🔄 Refresh";
refreshBtn.addEventListener("click", ()=> location.reload());
document.body.appendChild(refreshBtn);

window.addEventListener('beforeunload', () => { try { if (currentUser) db.ref(`presence/${currentUser}`).remove(); } catch(e){} });

/* End of main script block */
</script>

<!-- ADD THIS JUST BEFORE </body> -->
<script>
(function enhancePresenceAndLastActive(){
  if (typeof firebase === 'undefined' || !firebase.database) {
    console.warn('Firebase not detected — presence/lastSeen enhancers skipped.');
    return;
  }
  const sv = firebase.database.ServerValue.TIMESTAMP;
  const DB = firebase.database();

  function setupForUser(u){
    if (!u) return;
    try {
      const presRef = DB.ref(`presence/${u}`);
      presRef.onDisconnect().remove();           // remove presence on disconnect
      presRef.set(true).catch(()=>{});          // mark online now

      const lastRef = DB.ref(`lastSeen/${u}`);
      lastRef.onDisconnect().set(sv);           // server will set lastSeen on disconnect
      // also update an initial lastSeen/lastActive right away
      lastRef.set(sv).catch(()=>{});
      DB.ref(`users/${u}/lastActive`).set(sv).catch(()=>{});
    } catch(e) { console.error('setupForUser err', e); }
  }

  async function writeLastSeenNow(u){
    if (!u) return;
    try {
      await DB.ref(`lastSeen/${u}`).set(sv);
    } catch(e) { /* best effort */ console.warn('writeLastSeenNow err', e); }
  }

  // monkeypatch login to run setup after successful login
  if (window.login && !window.__login_enhanced__) {
    const _login = window.login;
    window.login = async function(...args){
      // call original login
      const res = await _login.apply(this, args);
      // if a currentUser variable exists and is set by original login, initialize presence hooks
      if (typeof currentUser !== 'undefined' && currentUser) setupForUser(currentUser);
      return res;
    };
    window.__login_enhanced__ = true;
  }

  // monkeypatch logout to set lastSeen before original logout
  if (window.logout && !window.__logout_enhanced__) {
    const _logout = window.logout;
    window.logout = async function(...args){
      try { if (typeof currentUser !== 'undefined' && currentUser) await DB.ref(`lastSeen/${currentUser}`).set(sv); } catch(e){ console.warn('logout lastSeen err', e); }
      const res = await _logout.apply(this, args);
      return res;
    };
    window.__logout_enhanced__ = true;
  }

  // best-effort beforeunload: server onDisconnect covers unexpected disconnects,
  // but we also attempt a synchronous write / beacon when the user explicitly closes
  window.addEventListener('beforeunload', function(){
    try {
      if (typeof currentUser !== 'undefined' && currentUser) {
        // try navigator.sendBeacon to write a plain timestamp (fallback)
        try {
          const url = `https://pack-f76c3-default-rtdb.firebaseio.com/lastSeen/${encodeURIComponent(currentUser)}.json`;
          navigator.sendBeacon(url, JSON.stringify(Date.now()));
        } catch(e) {}
        // best-effort set (may not finish, but onDisconnect exists)
        try { DB.ref(`lastSeen/${currentUser}`).set(sv); } catch(e) {}
        try { DB.ref(`presence/${currentUser}`).remove(); } catch(e) {}
      }
    } catch(e){ console.warn('beforeunload enhancer err', e); }
  });

  // helper exposed globally so you can call it manually in your app
  window.updateLastActive = function(){
    try {
      if (typeof currentUser === 'undefined' || !currentUser) return;
      DB.ref(`users/${currentUser}/lastActive`).set(sv).catch(()=>{});
      DB.ref(`lastSeen/${currentUser}`).set(sv).catch(()=>{});
    } catch(e){ console.warn('updateLastActive err', e); }
  };

  // wrap common action functions so they update lastActive automatically
  const actionsToWrap = ['openPack','sellCard','sendCardToRecipient','attemptSteal'];
  actionsToWrap.forEach(name => {
    if (window[name] && !window[`__wrapped_${name}`]) {
      const orig = window[name];
      window[name] = function(...args){
        try { window.updateLastActive(); } catch(e){ /* ignore */ }
        return orig.apply(this, args);
      };
      window[`__wrapped_${name}`] = true;
    }
  });

  // If currentUser was already set when this script runs (page restored), ensure setup runs
  if (typeof currentUser !== 'undefined' && currentUser) setupForUser(currentUser);

  console.log('Presence/lastSeen enhancer installed.');
})();
</script>
<!-- END ADD -->

<!-- ORPHAN / GOLD-GLITTER CARD HIGHLIGHTER -->
<style>
  /* visual style for cards that are "no longer in packs" */
  .orphan-card {
    /* soft white base with warm golden tint */
    background: linear-gradient(135deg, #ffffff 0%, #fff9ef 55%, #fff4d9 100%) !important;
    border-color: #d4af37 !important;
    color: #2b1f00 !important;
    box-shadow: 0 6px 18px rgba(212,175,55,0.12), 0 1px 0 rgba(255,255,255,0.5) inset;
    position: relative;
    overflow: hidden;
  }

  /* subtle gold outline */
  .orphan-card::before {
    content: "";
    pointer-events: none;
    position: absolute;
    inset: 0;
    border-radius: inherit;
    box-shadow: 0 0 0 2px rgba(212,175,55,0.18) inset, 0 4px 18px rgba(212,175,55,0.06);
    mix-blend-mode: overlay;
  }

  /* moving glitter layer */
  .orphan-glitter {
    position: absolute;
    left: -60%;
    top: -40%;
    width: 220%;
    height: 180%;
    pointer-events: none;
    background-image:
      radial-gradient(1px 1px at 5% 20%, rgba(255,255,255,0.95) 0, rgba(255,255,255,0) 40%),
      radial-gradient(1.2px 1.2px at 20% 60%, rgba(255,255,255,0.92) 0, rgba(255,255,255,0) 35%),
      radial-gradient(1.6px 1.6px at 50% 30%, rgba(255,240,200,0.85) 0, rgba(255,240,200,0) 35%),
      linear-gradient(90deg, rgba(255,255,255,0.05), rgba(255,230,160,0.06), rgba(255,255,255,0.05));
    transform: translateX(0) rotate(-12deg);
    opacity: 0.95;
    animation: glitterMove 3.5s linear infinite;
    mix-blend-mode: screen;
  }

  @keyframes glitterMove {
    0%   { transform: translateX(-40%) rotate(-12deg); opacity: 0.8; }
    50%  { transform: translateX(0%)   rotate(-12deg); opacity: 1; }
    100% { transform: translateX(40%)  rotate(-12deg); opacity: 0.85; }
  }

  /* make sure quantity/mutation labels remain visible */
  .orphan-card .quantity-label,
  .orphan-card .mutation-label,
  .orphan-card .protected-label,
  .orphan-card .protection-countdown {
    background: rgba(255,255,255,0.9);
    color: #111;
  }

  /* small polish: darker title color for readability */
  .orphan-card h3 { color: #2b1f00 !important; text-shadow: none !important; }
</style>

<script>
(function(){
  // Build a quick set of all "in-pack names" (lowercased) from your cardPools object
  function buildPoolNameSet() {
    const set = new Set();
    try {
      for (const k in cardPools) {
        const arr = cardPools[k] || [];
        arr.forEach(c => { if (c && c.name) set.add(String(c.name).toLowerCase().trim()); });
      }
    } catch(e) { console.warn('buildPoolNameSet err', e); }
    return set;
  }

  let poolNames = buildPoolNameSet();

  // returns true if the card name text isn't found in any pool
  function isOrphanCardName(name) {
    if (!name) return false;
    const normalized = String(name).toLowerCase().trim();
    return !poolNames.has(normalized);
  }

  // scan card DOM nodes and mark/unmark orphan style
  function markOrphanCards() {
    try {
      // targets where cards appear
      const targets = [
        document.getElementById('collection'),
        document.getElementById('otherUserCollection'),
        document.getElementById('openedCard'),
        document.getElementById('cardDetailsContent')
      ].filter(Boolean);

      targets.forEach(container => {
        const nodes = container.querySelectorAll('.card');
        nodes.forEach(cardEl => {
          // card name usually in an H3 inside the card
          const h3 = cardEl.querySelector('h3');
          const name = h3 ? h3.innerText : (cardEl.getAttribute('data-name') || cardEl.textContent);
          if (isOrphanCardName(name)) {
            if (!cardEl.classList.contains('orphan-card')) {
              cardEl.classList.add('orphan-card');
              // add glitter element if not present
              if (!cardEl.querySelector('.orphan-glitter')) {
                const g = document.createElement('div');
                g.className = 'orphan-glitter';
                cardEl.appendChild(g);
              }
            }
          } else {
            if (cardEl.classList.contains('orphan-card')) {
              cardEl.classList.remove('orphan-card');
              const g = cardEl.querySelector('.orphan-glitter');
              if (g) g.remove();
            }
          }
        });
      });
    } catch(e) { console.warn('markOrphanCards err', e); }
  }

  // observe mutations on main containers so newly-rendered cards get rechecked
  const observeTargets = ['collection','otherUserCollection','openedCard','cardDetailsContent'];
  observeTargets.forEach(id => {
    const el = document.getElementById(id);
    if (!el) return;
    const mo = new MutationObserver(markOrphanCards);
    mo.observe(el, { childList: true, subtree: true, attributes: true });
  });

  // monkeypatch updateUI (if present) to run after UI updates
  if (window.updateUI && !window.__wrapped_updateUI_orphan__) {
    const _u = window.updateUI;
    window.updateUI = function(...args){
      const res = _u.apply(this,args);
      try { poolNames = buildPoolNameSet(); } catch(e){}
      setTimeout(markOrphanCards, 40); // slight delay to allow DOM render
      return res;
    };
    window.__wrapped_updateUI_orphan__ = true;
  }

  // also wrap openPack / send / other actions that change pool quantities
  if (window.refillStocks && !window.__wrapped_refillStocks_orphan__) {
    const _r = window.refillStocks;
    window.refillStocks = async function(...args){
      const res = await _r.apply(this,args);
      poolNames = buildPoolNameSet();
      setTimeout(markOrphanCards, 80);
      return res;
    };
    window.__wrapped_refillStocks_orphan__ = true;
  }

  // run once now (and again shortly after load)
  document.addEventListener('DOMContentLoaded', () => { poolNames = buildPoolNameSet(); markOrphanCards(); });
  // also run immediately (script inserted before </body>)
  poolNames = buildPoolNameSet(); markOrphanCards();

  // expose helper (optional)
  window.markOrphanCards = function(){ poolNames = buildPoolNameSet(); markOrphanCards(); };

  console.log('Orphan-card highlighter installed.');
})();
</script>
<!-- END ORPHAN / GOLD-GLITTER CARD HIGHLIGHTER -->

<script>
/* Auto-format #balance on any change using MutationObserver.
   Safe: prevents infinite loops and preserves raw numeric value in dataset.rawValue.
*/

(function installBalanceObserver() {
  const el = document.getElementById('balance');
  if (!el) return console.warn('Balance element not found for observer.');

  // Same formatter you used earlier (1K, 1.2M, etc.)
  function formatNumberShort(num, digits = 1) {
    if (num === null || num === undefined) return '0';
    const n = Number(num);
    if (!isFinite(n)) return String(num);
    const abs = Math.abs(n);
    const sign = n < 0 ? '-' : '';
    if (abs < 1000) return sign + (Math.round(n) === n ? String(Math.round(n)) : String(n));
    const units = [
      { value: 1e12, symbol: 'T' },
      { value: 1e9, symbol: 'B' },
      { value: 1e6, symbol: 'M' },
      { value: 1e3, symbol: 'K' }
    ];
    for (const u of units) {
      if (abs >= u.value) {
        const formatted = (abs / u.value).toFixed(digits);
        const clean = formatted.replace(/\.0+$/, '');
        return sign + clean + u.symbol;
      }
    }
    return String(n);
  }

  function parseNumberFromText(txt) {
    if (txt === null || txt === undefined) return null;
    const s = String(txt).replace(/[, \$x]/g,'').trim();
    if (s === '') return null;
    const v = Number(s);
    return Number.isNaN(v) ? null : v;
  }

  // Perform the formatting once (initial)
  function doFormat() {
    // read freshest text in DOM
    let n = parseNumberFromText(el.innerText);
    // if not parseable, try dataset.rawValue
    if (n === null && el.dataset.rawValue !== undefined) {
      const rv = Number(el.dataset.rawValue);
      if (!Number.isNaN(rv)) n = rv;
    }
    if (n !== null) {
      // store the raw numeric value (string) for other logic to use
      el.dataset.rawValue = String(n);
      // write the short form to the DOM
      el.innerText = formatNumberShort(n);
    }
  }

  // Observer callback (disconnects when updating to avoid loops)
  const mo = new MutationObserver(mutations => {
    // If change came from our own formatting, skip or handle safely.
    // Disconnect observer while we reformat to avoid recursion.
    try {
      mo.disconnect();
      doFormat();
    } catch (e) {
      console.warn('balance formatting error', e);
    } finally {
      // observe again for future changes
      mo.observe(el, { childList: true, characterData: true, subtree: true });
    }
  });

  // Start observing and do an initial format
  mo.observe(el, { childList: true, characterData: true, subtree: true });
  // Run immediately so current raw value (e.g. "1000") becomes "1K"
  doFormat();

  // Expose helper to force refresh from JS if you ever want:
  window.__refreshFormattedBalance = function(digits) {
    const n = parseNumberFromText(el.innerText) ?? (el.dataset.rawValue ? Number(el.dataset.rawValue) : null);
    if (n !== null) {
      el.dataset.rawValue = String(n);
      el.innerText = formatNumberShort(n, digits === undefined ? 1 : digits);
    }
  };

  console.log('Balance observer installed.');
})();
</script>

<script>
(async function(){
  // ---------- CONFIG ----------
  const firebaseConfig = {
    apiKey: "AIzaSyDclp6rqCZRVreOzTcxv840mXcl6nDKAv8",
    authDomain: "pack-f76c3.firebaseapp.com",
    databaseURL: "https://pack-f76c3-default-rtdb.firebaseio.com",
    projectId: "pack-f76c3",
    storageBucket: "pack-f76c3.firebasestorage.app",
    messagingSenderId: "694325056042",
    appId: "1:694325056042:web:aae383919a2ce159892953",
    measurementId: "G-07WXQ7YQ4M"
  };
  const COMPAT_APP = 'https://www.gstatic.com/firebasejs/9.6.1/firebase-app-compat.js';
  const COMPAT_DB  = 'https://www.gstatic.com/firebasejs/9.6.1/firebase-database-compat.js';
  const TEN_MIN = 10* 60 * 1000;

  // ---------- load firebase compat libs if needed ----------
  function loadScriptOnce(src){
    return new Promise((resolve,reject)=>{
      if (document.querySelector(`script[src="${src}"]`)) return resolve();
      const s = document.createElement('script');
      s.src = src; s.onload = () => resolve(); s.onerror = () => reject(new Error('load fail ' + src));
      document.head.appendChild(s);
    });
  }
  if (typeof firebase === 'undefined' || !firebase.database) {
    try { await loadScriptOnce(COMPAT_APP); await loadScriptOnce(COMPAT_DB); }
    catch(e){ console.error('Could not load Firebase libs', e); return; }
  }

  // ---------- init ----------
  if (!firebase.apps || !firebase.apps.length) firebase.initializeApp(firebaseConfig);
  const db = firebase.database();
  const nextRefillRef = db.ref('meta/nextRefill');
  const logsRef = db.ref('meta/refillLogs');

  // ---------- tiny UI (top-left) ----------
  const box = document.createElement('div');
  Object.assign(box.style, {
    position: 'fixed', left: '8px', top: '8px', zIndex: 99999,
    background: 'rgba(0,0,0,0.55)', color: '#fff',
    padding: '6px 8px', borderRadius: '6px',
    fontFamily: 'system-ui, -apple-system, "Segoe UI", Roboto, Arial',
    fontSize: '11px', minWidth: '88px', textAlign: 'center',
    boxShadow: '0 4px 12px rgba(0,0,0,0.25)', backdropFilter: 'blur(4px)'
  });
  box.innerHTML = `<span id="refill-count-small">—</span>`;
  document.body.appendChild(box);
  const el = document.getElementById('refill-count-small');

  // ---------- placeholder refillStocks (keeps user's function if defined) ----------
  if (typeof window.refillStocks !== 'function') {
    window.refillStocks = async function refillStocks(){
      console.log('[refillStocks] placeholder called', new Date().toISOString());
      // implement actual DB stock writes here
    };
  }

  // ---------- keep latest nextRefill and server offset ----------
  let latestNextRefill = null;
  let serverOffset = 0; // ms

  // listen for serverTimeOffset changes (keeps offset fresh)
  db.ref('.info/serverTimeOffset').on('value', snap => { serverOffset = snap.val() || 0; });

  // listen for nextRefill updates
  nextRefillRef.on('value', snap => {
    const v = snap.val();
    latestNextRefill = (typeof v === 'number') ? v : null;
  });

  // ---------- ensure nextRefill exists ----------
  async function ensureNextRefill(){
    try {
      const snap = await nextRefillRef.once('value');
      if (!snap.exists() || typeof snap.val() !== 'number') {
        const serverNow = Date.now() + (await db.ref('.info/serverTimeOffset').once('value')).val() || 0;
        await nextRefillRef.set(serverNow + TEN_MIN);
      }
    } catch(e){ console.error('ensureNextRefill error', e); }
  }

  // ---------- small helper to get serverNow (reads fresh offset) ----------
  async function getServerNow(){
    const offSnap = await db.ref('.info/serverTimeOffset').once('value');
    const off = offSnap.val() || 0;
    return Date.now() + off;
  }

  // ---------- countdown updater (mins & secs only) ----------
  function formatMinSec(ms){
    if (ms <= 0) return '0m 0s';
    const totalSec = Math.floor(ms/1000);
    const m = Math.floor(totalSec/60);
    const s = totalSec % 60;
    return `${m}m ${s}s`;
  }
  setInterval(() => {
    // use locally-cached serverOffset for responsiveness (updated by listener)
    if (!latestNextRefill) { el.textContent = '—'; return; }
    const serverNow = Date.now() + serverOffset;
    const diff = latestNextRefill - serverNow;
    el.textContent = `in ${formatMinSec(diff)}`;
  }, 1000);

  // ---------- claim loop (transactional) ----------
  async function tryClaimAndRun(){
    try {
      const serverNow = await getServerNow();
      nextRefillRef.transaction(curr => {
        if (!curr || curr <= serverNow) return serverNow + TEN_MIN;
        return; // abort
      }, async (err, committed, snapshot) => {
        if (err) { console.error('[refill] tx err', err); return; }
        if (!committed) return;
        // we claimed it
        const newNext = snapshot.val();
        try {
          await Promise.resolve(window.refillStocks());
        } catch(e){ console.error('[refill] refillStocks error', e); }
        try { await logsRef.push({ at: serverNow, nextScheduled: newNext, by:'client' }); }
        catch(e){ console.error('[refill] log write failed', e); }
      }, false);
    } catch(e){ console.error('[refill] claim error', e); }
  }

  // ---------- start ----------
  await ensureNextRefill();
  tryClaimAndRun();
  const claimInterval = setInterval(tryClaimAndRun, 5000);

  // ---------- test helpers ----------
  window.forceRefillNow = async function(){
    const sn = await getServerNow();
    await nextRefillRef.set(sn);
    console.log('forceRefillNow ->', new Date(sn).toISOString());
  };
  window.stopRefillLoop = function(){
    clearInterval(claimInterval);
    nextRefillRef.off();
    db.ref('.info/serverTimeOffset').off();
    console.log('Stopped refill loop.');
  };

  console.log('Tiny refill scheduler started.');
})();
</script>

<script>
/* SHORTEN ALL NUMBERS ON PAGE (safe, dynamic)
   - Replaces numbers with 4+ digits across visible text nodes
   - Skips SCRIPT, STYLE, CODE, PRE, TEXTAREA and elements with data-preserve="true"
   - Updates common display attributes: title, alt, placeholder, aria-label, input/textarea values
   - Observes DOM changes and auto-updates newly inserted content
*/

/* ---------- formatting ---------- */
function formatNumber(n) {
  if (!isFinite(n)) return String(n);
  n = Number(n);
  if (n >= 1_000_000_000) return (n / 1_000_000_000).toFixed(1).replace(/\.0$/, "") + "B";
  if (n >= 1_000_000) return (n / 1_000_000).toFixed(1).replace(/\.0$/, "") + "M";
  if (n >= 1_000) return (n / 1_000).toFixed(1).replace(/\.0$/, "") + "K";
  return String(n);
}

/* ---------- helpers ---------- */
const SKIP_TAGS = new Set(['SCRIPT','STYLE','CODE','PRE','TEXTAREA']);
const ATTRS_TO_UPDATE = ['title','alt','placeholder','aria-label','value'];

function shouldSkipNode(node) {
  if (!node || !node.parentElement) return false;
  const tag = node.parentElement.tagName;
  if (SKIP_TAGS.has(tag)) return true;
  // preserve if developer explicitly requested
  if (node.parentElement.closest && node.parentElement.closest('[data-preserve="true"]')) return true;
  return false;
}

/* Regex matches numbers >= 1000 (with optional commas and decimals)
   - matches: 5000, 1,500,000, 1500000, 12345.67
*/
const NUMBER_REGEX = /(\d{1,3}(?:,\d{3})+|\d{4,})(\.\d+)?/g;

function shortenText(str) {
  return str.replace(NUMBER_REGEX, (match) => {
    const raw = match.replace(/,/g, '');
    const num = Number(raw);
    if (isNaN(num)) return match;
    return formatNumber(num);
  });
}

/* ---------- text nodes traversal ---------- */
function processTextNodes(root = document.body) {
  if (!root) return;
  const walker = document.createTreeWalker(root, NodeFilter.SHOW_TEXT, null, false);
  let node;
  while ((node = walker.nextNode())) {
    if (!node.nodeValue || shouldSkipNode(node)) continue;
    const newText = shortenText(node.nodeValue);
    if (newText !== node.nodeValue) node.nodeValue = newText;
  }
}

/* ---------- attributes (title, alt, placeholder, aria-label, value) ---------- */
function processAttributes(root = document.body) {
  const elements = root.querySelectorAll('*:not(script):not(style):not(code):not(pre):not(textarea)');
  elements.forEach(el => {
    if (el.closest && el.closest('[data-preserve="true"]')) return;
    ATTRS_TO_UPDATE.forEach(attr => {
      if (el.hasAttribute && el.hasAttribute(attr)) {
        try {
          const val = el.getAttribute(attr);
          if (!val) return;
          const newVal = shortenText(val);
          if (newVal !== val) el.setAttribute(attr, newVal);
        } catch (e) {
          // ignore read-only attributes or unexpected exceptions
        }
      } else if (attr === 'value' && (el.tagName === 'INPUT' || el.tagName === 'TEXTAREA')) {
        // update visible text-type inputs (avoid changing input[type=number], radios, checkboxes)
        if (el.type && ['number','checkbox','radio','submit','button','file','hidden'].includes(el.type)) return;
        const val = el.value;
        if (!val) return;
        const newVal = shortenText(val);
        if (newVal !== val) el.value = newVal;
      }
    });
  });
}

/* ---------- run once / safe init ---------- */
function shortenAllNumbers(root = document.body) {
  try {
    processTextNodes(root);
    processAttributes(root);
  } catch (err) {
    console.error('shortenAllNumbers error:', err);
  }
}

/* ---------- observe DOM for changes (dynamic updates) ---------- */
let mutationObserver = null;
function startObserving() {
  if (mutationObserver) return;
  mutationObserver = new MutationObserver(mutations => {
    // throttle: collect affected nodes and process them in batch
    const roots = new Set();
    for (const m of mutations) {
      if (m.addedNodes && m.addedNodes.length) {
        m.addedNodes.forEach(n => { if (n.nodeType === 1) roots.add(n); });
      }
      if (m.target && m.target.nodeType === 1) roots.add(m.target);
    }
    // process each root separately to avoid rewalking entire document for every mutation
    roots.forEach(r => shortenAllNumbers(r));
  });
  mutationObserver.observe(document.body, {
    childList: true,
    subtree: true,
    characterData: true,
    attributes: false
  });
}

/* ---------- execute on load ---------- */
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', () => {
    shortenAllNumbers();
    startObserving();
  });
} else {
  shortenAllNumbers();
  startObserving();
}

/* ---------- optional: public helper to revert/refresh ---------- */
window.__shortenNumbers = {
  run: shortenAllNumbers,
  disconnectObserver: () => { if (mutationObserver) { mutationObserver.disconnect(); mutationObserver = null; } },
  reconnectObserver: startObserving
};
</script>
<!-- ===== Admin message widget (saves seen messages in localStorage) - paste before </body> ===== -->
<!-- Firebase compat SDKs (required for DB) -->
<script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-database-compat.js"></script>

  <style>
    /* container for incoming messages (top-center) */
    #adminMessagesContainer{
      position: fixed;
      top: 12px;
      left: 50%;
      transform: translateX(-50%);
      width: min(920px, calc(100% - 24px));
      z-index: 2147483646;
      display: flex;
      flex-direction: column;
      gap: 10px;
      align-items: center;
      pointer-events: none;
    }

    .adminMsg {
      pointer-events: auto;
      width: 100%;
      background: #000; /* black background */
      color: #fff;
      padding: 14px 18px;
      border-radius: 10px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.6);
      transform-origin: top center;
      animation: slideDown 320ms cubic-bezier(.2,.9,.2,1);
      display: flex;
      gap: 16px;
      align-items: flex-start;
      justify-content: space-between;
      box-sizing: border-box;
    }

    .adminMsg .left {
      display:flex;
      gap:16px;
      align-items:flex-start;
      flex:1;
      min-width:0; /* allow text to wrap */
    }

    .adminMsg .avatar {
      min-width:48px;
      height:48px;
      border-radius:8px;
      display:flex;
      align-items:center;
      justify-content:center;
      font-weight:700;
      color:#fff;
      background: rgba(255,255,255,0.06);
      flex: 0 0 48px;
      font-size:16px;
    }

    .adminMsg .meta {
      display:flex;
      flex-direction:column;
      gap:8px;
      min-width:0;
    }

    .adminMsg .meta .who {
      font-weight:800;
      font-size:15px;
      line-height:1;
      color: #ffffff;
      word-break: break-word;
    }

    .adminMsg .meta .text {
      font-size:15px;
      line-height:1.35;
      white-space: pre-wrap;      /* preserves newlines */
      word-break: break-word;     /* long words will wrap */
      overflow-wrap: anywhere;
      color: inherit;             /* will use provided color */
    }

    .adminMsg .right {
      display:flex;
      gap:8px;
      align-items:flex-start;
      margin-left: 8px;
    }

    .adminMsg .closeBtn {
      background:transparent;
      border:1px solid rgba(255,255,255,0.12);
      padding:6px 10px;
      border-radius:8px;
      color:inherit;
      cursor:pointer;
      font-size:13px;
    }

    @keyframes slideDown {
      from { transform: translateY(-12px) scale(.99); opacity: 0; }
      to { transform: translateY(0) scale(1); opacity: 1; }
    }

    /* admin floating button */
    #adminOpenBtn{
      position: fixed;
      right: 18px;
      bottom: 18px;
      z-index: 2147483647;
      background: #0b1220;
      color: #fff;
      border-radius: 12px;
      padding: 10px 14px;
      box-shadow: 0 10px 30px rgba(2,6,23,0.6);
      cursor:pointer;
      border: none;
      font-weight:800;
    }

    /* FULL-SCREEN overlay + panel */
    #adminOverlay {
      position: fixed;
      inset: 0;
      background: rgba(2,6,23,0.78);
      backdrop-filter: blur(4px);
      z-index: 2147483646;
      display: none;
      align-items: center;
      justify-content: center;
      padding: 18px;
    }

    #adminPanel {
      width: 100%;
      height: 100%;
      max-width: none;
      max-height: none;
      border-radius: 8px;
      background: linear-gradient(180deg,#071122,#091426 60%);
      color: #fff;
      padding: 22px;
      box-shadow: 0 20px 60px rgba(2,6,23,0.6);
      display: flex;
      flex-direction: column;
      gap: 12px;
      overflow: auto;
      position: relative;
    }

    /* header */
    #adminPanelHeader { display:flex; align-items:center; justify-content:space-between; gap:12px; }
    #adminPanelHeader .title { font-size:20px; font-weight:900; }
    #adminPanelHeader .sub { color:#9aa4b2; font-size:13px; }

    /* form controls */
    #adminForm { display:flex; gap:12px; flex-direction:column; width:100%; }
    .formRow { display:flex; gap:12px; align-items:flex-start; }
    .formCol { flex:1; min-width:0; }
    input[type="text"], input[type="number"], textarea, input[type="color"] {
      width:100%;
      box-sizing:border-box;
      padding:12px 14px;
      border-radius:10px;
      border: 1px solid rgba(255,255,255,0.06);
      background: rgba(255,255,255,0.02);
      color: #fff;
      outline: none;
      font-size:15px;
      resize: vertical;
    }

    .controls { display:flex; gap:12px; margin-top:6px; }
    .controls button { padding:10px 14px; border-radius:10px; border:none; cursor:pointer; font-weight:800; }
    .btnPrimary { background: linear-gradient(90deg,#06b6d4,#0ea5b3); color:#04121a; }
    .btnGhost { background:transparent; border:1px solid rgba(255,255,255,0.08); color:#fff; }

    #adminPanelFooter { margin-top:auto; color:#9aa4b2; font-size:13px; display:flex; align-items:center; justify-content:space-between; gap:12px; }

    #closeAdminPanel { background:transparent; color:#9aa4b2; border:none; font-size:20px; cursor:pointer; }

    @media (max-width:720px) {
      #adminPanel { padding: 12px; }
      .formRow { flex-direction: column; }
      .adminMsg { padding:12px; gap:12px; }
      .adminMsg .avatar { min-width:40px; height:40px; flex:0 0 40px; }
    }
  </style>

  <div id="adminMessagesContainer" aria-live="polite"></div>

  <button id="adminOpenBtn" title="Admin">Admin</button>

  <!-- Fullscreen overlay -->
  <div id="adminOverlay" role="dialog" aria-modal="true" aria-hidden="true">
    <div id="adminPanel" role="document" aria-label="Admin panel">
      <div id="adminPanelHeader">
        <div>
          <div class="title">Admin — Post message</div>
          <div class="sub">Enter code to open. Messages saved to <code>adminMessages</code>.</div>
        </div>
        <div style="display:flex;gap:8px;align-items:center;">
          <button id="closeAdminPanel" title="Close">✕</button>
        </div>
      </div>

      <form id="adminForm" onsubmit="return false;">
        <div style="display:flex;gap:12px;align-items:center;">
          <label style="color:#9aa4b2;font-size:13px;min-width:72px">Name</label>
          <input id="adminName" type="text" class="formCol" placeholder="e.g. zezo" />
        </div>

        <div style="display:flex;gap:12px;">
          <label style="color:#9aa4b2;font-size:13px;min-width:72px;align-self:flex-start">Message</label>
          <textarea id="adminMsg" rows="6" class="formCol" placeholder="Your message..."></textarea>
        </div>

        <div class="formRow">
          <div class="formCol" style="max-width:220px;">
            <label style="color:#9aa4b2;font-size:13px">Duration (seconds)</label>
            <input id="adminDuration" type="number" min="1" value="6" />
          </div>
          <div class="formCol" style="max-width:160px;">
            <label style="color:#9aa4b2;font-size:13px">Text color</label>
            <input id="adminColor" type="color" value="#ffffff" />
          </div>
          <div class="formCol" style="max-width:140px;">
            <label style="color:#9aa4b2;font-size:13px">Target (optional)</label>
            <input id="adminTarget" type="text" placeholder="leave blank = all users" />
          </div>
        </div>

        <div class="controls">
          <button id="postAdminMsg" class="btnPrimary" type="button">Post message</button>
          <button id="showPreview" class="btnGhost" type="button">Preview (local)</button>
          <button id="clearSeenLocal" class="btnGhost" type="button">Clear Seen (local)</button>
        </div>
      </form>

      <div id="adminPanelFooter">
        <div>Messages are posted to your Firebase Realtime DB at <code>adminMessages</code>.</div>
        <div style="opacity:0.9">
          <small style="color:#9aa4b2">Tip: press <kbd>Esc</kbd> to close</small>
        </div>
      </div>
    </div>
  </div>

  <script>
  document.addEventListener('DOMContentLoaded', function () {
    // ---------- YOUR firebaseConfig (from your message) ----------
    const firebaseConfig = {
      apiKey: "AIzaSyDclp6rqCZRVreOzTcxv840mXcl6nDKAv8",
      authDomain: "pack-f76c3.firebaseapp.com",
      databaseURL: "https://pack-f76c3-default-rtdb.firebaseio.com",
      projectId: "pack-f76c3",
      storageBucket: "pack-f76c3.firebasestorage.app",
      messagingSenderId: "694325056042",
      appId: "1:694325056042:web:aae383919a2ce159892953",
      measurementId: "G-07WXQ7YQ4M"
    };

    // Initialize Firebase
    let firebaseAvailable = false;
    try {
      if (firebaseConfig && firebaseConfig.apiKey) {
        if (typeof firebase !== 'undefined' && firebase.initializeApp) {
          firebase.initializeApp(firebaseConfig);
          if (firebase.database) firebaseAvailable = true;
        } else {
          console.warn('Firebase SDK loaded but "firebase" is undefined or missing initializeApp.');
        }
      }
    } catch (err) {
      console.error('Firebase init error:', err);
    }

    // ------------------ Seen state in localStorage -------------------
    const SEEN_KEY = 'adminMessagesSeen_v2';
    function getSeenSet() {
      try {
        const raw = localStorage.getItem(SEEN_KEY) || '[]';
        return new Set(JSON.parse(raw));
      } catch (e) {
        return new Set();
      }
    }
    function saveSeenSet(set) {
      try { localStorage.setItem(SEEN_KEY, JSON.stringify([...set])); } catch(e){}
    }
    function hasSeen(id) {
      return getSeenSet().has(id);
    }
    function addSeen(id) {
      if (!id) return;
      const s = getSeenSet();
      if (!s.has(id)) {
        s.add(id);
        saveSeenSet(s);
      }
    }
    function clearSeenLocal() {
      if (confirm('Clear locally saved seen messages? Users will see messages again after refresh.')) {
        localStorage.removeItem(SEEN_KEY);
        alert('Local seen list cleared.');
      }
    }

    // ------------------ UI elements -------------------
    const adminBtn = document.getElementById('adminOpenBtn');
    const adminOverlay = document.getElementById('adminOverlay');
    const adminPanel = document.getElementById('adminPanel');
    const closeAdminPanel = document.getElementById('closeAdminPanel');
    const postBtn = document.getElementById('postAdminMsg');
    const previewBtn = document.getElementById('showPreview');
    const clearSeenBtn = document.getElementById('clearSeenLocal');
    const container = document.getElementById('adminMessagesContainer');

    // Panel open/close
    function openPanel() {
      adminOverlay.style.display = 'flex';
      adminOverlay.setAttribute('aria-hidden','false');
      setTimeout(()=> document.getElementById('adminName').focus(), 120);
    }
    function closePanel() {
      adminOverlay.style.display = 'none';
      adminOverlay.setAttribute('aria-hidden','true');
    }

    // Password flow: require 246
    adminBtn.addEventListener('click', () => {
      try {
        const code = prompt('Enter admin code (required):');
        if (code === null) return;
        if (String(code).trim() === '246') {
          openPanel();
        } else {
          alert('Wrong code.');
        }
      } catch (e) {
        console.error(e);
        alert('An error occurred, check console.');
      }
    });

    adminBtn.addEventListener('dblclick', () => {
      if (adminOverlay.style.display === 'flex') closePanel(); else openPanel();
    });

    closeAdminPanel.addEventListener('click', closePanel);
    document.addEventListener('keydown', (e) => { if (e.key === 'Escape') closePanel(); });

    clearSeenBtn.addEventListener('click', clearSeenLocal);

    // --------------- Post message to Firebase ----------------
    postBtn.addEventListener('click', async () => {
      const name = document.getElementById('adminName').value.trim() || 'Admin';
      const msg = document.getElementById('adminMsg').value.trim();
      const duration = parseInt(document.getElementById('adminDuration').value,10) || 6;
      const color = document.getElementById('adminColor').value || '#ffffff';
      const target = document.getElementById('adminTarget').value.trim() || '';

      if (!msg) { alert('Please enter a message.'); return; }

      const payload = {
        name,
        text: msg,
        duration,
        color,
        target,
        createdAt: Date.now()
      };

      if (firebaseAvailable) {
        try {
          await firebase.database().ref('adminMessages').push(payload);
          document.getElementById('adminMsg').value = '';
          alert('Message posted to Firebase.');
        } catch (err) {
          console.error(err);
          alert('Failed to post message to Firebase. See console.');
        }
      } else {
        console.warn('Firebase not available - showing message locally only.');
        const pseudoId = 'local-' + Date.now() + '-' + Math.floor(Math.random()*10000);
        showMessage(pseudoId, payload);
        // mark seen immediately (since user saw it)
        addSeen(pseudoId);
        alert('Message shown locally (not persisted).');
      }
    });

    // Preview button (local-only)
    previewBtn.addEventListener('click', () => {
      const name = document.getElementById('adminName').value.trim() || 'Admin';
      const msg = document.getElementById('adminMsg').value.trim() || 'Preview message';
      const duration = parseInt(document.getElementById('adminDuration').value,10) || 6;
      const color = document.getElementById('adminColor').value || '#ffffff';
      const payload = { name, text: msg, duration, color, createdAt: Date.now() };
      const pseudoId = 'preview-' + Date.now();
      showMessage(pseudoId, payload);
      // mark preview as seen so it won't reappear on refresh
      addSeen(pseudoId);
    });

    // --------------- Displaying incoming messages (with local seen tracking) ----------------
    function buildMessageElement(id, data) {
      const el = document.createElement('div');
      el.className = 'adminMsg';
      el.dataset.msgId = id;

      const left = document.createElement('div');
      left.className = 'left';

      const avatar = document.createElement('div');
      avatar.className = 'avatar';
      avatar.textContent = (data.name || 'A').slice(0,2).toUpperCase();

      const meta = document.createElement('div');
      meta.className = 'meta';
      const who = document.createElement('div');
      who.className = 'who';
      who.textContent = (data.name ? data.name : 'Admin');
      const text = document.createElement('div');
      text.className = 'text';
      text.innerText = data.text || '';
      text.style.color = data.color || '#ffffff';

      meta.appendChild(who);
      meta.appendChild(text);
      left.appendChild(avatar);
      left.appendChild(meta);

      const right = document.createElement('div');
      right.className = 'right';

      // Close button: remove locally and mark as seen so it won't reappear
      const closeBtn = document.createElement('button');
      closeBtn.className = 'closeBtn';
      closeBtn.textContent = 'Close';
      closeBtn.addEventListener('click', () => {
        addSeen(id);
        el.style.transition = 'opacity .25s, transform .25s';
        el.style.opacity = '0';
        el.style.transform = 'translateY(-8px) scale(.99)';
        setTimeout(()=> el.remove(), 260);
      });
      right.appendChild(closeBtn);

      el.appendChild(left);
      el.appendChild(right);

      return el;
    }

    // Show message: prepend so newest on top, skip if seen
    function showMessage(id, data) {
      if (!id) id = 'msg-' + Date.now();
      if (hasSeen(id)) return; // skip if locally seen already

      const el = buildMessageElement(id, data);
      container.prepend(el);

      // mark as seen shortly after it appears (user has "seen" it)
      setTimeout(() => addSeen(id), 400);

      // Auto-remove after duration if provided and >0; when removed, ensure marked seen
      const dur = (data.duration && Number(data.duration)) ? Number(data.duration) * 1000 : 0;
      if (dur > 0) {
        setTimeout(() => {
          if (document.body.contains(el)) {
            addSeen(id);
            el.style.transition = 'opacity .25s, transform .25s';
            el.style.opacity = '0';
            el.style.transform = 'translateY(-8px) scale(.99)';
            setTimeout(()=> { if (el.remove) el.remove(); }, 260);
          }
        }, dur);
      }
    }

    // --------------- Firebase listener for child_added (skip seen) ----------------
    if (firebaseAvailable) {
      try {
        const ref = firebase.database().ref('adminMessages').limitToLast(200);
        ref.on('child_added', snapshot => {
          const id = snapshot.key;
          const data = snapshot.val();
          if (!data || !data.text) return;
          try { showMessage(id, data); } catch (e) { console.error('showMessage err', e); }
        });
      } catch (e) {
        console.error('Firebase listener setup failed:', e);
      }
    } else {
      // no firebase: preview and local posting still work
    }

    // Expose debug helpers
    window._adminMessages = {
      showMessage,
      hasSeen,
      addSeen,
      getSeenSet: () => Array.from(getSeenSet()),
      clearSeenLocal
    };

  }); // DOMContentLoaded
  </script>
  <script>
  /*
    Pack game: listen to /topNotices and display top banner
    - Paste this exactly before </body> in your pack game page.
    - Requires firebase.database() available (your pack already does).
    - Shows the stored `.text` for each notice; notices are removed when expireAt passes.
  */
  (function(){
    const _db = (typeof db !== 'undefined') ? db : (window.firebase && firebase.database ? firebase.database() : null);
    if (!_db) { console.warn('[topNotices] Firebase DB not found.'); return; }

    // create top banner UI if not already present
    function ensureUI(){
      let wrapper = document.getElementById('globalTopNoticeWrap');
      if (wrapper) return { wrapper, textEl: wrapper.querySelector('.notice-text') };
      wrapper = document.createElement('div');
      wrapper.id = 'globalTopNoticeWrap';
      Object.assign(wrapper.style, {
        position:'fixed', top:'10px', left:'50%', transform:'translateX(-50%)',
        zIndex:2147483647, display:'none', pointerEvents:'none'
      });
      const box = document.createElement('div');
      box.className = 'notice-box';
      Object.assign(box.style, {
        background:'#000', color:'#fff', padding:'10px 16px', borderRadius:'10px',
        fontWeight:700, boxShadow:'0 8px 30px rgba(0,0,0,0.35)', pointerEvents:'auto',
        maxWidth:'92vw', textAlign:'center', fontFamily:'Inter, system-ui, Arial, sans-serif'
      });
      const text = document.createElement('div'); text.className = 'notice-text';
      box.appendChild(text);
      wrapper.appendChild(box);
      document.body.appendChild(wrapper);
      return { wrapper, textEl: text };
    }

    const { wrapper: noticeWrap, textEl: noticeText } = ensureUI();
    const active = {}; // key -> { val, timeoutId }

    function show(text){
      noticeText.innerText = text;
      noticeWrap.style.display = 'block';
      noticeWrap.style.opacity = '1';
    }
    function hide(){
      noticeWrap.style.opacity = '0';
      setTimeout(()=> { try { noticeWrap.style.display = 'none'; } catch(e){} }, 260);
    }

    async function scheduleRemove(key, val){
      try {
        if (!val || !val.expireAt) return;
        const msLeft = Number(val.expireAt) - Date.now();
        if (msLeft <= 0) {
          try { await _db.ref('topNotices/' + key).remove().catch(()=>{}); } catch(e){}
          return;
        }
        if (active[key] && active[key].timeoutId) clearTimeout(active[key].timeoutId);
        active[key] = active[key] || {};
        active[key].timeoutId = setTimeout(async () => {
          try {
            const ref = _db.ref('topNotices/' + key);
            const snap = await ref.once('value');
            const node = snap.val();
            if (node && node.expireAt && Number(node.expireAt) <= Date.now()) {
              await ref.remove().catch(()=>{});
            }
          } catch(e) { console.warn('[topNotices] scheduled removal failed', e); }
        }, msLeft + 50);
      } catch(e){ console.warn('[topNotices] scheduleRemove err', e); }
    }

    function pickTop(){
      let best = null;
      for (const k in active){
        const it = active[k];
        if (!it || !it.val) continue;
        const exp = Number(it.val.expireAt || 0);
        if (!best || exp > Number(best.val.expireAt || 0)) best = { key: k, val: it.val };
      }
      return best;
    }

    function renderActive(){
      const top = pickTop();
      if (!top) { hide(); return; }
      const secLeft = Math.max(0, Math.ceil((Number(top.val.expireAt) - Date.now()) / 1000));
      show(`${top.val.text}${secLeft>0 ? ` — ${secLeft}s` : ''}`);
    }

    const ref = _db.ref('topNotices');

    ref.on('child_added', snap => {
      try {
        const k = snap.key; const v = snap.val(); if (!v) return;
        active[k] = active[k] || {};
        active[k].val = v;
        scheduleRemove(k, v);
        renderActive();
      } catch(e){ console.error('[topNotices] child_added', e); }
    });

    ref.on('child_changed', snap => {
      try {
        const k = snap.key; const v = snap.val(); active[k] = active[k] || {}; active[k].val = v;
        scheduleRemove(k, v);
        renderActive();
      } catch(e){ console.error('[topNotices] child_changed', e); }
    });

    ref.on('child_removed', snap => {
      try {
        const k = snap.key;
        if (active[k] && active[k].timeoutId) clearTimeout(active[k].timeoutId);
        delete active[k];
        renderActive();
      } catch(e){ console.error('[topNotices] child_removed', e); }
    });

    // refresh UI once per second for countdown
    setInterval(renderActive, 1000);

    // expose helpers for debugging
    window._topNoticesLocal = {
      active,
      publishLocal: async (text, seconds = 7) => {
        const now = Date.now(); const expireAt = now + seconds*1000;
        await _db.ref('topNotices').push({ text, createdAt: now, expireAt, source: 'game-console' });
      },
      removeByKey: async (k) => { await _db.ref('topNotices/' + k).remove().catch(()=>{}); }
    };

    console.log('[topNotices] listener active (showing DB text exactly as stored).');
  })();
  </script>
  <!-- ===== Rebirth system (stores LEVEL under accounts/{username}/LEVEL) ===== -->
  <style>
    /* Rebirth modal + small header button */
    #rebirthBtnHeader { margin-left: 8px; }
    #rebirthModalBox {
      display:none; position:fixed; z-index:2000; left:50%; top:50%;
      transform:translate(-50%,-50%); background:#fff; padding:18px; border-radius:12px;
      box-shadow:0 12px 40px rgba(0,0,0,0.35); width:min(420px,94%); text-align:left;
    }
    #rebirthModalBox h3 { margin:0 0 8px 0; font-size:20px; }
    #rebirthModalBox p { margin:6px 0; color:#333; }
    #rebirthModalBox .req { background:#fff9e6; border-radius:8px; padding:10px; margin:10px 0; border:1px solid #ffecb3; }
    #rebirthModalBox .actions { display:flex; gap:10px; justify-content:flex-end; margin-top:12px; }
    .btn-rebirth { background:linear-gradient(180deg,#ffd64d 0%,#ffcc00 100%); color:#1a1a1a; border-radius:8px; padding:10px 16px; font-weight:800; border:1px solid rgba(0,0,0,0.06); cursor:pointer; }
    .btn-rebirth[disabled] { opacity:0.45; cursor:not-allowed; filter:grayscale(0.12); }
    #rebirthClose { background:#eee; border-radius:8px; padding:10px 14px; cursor:pointer; border:1px solid #ddd; }
    #rebirthNotice { color:#666; font-size:0.9rem; }
    #userLevelDisplay { font-size:0.95rem; color:#222; margin-top:4px; }
  </style>

  <!-- Modal markup -->
  <div id="rebirthModalBox" role="dialog" aria-modal="true" aria-hidden="true">
    <h3 id="rebirthTitle">Rebirth</h3>
    <div id="rebirthContent">
      <p id="rebirthDesc">Prepare to rebirth and increase your level.</p>
      <div class="req">
        <div><strong>Required Card:</strong> <span id="rebirthReqCard">—</span></div>
        <div><strong>Required Money:</strong> <span id="rebirthReqMoney">—</span></div>
        <div id="rebirthHasCard" style="margin-top:6px;color:#333;"></div>
        <div id="rebirthHasMoney" style="margin-top:6px;color:#333;"></div>
      </div>
      <div id="rebirthNotice">If you rebirth your cards will be reset and your balance will become $500.</div>
    </div>
    <div class="actions">
      <button id="rebirthClose" onclick="closeRebirthModal()">Cancel</button>
      <button id="rebirthConfirm" class="btn-rebirth" disabled>Rebirth</button>
    </div>
  </div>

  <script>
  (function(){
    // ==== CONFIG: Edit this to add more levels ====
    // money may be a number (plain integer) or a shorthand string "5M", "1.2K", etc.
    const REBIRTH_LEVELS = [
      { level: 2, card: "Zezo SECRET", money: "5M" },
      { level: 3, card: "lilly kowaferr", money: "10M" },
      { level: 4, card: "Asser colotinni fasatennee", money: "150M" },
      { level: 5, card: "Zezo Prismatic", money: "350M" },
      { level: 6, card: "LILLY EXAM", money: "650M" },
      { level: 7, card: "CANDY ZEZO", money: "850M" },
      { level: 8, card: "CANDY RED DEAD REDEMTION II", money: "1B" },
      { level: 9, card: "CANDY ROCKET LEAGUE", money: "1.25B" },
      { level: 10, card: "CANDY MR.ZEZO", money: "1.5B" },
      { level: 11, card: "CANDY 67", money: "2.25B" },
      { level: 12, card: "CANDY MEOWL", money: "2.75B" },
      { level: 13, card: "BLOODMOON GARAMA AND MADUNG", money: "3B" },
      { level: 14, card: "BLOODMOON MEOWL", money: "3.25B" },
      { level: 15, card: "BLOODMOON 67", money: "3.5B" },
      { level: 16, card: "BLOODMOON LOS BROS", money: "3.75B" },
      { level: 17, card: "BLOODMOON LOS ZEZOS", money: "4B" },
      { level: 18, card: "BLOODMOON LOS TUNGTUNGCITOS", money: "4.25B" },
      { level: 19, card: "BLOODMOON MADRID VS BARCA", money: "4.5B" },
    ];

    // ==== HELPERS ====
    function parseMoneyValue(v) {
      if (v === undefined || v === null) return 0;
      if (typeof v === 'number') return v;
      const s = String(v).trim().toUpperCase();
      const m = s.match(/^([\d.,]+)\s*([KMB])?$/);
      if (!m) return Number(s.replace(/[, ]+/g,'')) || 0;
      let num = Number(m[1].replace(/,/g,''));
      const unit = m[2];
      if (unit === 'K') num *= 1e3;
      if (unit === 'M') num *= 1e6;
      if (unit === 'B') num *= 1e9;
      return Math.round(num);
    }

    function humanMoney(n) {
      if (n === null || n === undefined) return '$0';
      const num = Number(n);
      if (!isFinite(num)) return String(n);
      if (Math.abs(num) >= 1e9) return (num/1e9).toFixed(1).replace(/\.0$/,'') + 'B';
      if (Math.abs(num) >= 1e6) return (num/1e6).toFixed(1).replace(/\.0$/,'') + 'M';
      if (Math.abs(num) >= 1e3) return (num/1e3).toFixed(1).replace(/\.0$/,'') + 'K';
      return '$' + num;
    }

    // check if user has a card by exact (case-insensitive) name in collection or lockedCards
    function userHasCard(cardName) {
      if (!cardName) return false;
      const target = String(cardName).trim().toLowerCase();
      try {
        for (const id in (collection || {})) {
          const c = collection[id];
          if (!c || !c.name) continue;
          if (String(c.name).trim().toLowerCase() === target) return true;
        }
        for (const id in (lockedCards || {})) {
          const c = lockedCards[id];
          if (!c || !c.name) continue;
          if (String(c.name).trim().toLowerCase() === target) return true;
        }
      } catch(e){ console.warn('userHasCard err',e); }
      return false;
    }

    // ==== DOM refs ====
    const rebirthModal = document.getElementById('rebirthModalBox');
    const rebirthReqCard = document.getElementById('rebirthReqCard');
    const rebirthReqMoney = document.getElementById('rebirthReqMoney');
    const rebirthHasCard = document.getElementById('rebirthHasCard');
    const rebirthHasMoney = document.getElementById('rebirthHasMoney');
    const rebirthConfirm = document.getElementById('rebirthConfirm');

    // ----- IMPORTANT: accounts path constant (LEVEL stored here) -----
    const ACCOUNTS_LEVEL_PATH = (user) => `accounts/${user}/LEVEL`;

    // display/close helpers
    window.openRebirthModal = async function() {
      if (!currentUser) { showMessage('You must be logged in to rebirth.'); return; }
      const level = await getCurrentUserLevel(); // now reads from /accounts/{user}/LEVEL
      const nextLevel = (typeof level === 'number') ? level + 1 : 2;
      const req = REBIRTH_LEVELS.find(r => r.level === nextLevel);
      if (!req) {
        showMessage(`you are now MAX REBIRTH ${nextLevel}.more rebirths on the way `);
        return;
      }
      // fill UI
      rebirthReqCard.innerText = req.card || '—';
      rebirthReqMoney.innerText = humanMoney(parseMoneyValue(req.money));
      // eligibility checks
      const hasCard = userHasCard(req.card);
      const hasMoney = (Number(balance || 0) >= parseMoneyValue(req.money));
      rebirthHasCard.innerText = hasCard ? 'Card found in your collection.' : 'Required card not found.';
      rebirthHasCard.style.color = hasCard ? '#166534' : '#8b0000';
      rebirthHasMoney.innerText = hasMoney ? `You have ${humanMoney(balance)} (required ${humanMoney(parseMoneyValue(req.money))}).` : `Insufficient funds: you have ${humanMoney(balance)}.`;
      rebirthHasMoney.style.color = hasMoney ? '#166534' : '#8b0000';
      // enable/disable confirm
      rebirthConfirm.disabled = !(hasCard && hasMoney);
      // store current displayed requirement on the button for safety
      rebirthConfirm.dataset.reqLevel = req.level;
      rebirthConfirm.dataset.reqCard = req.card;
      rebirthConfirm.dataset.reqMoney = parseMoneyValue(req.money);
      // show modal
      rebirthModal.style.display = 'block';
    };

    window.closeRebirthModal = function() {
      rebirthModal.style.display = 'none';
      rebirthConfirm.dataset.reqLevel = '';
      rebirthConfirm.dataset.reqCard = '';
      rebirthConfirm.dataset.reqMoney = '';
    };

    // ==== Rebirth action ====
    async function performRebirth() {
      if (!currentUser) { showMessage('You must be logged in.'); return; }
      const reqLevel = Number(rebirthConfirm.dataset.reqLevel || 0);
      const reqCard = String(rebirthConfirm.dataset.reqCard || '').trim();
      const reqMoney = Number(rebirthConfirm.dataset.reqMoney || 0);

      if (!reqLevel || !reqCard) { showMessage('Invalid rebirth requirement data.'); return; }

      // re-check eligibility (server-trustable path would be better)
      const freshUserSnap = await db.ref(`users/${currentUser}`).once('value');
      const userNode = freshUserSnap.exists() ? freshUserSnap.val() : {};
      const currentBalance = Number(userNode.balance || balance || 0);
      // check card existence in local caches (good enough for now)
      const hasCard = userHasCard(reqCard);
      if (!hasCard) { showMessage('You no longer have the required card.'); closeRebirthModal(); return; }
      if (currentBalance < reqMoney) { showMessage('You do not have the required money.'); closeRebirthModal(); return; }

      // perform update: reset collections, set balance to 500, set new level UNDER accounts/{user}/LEVEL
      const newLevel = reqLevel;
      const updates = {};
      updates[`users/${currentUser}/balance`] = 500;
      updates[`users/${currentUser}/collection`] = {};       // reset to empty
      updates[`users/${currentUser}/lockedCards`] = {};     // reset to empty
      // **store LEVEL under accounts path only**
      updates[ACCOUNTS_LEVEL_PATH(currentUser)] = newLevel;
      // optional log
      updates[`adminActions/rebirths/${Date.now()}_${currentUser}`] = { by: currentUser, newLevel, at: Date.now(), reason: `Rebirth: level ${newLevel}` };

      try {
        await db.ref().update(updates);
        // update local state to reflect changes
        balance = 500;
        collection = {};
        lockedCards = {};
        // persist other user fields (saveUser uses update and won't touch accounts/*)
        await saveUser().catch(()=>{ /* not fatal if already updated above */ });
        updateUI();
        updateUserLevelUI(newLevel); // local UI update
        showMessage(`Rebirth successful! You are now level ${newLevel}. Your collection has been reset and balance set to $500.`);
      } catch (err) {
        console.error('performRebirth err', err);
        showMessage('Error performing rebirth. See console for details.');
      } finally {
        closeRebirthModal();
      }
    }

    rebirthConfirm.addEventListener('click', function(){
      const doIt = confirm('Are you sure? Rebirthing resets your collection and sets your balance to $500.');
      if (!doIt) return;
      performRebirth();
    });

    // ==== User level UI handling (reads/writes only under accounts/{user}/LEVEL) ====
    let levelRefHandle = null;
    function updateUserLevelUI(val) {
      try {
        let wrap = document.getElementById('userLevelDisplay');
        if (!wrap) {
          const headerActions = document.querySelector('.header-actions');
          if (headerActions) {
            const right = headerActions.querySelector('.header-right') || headerActions;
            const d = document.createElement('div');
            d.id = 'userLevelDisplay';
            d.innerText = 'Level: 1';
            right.insertBefore(d, right.firstChild || null);
          }
          wrap = document.getElementById('userLevelDisplay');
        }
        const levelText = (val !== undefined && val !== null) ? val : (window._cachedUserLevel || 1);
        if (wrap) wrap.innerText = `Level: ${levelText}`;
        window._cachedUserLevel = levelText;
      } catch(e){ console.warn('updateUserLevelUI err', e); }
    }

    async function getCurrentUserLevel() {
      if (!currentUser) return 1;
      try {
        const snap = await db.ref(ACCOUNTS_LEVEL_PATH(currentUser)).once('value');
        const v = snap.exists() ? snap.val() : null;
        const level = (v === null || v === undefined) ? 1 : Number(v || 1);
        window._cachedUserLevel = level;
        updateUserLevelUI(level);
        return level;
      } catch(e){ console.warn('getCurrentUserLevel err', e); return (window._cachedUserLevel || 1); }
    }

    // attach DB listener to keep UI in sync (listens to accounts/{user}/LEVEL)
    function attachLevelListenerForUser(u) {
      try {
        if (!u) return;
        if (levelRefHandle) { try { levelRefHandle.off(); } catch(e){} levelRefHandle = null; }
        const ref = db.ref(ACCOUNTS_LEVEL_PATH(u));
        ref.on('value', snap => {
          const v = snap.exists() ? snap.val() : 1;
          window._cachedUserLevel = Number(v || 1);
          updateUserLevelUI(window._cachedUserLevel);
        });
        levelRefHandle = ref;
      } catch(e){ console.warn('attachLevelListenerForUser err', e); }
    }

    function detachLevelListener() {
      try {
        if (levelRefHandle) { levelRefHandle.off(); levelRefHandle = null; }
      } catch(e){ console.warn('detachLevelListener err', e); }
    }

    // Monkeypatch login/logout to attach/detach level listener (idempotent)
    if (window.login && !window.__rebirth_wrapped_login__) {
      const _login = window.login;
      window.login = async function(...args) {
        const res = await _login.apply(this, args);
        try { if (currentUser) { attachLevelListenerForUser(currentUser); getCurrentUserLevel().catch(()=>{}); } } catch(e){}
        return res;
      };
      window.__rebirth_wrapped_login__ = true;
    }
    if (window.logout && !window.__rebirth_wrapped_logout__) {
      const _logout = window.logout;
      window.logout = function(...args) {
        try { detachLevelListener(); } catch(e){}
        return _logout.apply(this, args);
      };
      window.__rebirth_wrapped_logout__ = true;
    }

    // ==== Add header button (if header exists) ====
    function injectRebirthButton() {
      try {
        const hdrRight = document.querySelector('.header-right');
        if (!hdrRight) return;
        if (document.getElementById('rebirthBtnHeader')) return;
        const btn = document.createElement('button');
        btn.id = 'rebirthBtnHeader';
        btn.className = 'btn-rebirth';
        btn.innerText = 'Rebirth';
        btn.onclick = openRebirthModal;
        hdrRight.prepend(btn);
        updateUserLevelUI();
      } catch(e){ console.warn('injectRebirthButton err', e); }
    }

    injectRebirthButton();
    document.addEventListener('DOMContentLoaded', injectRebirthButton);

    // watch for currentUser to be set after this script loads
    (function watchForUser() {
      let attempts = 0;
      const id = setInterval(() => {
        attempts++;
        if (currentUser) {
          attachLevelListenerForUser(currentUser);
          getCurrentUserLevel().catch(()=>{});
          clearInterval(id);
          return;
        }
        if (attempts > 120) clearInterval(id);
      }, 1000);
    })();

    // expose small helpers for debug
    window._rebirth = {
      REBIRTH_LEVELS,
      openRebirthModal,
      performRebirth,
      parseMoneyValue,
      userHasCard,
      ACCOUNTS_LEVEL_PATH
    };

  })(); // IIFE
  </script>
  <!-- ===== END Rebirth system (accounts/USERNAME/LEVEL) ===== -->
<script>
/* -------- Rebirth Sell-Multiplier (paste after your rebirth system) --------
   Behavior:
   - Level stored at accounts/{user}/LEVEL (your existing code)
   - Multiplier = 1.0 + (level - 1) * 0.5
   - When selling a card: soldPrice = round(card.currentPrice * multiplier)
   - UI: shows "Sell Multiplier: ×1.5" next to Level display
*/

(function(){

  // read current cached level (your rebirth code writes window._cachedUserLevel)
  function getUserLevel() {
    // fallback to 1 if unknown
    const lvl = (window._cachedUserLevel !== undefined && window._cachedUserLevel !== null) ? Number(window._cachedUserLevel) : 1;
    return (isNaN(lvl) || lvl < 1) ? 1 : lvl;
  }

  // multiplier formula: 1.0 + (level - 1) * 0.5
  function getSellMultiplier() {
    const lvl = getUserLevel();
    return 1 + (Math.max(lvl - 1, 0) * 0.25);
  }

  // Show multiplier in UI (creates element if missing)
  function updateSellMultiplierUI() {
    try {
      let levelEl = document.getElementById('userLevelDisplay');
      if (!levelEl) {
        // if level element doesn't exist yet, create minimal one in header-right
        const hdr = document.querySelector('.header-right') || document.querySelector('.header-actions');
        if (hdr) {
          const d = document.createElement('div');
          d.id = 'userLevelDisplay';
          d.style.fontSize = '0.95rem';
          d.style.color = '#222';
          d.style.marginTop = '4px';
          hdr.insertBefore(d, hdr.firstChild || null);
          levelEl = d;
        } else {
          // can't find place to show it — bail silently
          return;
        }
      }
      // keep the level text as your code sets it; ensure it exists
      const lvlText = getUserLevel();
      levelEl.innerText = `Level: ${lvlText}`;

      // multiplier display element
      let mEl = document.getElementById('sellMultiplierDisplay');
      if (!mEl) {
        mEl = document.createElement('div');
        mEl.id = 'sellMultiplierDisplay';
        mEl.style.fontSize = '0.9rem';
        mEl.style.color = '#444';
        mEl.style.marginTop = '2px';
        levelEl.parentElement.insertBefore(mEl, levelEl.nextSibling);
      }
      const mult = getSellMultiplier();
      mEl.innerText = `Sell Multiplier: ×${mult.toFixed(1)}`;
    } catch (e) {
      console.warn('updateSellMultiplierUI err', e);
    }
  }

  // Attempt to keep UI in sync if your rebirth code calls updateUserLevelUI
  // If updateUserLevelUI exists on window, wrap it so we also refresh the multiplier UI.
  try {
    if (window.updateUserLevelUI && !window.__wrapped_updateUserLevelUI_for_multiplier__) {
      const _orig = window.updateUserLevelUI;
      window.updateUserLevelUI = function(val) {
        try { _orig.call(this, val); } catch(e){ try { _orig(val); } catch(e2){} }
        try { updateSellMultiplierUI(); } catch(e){ console.warn('post-update sell UI failed', e); }
      };
      window.__wrapped_updateUserLevelUI_for_multiplier__ = true;
    } else {
      // if updateUserLevelUI not present or wrapped already, still update UI now
      setTimeout(updateSellMultiplierUI, 120);
    }
  } catch(e){ setTimeout(updateSellMultiplierUI, 120); }

  // --- Patch sellCard to apply multiplier ---
  // The original sellCard in your code was:
  // function sellCard(cardId) { const c = collection[cardId]; if (!c) return showMessage("Card not found!"); balance += c.currentPrice; delete collection[cardId]; saveUser(); updateUI(); showMessage(`Sold card "${c.name}" for $${c.currentPrice}.`); }
  // We'll wrap/replace it safely so other code calling sellCard(cardId) still works.

  function doSell(cardId) {
    // This function implements the new sell with multiplier. It mirrors your previous logic.
    try {
      const c = (collection && collection[cardId]) ? collection[cardId] : ((lockedCards && lockedCards[cardId]) ? lockedCards[cardId] : null);
      if (!c) return showMessage("Card not found!");

      // Prevent selling locked cards if they are explicitly locked in your logic
      if (lockedCards && lockedCards[cardId] && lockedCards[cardId].isLocked) {
        return showMessage("This card is locked and cannot be sold.");
      }

      const basePrice = Number(c.currentPrice || c.basePrice || 0);
      const mult = getSellMultiplier();
      const sellPrice = Math.round(basePrice * mult);

      // Update balance and local collection state
      balance = Number(balance || 0) + sellPrice;
      if (collection && collection[cardId]) delete collection[cardId];
      if (lockedCards && lockedCards[cardId]) delete lockedCards[cardId]; // fallback - usually sell from collection

      // persist and update UI
      saveUser().catch(()=>{}); // best-effort
      updateUI();
      showMessage(`Sold card "${c.name}" for $${sellPrice} (×${mult.toFixed(1)}).`);
    } catch (err) {
      console.error('doSell err', err);
      showMessage('Error selling card. See console.');
    }
  }

  // If a global sellCard existed, wrap it; otherwise define it.
  try {
    if (typeof window.sellCard === 'function' && !window.__sellCard_multiplier_patched__) {
      const orig = window.sellCard;
      window.sellCard = function(cardId, ...rest) {
        // prefer our new behavior
        doSell(cardId);
        // keep backward compatibility: we won't call original to avoid double-processing.
      };
      window.__sellCard_multiplier_patched__ = true;
    } else if (typeof window.sellCard !== 'function') {
      // define sellCard globally as expected by your UI buttons
      window.sellCard = function(cardId) { doSell(cardId); };
      window.__sellCard_multiplier_patched__ = true;
    } else {
      // already patched, still ensure doSell is available
      window.sellCard = function(cardId) { doSell(cardId); };
      window.__sellCard_multiplier_patched__ = true;
    }
  } catch (e) {
    // fallback: create global function anyway
    try { window.sellCard = function(cardId){ doSell(cardId); }; window.__sellCard_multiplier_patched__ = true; } catch(e2){ console.warn('failed to install sellCard patch', e2); }
  }

  // Also patch one-off places where code might call direct balance increment after selling:
  // (This is conservative: many parts call saveUser() and updateUI(), so consistent state is kept.)
  // We expose helper in case you want to compute adjusted sell price elsewhere:
  window.getSellMultiplier = getSellMultiplier;
  window.getSellPriceFor = function(card) {
    const base = Number((card && (card.currentPrice || card.basePrice)) || 0);
    return Math.round(base * getSellMultiplier());
  };

  // Run initial UI update
  setTimeout(updateSellMultiplierUI, 150);

  // Keep multiplier UI refreshed every 3 seconds (in case level updates from DB)
  setInterval(updateSellMultiplierUI, 3000);

  console.log('[rebirth-multiplier] installed: base=1.0, +0.5 per level. Current multiplier:', getSellMultiplier());

})(); // IIFE end
</script>
<!-- ========== SECRET BUTTON + HIDDEN INLINE ADMIN RESTOCK (requires code 555) ========== -->
<style>
  /* Inline admin restock (hidden by default) */
  #adminInlineRestock { display: none; margin: 28px auto; padding: 18px; border-radius: 12px; max-width: 1100px; background: #fff; border: 1px solid #e6e7eb; box-shadow: 0 6px 20px rgba(2,6,23,0.06); font-family: inherit; }
  #adminInlineRestock h3 { margin: 0 0 8px 0; font-size: 1.05rem; }
  #adminInlineRestock .grid { display:flex; flex-wrap:wrap; gap:12px; align-items:flex-end; }
  #adminInlineRestock .field { flex:1 1 200px; min-width:160px; }
  #adminInlineRestock label { display:block; font-size:0.92rem; margin-bottom:6px; color:#374151; }
  #adminInlineRestock input[type="text"], #adminInlineRestock input[type="number"], #adminInlineRestock select, #adminInlineRestock textarea {
    width:100%; padding:8px 10px; border-radius:8px; border:1px solid #d1d5db; box-sizing:border-box; font-size:0.95rem;
  }
  #adminInlineRestock .actions { display:flex; gap:8px; justify-content:flex-end; margin-top:12px; }
  /* Scoped button class — NO color/background/border set here to avoid affecting global buttons */
  #adminInlineRestock .adminInlineBtn { padding:8px 12px; border-radius:8px; cursor:pointer; font-size:0.95rem; }
  #adminInlinePreview { margin-top:10px; padding:10px; background:#fafafa; border:1px dashed #e5e7eb; border-radius:8px; white-space:pre-wrap; font-size:0.92rem; color:#374151; }

  /* Secret toggle button (bottom-left) - avoid color styles on the button itself */
  #secretToggleContainer { position: fixed; left: 14px; bottom: 14px; z-index: 9999; }
  #secretToggleContainer button { padding:10px 12px; border-radius:999px; cursor:pointer; font-size:0.95rem; }
  /* small hint text when revealed (optional) */
  #secretHint { display:none; position:fixed; left:14px; bottom:56px; z-index:9998; background: rgba(255,255,255,0.95); border:1px solid #e5e7eb; padding:6px 10px; border-radius:8px; font-size:0.86rem; color:#374151; }
</style>

<!-- Secret toggle -->
<div id="secretToggleContainer" aria-hidden="false">
  <button id="secretToggleBtn" type="button">Secret</button>
</div>
<div id="secretHint">Enter code to open admin</div>

<!-- Inline admin restock (hidden) -->
<section id="adminInlineRestock" aria-label="Admin restock section (secret)">
  <h3>Admin — Restock / Add Card (Secret)</h3>

  <div style="font-size:0.88rem; color:#6b7280; margin-bottom:10px;">
    This admin panel is hidden from regular users. Use the left-bottom <strong>Secret</strong> button and enter code <strong>555</strong>.
  </div>

  <div class="grid">
    <div class="field">
      <label for="adminInlinePack">Pack</label>
      <select id="adminInlinePack"></select>
    </div>

    <div class="field">
      <label for="adminInlineName">Card name</label>
      <input id="adminInlineName" type="text" placeholder="Exact card name (e.g. Blue Dragon)" />
    </div>

    <div style="width:150px" class="field">
      <label for="adminInlinePrice">Sell price</label>
      <input id="adminInlinePrice" type="number" min="0" step="1" placeholder="3500" />
    </div>

    <div style="width:120px" class="field">
      <label for="adminInlineQty">Quantity</label>
      <input id="adminInlineQty" type="number" min="1" step="1" placeholder="10" />
    </div>

    <div style="width:120px" class="field">
      <label for="adminInlineChance">Chance (0–1)</label>
      <input id="adminInlineChance" type="number" min="0" max="1" step="0.01" placeholder="0.05" />
    </div>

    <div style="width:220px" class="field">
      <label style="display:flex; gap:8px; align-items:center;">
        <input id="adminInlineCreate" type="checkbox" checked /> <span style="font-size:0.95rem;">Create if missing</span>
      </label>
    </div>
  </div>

  <div id="adminInlinePreview">Preview will appear here after you type values.</div>

  <div class="actions">
    <button class="adminInlineBtn" onclick="adminInlineReset()">Reset</button>
    <button class="adminInlineBtn" onclick="adminInlineClearAll()">Clear</button>
    <button class="adminInlineBtn" onclick="adminInlineSubmit()">Apply</button>
  </div>
</section>

<script>
/* SECRET BUTTON + HIDDEN ADMIN INLINE RESTOCK
   - Secret button bottom-left prompts for code (555).
   - On correct code, reveals the admin inline restock section and focuses the card name.
   - No global button color changes; uses scoped classes only.
*/

/* helpers (same as before) */
function _safePackKeys() {
  try { if (typeof cardPools === 'object' && cardPools) return Object.keys(cardPools); } catch(e) {}
  return ['common','rare','epic','legendary','mythical','divine','pristimatic','secret'];
}
function _slugify(name) { return String(name || '').toLowerCase().replace(/\s+/g,'_').replace(/[^a-z0-9_\-]/g,'').slice(0,120); }
function _nowISO(){ return (new Date()).toISOString(); }
function _msg(m){ if (typeof showMessage==='function') return showMessage(m); alert(String(m)); }

/* UI functions (reused/adapted) */
function adminInlinePopulatePacks() {
  const sel = document.getElementById('adminInlinePack');
  sel.innerHTML = '';
  _safePackKeys().forEach(p => {
    const opt = document.createElement('option'); opt.value = p; opt.textContent = p; sel.appendChild(opt);
  });
}
function adminInlineReset() {
  document.getElementById('adminInlineName').value = '';
  document.getElementById('adminInlinePrice').value = '';
  document.getElementById('adminInlineQty').value = '';
  document.getElementById('adminInlineChance').value = '0.05';
  document.getElementById('adminInlineCreate').checked = true;
  adminInlineUpdatePreview();
}
function adminInlineClearAll() {
  // clears quantities of the entered card only (if exists)
  const name = (document.getElementById('adminInlineName').value || '').trim();
  if (!name) return _msg('Enter the card name to clear its quantity.');
  const key = _slugify(name);
  try {
    if (typeof db !== 'undefined' && db && db.ref) {
      db.ref(`cardQuantities/${key}`).set(0);
    } else {
      localStorage.setItem(`cardQuantity_${key}`, '0');
    }
    // update in-memory if exists
    for (const pk in cardPools) {
      const card = (cardPools[pk] || []).find(c=>String(c.name)===String(name));
      if (card) card.quantity = 0;
    }
    if (typeof updateUI==='function') try{ updateUI(); }catch(e){console.warn(e);}
    adminInlineUpdatePreview();
    _msg(`Cleared quantity of "${name}".`);
  } catch (e) { console.error(e); _msg('Failed to clear quantity.'); }
}

/* preview update */
function adminInlineUpdatePreview() {
  const pack = document.getElementById('adminInlinePack').value || '(pack)';
  const name = (document.getElementById('adminInlineName').value || '').trim() || '(card)';
  const price = document.getElementById('adminInlinePrice').value || '0';
  const qty = document.getElementById('adminInlineQty').value || '0';
  const chance = document.getElementById('adminInlineChance').value || '0.05';
  const create = document.getElementById('adminInlineCreate').checked ? 'Yes' : 'No';
  document.getElementById('adminInlinePreview').innerText =
    `Pack: ${pack}\nCard: ${name}\nPrice: ${price}\nQty to add: ${qty}\nChance: ${chance}\nCreate if missing: ${create}`;
}

/* submit logic (same behavior) */
async function adminInlineSubmit() {
  const pack = document.getElementById('adminInlinePack').value;
  const name = (document.getElementById('adminInlineName').value || '').trim();
  const price = Number(document.getElementById('adminInlinePrice').value || 0);
  const qty = parseInt(document.getElementById('adminInlineQty').value || '0', 10);
  const chance = parseFloat(document.getElementById('adminInlineChance').value || '0.05');
  const createIfMissing = document.getElementById('adminInlineCreate').checked;

  if (!pack || !name) return _msg('Please choose a pack and enter card name.');
  if (!qty || qty <= 0) return _msg('Quantity must be a positive integer.');

  try {
    if (typeof cardPools !== 'object' || !cardPools) window.cardPools = {};
    if (!cardPools[pack]) cardPools[pack] = [];

    let card = cardPools[pack].find(c => String(c.name) === String(name));
    if (card) {
      card.price = price;
      card.quantity = (card.quantity || 0) + qty;
      card.chance = (typeof card.chance === 'number' && card.chance > 0) ? card.chance : (isNaN(chance) ? 0.05 : chance);
    } else {
      if (!createIfMissing) return _msg('Card not found in pack and create-if-missing is unchecked.');
      card = { name, price, quantity: qty, chance: (isNaN(chance) ? 0.05 : chance) };
      cardPools[pack].push(card);
    }

    // Persist change: prefer saveCardQuantities(), else db.ref single key, else localStorage
    const key = _slugify(name);
    if (typeof saveCardQuantities === 'function') {
      try { await saveCardQuantities(); } catch(e) {
        console.warn('saveCardQuantities failed', e);
        if (typeof db !== 'undefined' && db && db.ref) await db.ref(`cardQuantities/${key}`).set(card.quantity);
        else localStorage.setItem(`cardQuantity_${key}`, String(card.quantity));
      }
    } else if (typeof db !== 'undefined' && db && db.ref) {
      try { await db.ref(`cardQuantities/${key}`).set(card.quantity); } catch(e){ console.warn(e); localStorage.setItem(`cardQuantity_${key}`, String(card.quantity)); }
    } else {
      localStorage.setItem(`cardQuantity_${key}`, String(card.quantity));
    }

    if (typeof updateUI === 'function') try{ updateUI(); }catch(e){console.warn(e);}
    if (typeof updatePackChances === 'function') try{ updatePackChances(); }catch(e){console.warn(e);}

    // log admin action (firebase or local)
    const action = { action:'restock', by: (typeof currentUser!=='undefined' && currentUser) ? currentUser : (typeof auth!=='undefined' && auth && auth.currentUser && auth.currentUser.displayName) ? auth.currentUser.displayName : 'secret-admin', pack, name, price, qty, chance, at: _nowISO() };
    if (typeof db !== 'undefined' && db && db.ref) {
      try { await db.ref('adminActions').push(action); } catch(e){ console.warn('admin log failed', e); const arr=JSON.parse(localStorage.getItem('adminActionsLog')||'[]'); arr.push(action); localStorage.setItem('adminActionsLog', JSON.stringify(arr)); }
    } else { const arr=JSON.parse(localStorage.getItem('adminActionsLog')||'[]'); arr.push(action); localStorage.setItem('adminActionsLog', JSON.stringify(arr)); }

    _msg(`Restocked "${name}" in "${pack}" (+${qty}) — price:${price}, chance:${chance}`);
    adminInlineUpdatePreview();
  } catch (err) {
    console.error('adminInlineSubmit error', err);
    _msg('Restock failed — check console.');
  }
}

/* attach listeners for preview */
['adminInlinePack','adminInlineName','adminInlinePrice','adminInlineQty','adminInlineChance','adminInlineCreate'].forEach(id=>{
  document.addEventListener('input', (e)=>{ if(e.target && e.target.id===id) adminInlineUpdatePreview(); });
});

/* SECRET BUTTON HANDLERS */
const secretBtn = document.getElementById('secretToggleBtn');
const secretHint = document.getElementById('secretHint');
const adminSection = document.getElementById('adminInlineRestock');

let secretOpen = false;

function showSecretHint() {
  secretHint.style.display = 'block';
  setTimeout(()=>{ secretHint.style.display = 'none'; }, 2200);
}

secretBtn.addEventListener('mouseover', showSecretHint);
secretBtn.addEventListener('focus', showSecretHint);

secretBtn.addEventListener('click', function(){
  const code = prompt('Enter secret code:');
  if (code === null) return;
  if (String(code).trim() === '555') {
    if (!secretOpen) {
      // reveal admin section
      adminSection.style.display = 'block';
      adminInlinePopulatePacks(); // populate now to keep up-to-date
      adminInlineReset();
      document.getElementById('adminInlineName').focus();
      secretOpen = true;
    } else {
      // already open -> hide
      adminSection.style.display = 'none';
      secretOpen = false;
    }
  } else {
    _msg('Incorrect code.');
  }
});

/* Expose API in case you want to open programmatically (requires correct code) */
window.openSecretAdmin = function(code){
  if (String(code) === '555') {
    if (!secretOpen) {
      adminSection.style.display = 'block';
      adminInlinePopulatePacks();
      adminInlineReset();
      secretOpen = true;
    }
    return true;
  }
  return false;
};
</script>
<!-- ========== END SECRET BUTTON + HIDDEN INLINE ADMIN RESTOCK ========== -->

<script>
/* ===== Fishing: 5-minute active window + 25-minute cooldown (Firebase-backed) =====
   - Active window length: WINDOW_DURATION_MS (5 minutes)
   - Cooldown after window: COOLDOWN_MS (25 minutes)
   - When a user fishes, they WAIT_FISH_MS (1 minute) before the card is granted.
   - Stores meta at: meta/fishing = { activeStart, activeUntil, nextStart, lastClaimed }
   - Safe transaction used to claim a new window.
   - UI anchored under element with id="refill-count-small".
*/

(function installFiveMinFishingOneMinWait(){
  if (window.__fiveMinFishingOneMinWaitInstalled) return;
  window.__fiveMinFishingOneMinWaitInstalled = true;

  // ------- CONFIG -------
  const WINDOW_DURATION_MS = 5 * 60 * 1000;    // 5 minutes active window
  const COOLDOWN_MS      = 25 * 60 * 1000;    // 25 minutes cooldown after the window
  const UI_REFRESH_MS    = 1000;
  const CLAIM_INTERVAL_MS = 5000;             // try to claim when due
  const WAIT_FISH_MS     = 60 * 1000;         // <-- user requested: 1 minute wait before receiving card

  // rewards (same as yours)
  const RAW_REWARDS = [
    { name: 'KARKER KAR KUR KUR', price: 30000000, percent: 5 },
    { name: 'ESOK SEKOLA',        price: 6000000,  percent: 24 },
    { name: 'NOOOO MY EXAMINE',   price: 4500000,  percent: 10 },
    { name: 'YEEEES MY EXAMINE',  price: 7000000,  percent: 8 },
    { name: 'HALLOWEEN MEOWL',    price: 60000000, percent: 3 },
    { name: 'POT HOTSPOT',        price: 8000000,  percent: 6 },
    { name: 'LA SECRET COMBINOSION',             price: 100000000, percent: 1 },
    { name: 'LA CHUCARACHA',      price: 17000000, percent: 3 },
    { name: 'GRAPUSS MEDUSI',     price: 15000000, percent: 5 },
    { name: 'LA VACA',            price: 1000000,  percent: 35 }
  ];

  // ------- state -------
  let serverOffset = 0;
  let fishingInProgress = false; // per-browser indicator for single click flow
  let countdownInterval = null;
  let windowActive = false;
  const META_REF = (db && db.ref) ? db.ref('meta/fishing') : null;
  const TOTAL_CYCLE = WINDOW_DURATION_MS + COOLDOWN_MS;

  // ------- helpers: server time & percent pick -------
  function nowServerMs(){ return Date.now() + (serverOffset || 0); }

  function normalizePercents(list){
    const arr = list.map(i => Object.assign({}, i));
    let total = arr.reduce((s,i)=>s + Number(i.percent||0), 0);
    if (total === 0){
      const eq = 100 / Math.max(1, arr.length);
      arr.forEach(i=> i.percent = eq);
      return arr;
    }
    if (Math.abs(total - 100) > 0.0001){
      console.warn('Fishing rewards percent sum !=100 (was', total, '), normalizing.');
      arr.forEach(i => i.percent = (Number(i.percent||0) / total) * 100);
      let rounded = arr.map(i => Math.round(i.percent * 10) / 10);
      let diff = Math.round((100 - rounded.reduce((s,v)=>s+v,0)) * 10) / 10;
      let idx = 0;
      while (Math.abs(diff) >= 0.1 && idx < 1000){
        rounded[idx % rounded.length] = Math.round((rounded[idx % rounded.length] + Math.sign(diff) * 0.1) * 10) / 10;
        diff = Math.round((100 - rounded.reduce((s,v)=>s+v,0)) * 10) / 10;
        idx++;
      }
      arr.forEach((it, i) => it.percent = rounded[i]);
    } else {
      arr.forEach(i => i.percent = Math.round(Number(i.percent||0) * 10) / 10);
    }
    return arr;
  }

  function pickByPercent(list){
    const arr = normalizePercents(list);
    const r = Math.random() * 100;
    let acc = 0;
    for (const it of arr){
      acc += Number(it.percent || 0);
      if (r <= acc) return it;
    }
    return arr[arr.length-1];
  }

  function formatTimeShort(ms){
    const s = Math.max(0, Math.ceil(ms/1000));
    const mm = Math.floor(s/60), ss = s % 60;
    return `${mm}m ${ss}s`;
  }

  function formatAbsolute(ts){
    try {
      if (!ts) return '—';
      const d = new Date(Number(ts));
      return d.toLocaleString();
    } catch(e){ return '—'; }
  }

  // ------- Styling (green background) -------
  const BG_CLASS = '__fishingBgGreen_underRefill';
  (function injectCss(){
    if (document.getElementById('__fishingCssUnderRefill')) return;
    const s = document.createElement('style'); s.id = '__fishingCssUnderRefill';
    s.innerHTML = `
      body.${BG_CLASS} { background: linear-gradient(180deg,#0f6f2f 0%, #26a64a 100%) !important; transition: background 0.6s ease !important; }
      #__fishingContainerUnderRefill { pointer-events: auto; }
      #__fishingContainerUnderRefill .__fishUI { pointer-events: auto; font-family: Inter, system-ui, Arial; }
      #__fishingContainerUnderRefill .__fishBtn { cursor: pointer; border-radius:8px; padding:6px 8px; border:none; background:#036; color:#fff; font-weight:700; }
      #__fishingContainerUnderRefill .__fishSmall { font-size:12px; color:#fff; opacity:0.95; }
      #__fishingContainerUnderRefill .__fishTitle { font-weight:800; font-size:13px; color:#fff; }
      #__fishingContainerUnderRefill { transition: opacity .25s; }
    `;
    document.head.appendChild(s);
  })();

  // ------- UI anchored under restock timer -------
  function ensureUI(){
    let wrap = document.getElementById('__fishingContainerUnderRefill');
    if (wrap) {
      repositionUnderRefill();
      return wrap;
    }

    wrap = document.createElement('div');
    wrap.id = '__fishingContainerUnderRefill';
    Object.assign(wrap.style, {
      position: 'fixed', left: '8px', top: '56px', zIndex: 99990, pointerEvents: 'auto'
    });

    const ui = document.createElement('div');
    ui.className = '__fishUI';
    Object.assign(ui.style, {
      background:'rgba(3,6,12,0.85)', color:'#fff', padding:'8px 10px', borderRadius:'10px',
      boxShadow:'0 8px 26px rgba(0,0,0,0.35)', minWidth:'220px', display:'flex', flexDirection:'column', gap:'6px'
    });

    const title = document.createElement('div'); title.className='__fishTitle'; title.id='__fishTitle';
    title.innerText = 'Fishing — inactive';

    const nextRow = document.createElement('div'); nextRow.style.display='flex'; nextRow.style.justifyContent='space-between'; nextRow.style.alignItems='center';
    const nextLabel = document.createElement('div'); nextLabel.className='__fishSmall'; nextLabel.innerText = 'Next fishing:';
    const nextVal = document.createElement('div'); nextVal.id='__fishNext'; nextVal.className='__fishSmall'; nextVal.style.fontWeight='800'; nextVal.innerText = '—';
    nextRow.appendChild(nextLabel); nextRow.appendChild(nextVal);

    const statusRow = document.createElement('div'); statusRow.style.display='flex'; statusRow.style.justifyContent='space-between'; statusRow.style.alignItems='center';
    const statusText = document.createElement('div'); statusText.id='__fishStatus'; statusText.className='__fishSmall'; statusText.innerText = 'Waiting...';
    const btn = document.createElement('button'); btn.id='__fishBtn'; btn.className='__fishBtn'; btn.innerText = 'Fish now';
    btn.onclick = function(e){ e.stopPropagation(); startFishingNow(); };
    statusRow.appendChild(statusText); statusRow.appendChild(btn);

    const countdown = document.createElement('div'); countdown.id='__fishCountdown'; countdown.style.fontWeight = '800'; countdown.style.fontSize = '13px'; countdown.style.color='#ffe';

    ui.appendChild(title);
    ui.appendChild(nextRow);
    ui.appendChild(statusRow);
    ui.appendChild(countdown);
    wrap.appendChild(ui);
    document.body.appendChild(wrap);

    repositionUnderRefill();

    // clicking anywhere when active starts fishing (but ignore clicks on inputs/controls)
    document.addEventListener('click', function(e){
      if (!windowActive) return;
      const t = e.target;
      const skip = t.closest && (t.closest('input, textarea, select, button, [contenteditable="true"], .adminMsg, #adminPanel') );
      if (skip) {
        if (!(t.id === '__fishBtn' || t.closest && t.closest('#__fishingContainerUnderRefill'))) return;
      }
      startFishingNow();
    }, { capture: true });

    window.addEventListener('resize', repositionUnderRefill);
    return wrap;
  }

  function repositionUnderRefill(){
    try {
      const refillSpan = document.getElementById('refill-count-small');
      const wrap = document.getElementById('__fishingContainerUnderRefill');
      if (!wrap) return;
      if (refillSpan && refillSpan.parentElement) {
        const rect = refillSpan.parentElement.getBoundingClientRect();
        wrap.style.left = Math.max(4, rect.left) + 'px';
        wrap.style.top = (rect.bottom + 8) + 'px';
      } else {
        wrap.style.left = '8px';
        wrap.style.top = '56px';
      }
    } catch(e){ /* silent */ }
  }

  // ------- UI refresh function -------
  function refreshUI(){
    ensureUI();
    const title = document.getElementById('__fishTitle');
    const nextVal = document.getElementById('__fishNext');
    const statusEl = document.getElementById('__fishStatus');
    const countdownEl = document.getElementById('__fishCountdown');
    const btn = document.getElementById('__fishBtn');

    const serverNow = nowServerMs();

    const activeStart = Number(window._fishingActiveStart || 0);
    const activeUntil = Number(window._fishingActiveUntil || 0);
    const next = Number(window._nextFishingCached || 0);

    const inWindow = activeStart && serverNow >= activeStart && serverNow < activeUntil;
    windowActive = inWindow;

    if (inWindow) {
      document.body.classList.add(BG_CLASS);
      title.innerText = 'Fishing — ACTIVE';
      statusEl.innerText = fishingInProgress ? 'Fishing…' : 'Ready';
      btn.disabled = !!fishingInProgress;
      const leftWindow = Math.max(0, activeUntil - serverNow);
      countdownEl.innerText = 'Window ends in ' + formatTimeShort(leftWindow);
      nextVal.innerText = formatAbsolute(next) + ' (' + formatTimeShort(next - serverNow) + ')';
    } else {
      document.body.classList.remove(BG_CLASS);
      title.innerText = 'Fishing — inactive';
      btn.disabled = true;
      if (next && next > serverNow) {
        nextVal.innerText = formatAbsolute(next) + ' (' + formatTimeShort(next - serverNow) + ')';
        statusEl.innerText = 'Next in ' + formatTimeShort(next - serverNow);
        countdownEl.innerText = '';
      } else {
        nextVal.innerText = '—';
        statusEl.innerText = 'Waiting for schedule...';
        countdownEl.innerText = '';
      }
    }
  }

  // ------- local countdown helper -------
  function startLocalCountdown(durationMs, onTick, onDone){
    const end = Date.now() + durationMs;
    onTick && onTick(Math.max(0, end - Date.now()));
    if (countdownInterval) clearInterval(countdownInterval);
    countdownInterval = setInterval(() => {
      const left = Math.max(0, end - Date.now());
      onTick && onTick(left);
      if (left <= 0) {
        clearInterval(countdownInterval);
        countdownInterval = null;
        onDone && onDone();
      }
    }, 250);
  }

  // ------- fishing flow -------
  async function startFishingNow(){
    if (!currentUser) return showMessage('You must be logged in to fish.');
    if (!windowActive) return showMessage('Fishing is not active currently.');
    if (fishingInProgress) return showMessage('You are already fishing.');

    fishingInProgress = true;
    refreshUI();

    const statusEl = document.getElementById('__fishStatus');
    const countdownEl = document.getElementById('__fishCountdown');
    statusEl.innerText = 'Fishing...';

    // WAIT_FISH_MS before granting (1 minute as requested)
    startLocalCountdown(WAIT_FISH_MS, (left) => {
      countdownEl.innerText = 'Catching: ' + formatTimeShort(left);
    }, async () => {
      try {
        const reward = pickByPercent(RAW_REWARDS);
        if (!reward) throw new Error('No reward');

        const grantName = 'radioactive ' + reward.name;
        const grantPrice = Math.round(Number(reward.price || 0) * 1.5);

        const newCardId = (typeof generateCardId === 'function') ? generateCardId() : (Date.now().toString() + Math.random().toString().slice(2,8));
        const cardObj = {
          id: newCardId,
          name: grantName,
          basePrice: grantPrice,
          currentPrice: grantPrice,
          isLocked: false,
          lockTime: 0,
          lastMutationTime: Date.now(),
          mutations: [],
          protectAvailableAt: Date.now() + (5 * 60 * 1000),
          protectedUntil: 0,
          createdFrom: 'fishing',
          grantedAt: Date.now()
        };

        const updates = {};
        updates[`users/${currentUser}/collection/${newCardId}`] = cardObj;
        updates[`logs/fishing/${currentUser}_${Date.now()}`] = { user: currentUser, reward: reward.name, percent: Number(reward.percent||0), grantedName: grantName, price: grantPrice, at: Date.now() };
        await db.ref().update(updates);

        if (!collection || typeof collection !== 'object') collection = {};
        collection[newCardId] = cardObj;
        typeof updateUI === 'function' && updateUI();
        if (typeof attachButtonsToLuckyCards === 'function') try { attachButtonsToLuckyCards(); } catch(e){}
        showMessage(`Fishing success! You caught "${grantName}".`);
      } catch (err) {
        console.error('Fishing grant failed', err);
        showMessage('Fishing failed — please try again.');
        try { await loadUserData(); } catch(e){}
      } finally {
        fishingInProgress = false;
        refreshUI();
      }
    });
  }

  // ------- schedule management: ensure & claim functions -------
  async function ensureNextFishing(){
    if (!META_REF) return;
    try {
      const offSnap = await db.ref('.info/serverTimeOffset').once('value');
      serverOffset = offSnap.val() || serverOffset;
      const serverNow = nowServerMs();

      const snap = await META_REF.once('value');
      if (!snap.exists() || typeof snap.val() !== 'object' || !snap.val().nextStart) {
        // set nextStart aligned to next TOTAL_CYCLE boundary (predictable schedule)
        const nextTop = serverNow - (serverNow % TOTAL_CYCLE) + TOTAL_CYCLE;
        await META_REF.set({ nextStart: nextTop, activeStart: 0, activeUntil: 0, lastClaimed: 0 });
      } else {
        // update local cache from value
        const v = snap.val();
        // defensive fix: if nextStart is weirdly far in the future (existing DB), expose helper to reset (see resetFishingSchedule below)
        window._nextFishingCached = Number(v.nextStart || 0);
        window._fishingActiveStart = Number(v.activeStart || 0);
        window._fishingActiveUntil = Number(v.activeUntil || 0);
      }
    } catch(e){ console.warn('ensureNextFishing err', e); }
  }

  // tryClaimNextFishing: transactionally start a window when nextStart <= serverNow
  async function tryClaimNextFishing(){
    if (!META_REF) return;
    try {
      const offSnap = await db.ref('.info/serverTimeOffset').once('value');
      serverOffset = offSnap.val() || serverOffset;
      const serverNow = nowServerMs();

      await META_REF.transaction(current => {
        if (!current || typeof current !== 'object') return;
        const nextStart = Number(current.nextStart || 0);
        const activeUntil = Number(current.activeUntil || 0);
        // If a window is currently active (activeUntil > now), do nothing
        if (activeUntil && activeUntil > serverNow) return;
        // If nextStart is in the future, nothing to do
        if (nextStart && nextStart > serverNow) return;
        // Otherwise claim the new window: set activeStart/activeUntil and nextStart for the future
        const activeStart = serverNow;
        const activeUntilNew = serverNow + WINDOW_DURATION_MS;
        const nextStartNew = activeUntilNew + COOLDOWN_MS;
        return Object.assign({}, current, {
          activeStart: activeStart,
          activeUntil: activeUntilNew,
          nextStart: nextStartNew,
          lastClaimed: serverNow
        });
      }, (err, committed, snap) => {
        if (err) { console.warn('claim nextFishing tx err', err); return; }
        // result is applied by the listener below; nothing else to do here
      }, false);
    } catch(e){ console.warn('tryClaimNextFishing err', e); }
  }

  // Listen to meta/fishing and keep local cache in window.* variables
  if (META_REF) {
    try {
      META_REF.on('value', snap => {
        const v = snap.exists() ? snap.val() : {};
        window._nextFishingCached = Number((v && v.nextStart) || 0);
        window._fishingActiveStart = Number((v && v.activeStart) || 0);
        window._fishingActiveUntil = Number((v && v.activeUntil) || 0);
      });
    } catch(e){ console.warn('attach nextFishing listener failed', e); }
  }

  // Keep serverTimeOffset live if possible
  if (db && db.ref) {
    try { db.ref('.info/serverTimeOffset').on('value', s=> { serverOffset = s.val() || serverOffset; }); } catch(e){ /* ignore */ }
  }

  // Exposed helpers
  window.getFishingState = function(){ return { windowActive, fishingInProgress, serverOffset, nextFishing: window._nextFishingCached || null, activeStart: window._fishingActiveStart || null, activeUntil: window._fishingActiveUntil || null }; };
  window._getFishingRewardsPercent = function(){ return normalizePercents(RAW_REWARDS); };

  // Admin helper: force an active window now (useful for testing)
  window.forceAdvanceFishing = async function(){
    if (!META_REF) return false;
    const offSnap = await db.ref('.info/serverTimeOffset').once('value');
    const off = offSnap.val() || 0;
    const serverNow = Date.now() + off;
    const activeStart = serverNow;
    const activeUntil = serverNow + WINDOW_DURATION_MS;
    const nextStart = activeUntil + COOLDOWN_MS;
    await META_REF.set({ activeStart, activeUntil, nextStart, lastClaimed: serverNow });
    return true;
  };

  // Admin helper: reset schedule to a sane nextStart (useful if old DB had weird values)
  window.resetFishingSchedule = async function(offsetMsFromNow){
    if (!META_REF) return false;
    const offSnap = await db.ref('.info/serverTimeOffset').once('value');
    const off = offSnap.val() || 0;
    const serverNow = Date.now() + off;
    const nextStart = serverNow + (typeof offsetMsFromNow === 'number' ? offsetMsFromNow : COOLDOWN_MS);
    await META_REF.set({ nextStart, activeStart: 0, activeUntil: 0, lastClaimed: 0 });
    return true;
  };

  // ensure & claim on boot
  (async function boot(){
    await ensureNextFishing().catch(()=>{});
    // periodically try to claim (transaction) if the schedule allows
    setInterval(() => { tryClaimNextFishing().catch(()=>{}); }, CLAIM_INTERVAL_MS);
    // UI refresh loop
    refreshUI();
    setInterval(() => { try { refreshUI(); } catch(e) { console.warn(e); } }, UI_REFRESH_MS);
  })();

  // ensure UI exists now
  setTimeout(() => { ensureUI(); refreshUI(); }, 80);

  console.log('Fishing (5min active + 25min cooldown, 1min fish wait) installed.');
})();
</script>

  </body>
  </html>
