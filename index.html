<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Pack Opening Game with Mutations</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="apple-touch-icon" href="foot.jpeg">
<meta name="apple-mobile-web-app-title" content="YourAppName">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<link rel="apple-touch-icon" sizes="180x180" href="foot.jpeg">
<link rel="apple-touch-icon" sizes="152x152" href="foot.jpeg">
<link rel="apple-touch-icon" sizes="120x120" href="foot.jpeg">

<style>
  body {
    font-family: 'Inter', sans-serif;
    text-align: center;
    background: #e6f0ff;
    min-height: 100vh;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    padding: 1rem;
    color: #333;
  }
  .login-box, .game-box, #messageBox, #cardDetailsBox, #sendModal, #stealModal {
    margin: 20px auto;
    padding: 20px;
    border-radius: 12px;
    background: white;
    max-width: 480px;
    width: 100%;
    box-shadow: 0 4px 10px rgba(0,0,0,0.2);
  }
  .card-container {
    display: grid;
    gap: 1rem;
    grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
    justify-content: center;
    margin-top: 20px;
  }
  .card {
    padding: 15px;
    width: 100%;
    min-height: 250px;
    border-radius: 12px;
    text-align: center;
    border: 3px solid;
    box-sizing: border-box;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    transition: transform 0.2s ease, box-shadow 0.2s ease;
    cursor: pointer;
    position: relative;
    overflow: hidden;
  }
  .card:hover {
    transform: scale(1.05);
    box-shadow: 0 8px 15px rgba(0,0,0,0.3);
  }
  .mutation-label { position: absolute; top: 5px; left: 5px; background: rgba(0,0,0,0.5); color: white; padding: 2px 6px; border-radius: 8px; font-size: 0.75rem; }
  .quantity-label { position: absolute; top: 5px; right: 5px; background: rgba(255,255,255,0.95); color: #111; padding: 4px 8px; border-radius: 10px; font-size: 0.75rem; font-weight: 600; box-shadow: 0 2px 6px rgba(0,0,0,0.12); }
  .mutation-list { margin-top: 10px; text-align: left; width: 100%; }
  .mutation-list h4 { margin: 0; font-size: 0.9rem; color: #444; }
  .mutation-list ul { list-style: none; padding: 0; margin: 5px 0 0; }
  .mutation-list li { font-size: 0.8rem; margin-bottom: 2px; }
  .common-card { background: linear-gradient(#ddd, #bbb); border-color: #666; color: #444; }
  .rare-card { background: linear-gradient(#a0d4ff, #66aaff); border-color: #004488; color: white; font-weight: bold; }
  .epic-card { background: linear-gradient(to bottom right, #a020f0, #800080); border-color: #663399; color: #eee; font-weight: bold; }
  .legendary-card { background: linear-gradient(to bottom right, #ffcc00, #b8860b); border-color: #d4af37; color: #333; font-weight: bold; }
  .divine-card { background: linear-gradient(to bottom right, #e0e0ff, #c0c0d4); border-color: #9999ff; color: #1a1a33; font-weight: bold; }
  .pristimatic-card { background: conic-gradient(red, orange, yellow, green, blue, indigo, violet); border-color: #000; color: white; font-weight: bold; text-shadow: 1px 1px 2px black; }

  .mythical-card {
    background: linear-gradient(135deg, #fff7d6 0%, #ffefb5 20%, #ffd54b 50%, #f2c200 70%, #ffd94d 100%);
    border-color: #ffd700;
    color: #2b1f00;
    font-weight: 800;
    position: relative;
    overflow: hidden;
  }
  .mythical-card::after {
    content: "";
    position: absolute;
    top: -50%;
    left: -50%;
    width: 200%;
    height: 200%;
    background: linear-gradient(120deg, rgba(255,255,255,0.0) 0%, rgba(255,255,255,0.45) 50%, rgba(255,255,255,0.0) 100%);
    transform: rotate(25deg);
    animation: shimmer 3.5s linear infinite;
    pointer-events: none;
  }
  @keyframes shimmer { 0% { transform: translateX(-60%) rotate(25deg);} 100% { transform: translateX(60%) rotate(25deg);} }

  .btn { padding: 12px 24px; margin: 8px; border: none; background: #444; color: white; border-radius: 8px; cursor: pointer; font-size: 16px; transition: background 0.2s ease, transform 0.2s ease; }
  .btn:hover { background: #666; transform: translateY(-2px); }
  .btn-blue { background: #0077ff; }
  .btn-blue:hover { background: #0055aa; }
  .btn-purple { background: #800080; }
  .btn-purple:hover { background: #6a0dad; }
  .btn-gold { background: #d4af37; }
  .btn-gold:hover { background: #b8860b; }
  .btn-divine { background: #9999ff; }
  .btn-divine:hover { background: #7a7aff; }
  .btn-pristimatic { background: #e66465; }
  .btn-pristimatic:hover { background: #9198e5; }
  .btn-small { padding: 8px 16px; font-size: 14px; margin: 4px; }
  .locked-card { box-shadow: 0 0 10px 3px #ff0000; }
  .card-buttons { display: flex; flex-direction: column; gap: 5px; margin-top: 10px; width: 100%; }
  #messageBox, #cardDetailsBox, #sendModal, #stealModal { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); z-index: 1000; display: none; }
  #cardDetailsBox .card { cursor: default; transform: none; box-shadow: none; }
  .user-select-buttons { display: flex; justify-content: center; gap: 10px; margin-bottom: 20px; }
  .header-actions { display: flex; justify-content: space-between; align-items: center; width: 100%; max-width: 480px; }
  .header-right { display:flex; flex-direction:column; gap:6px; align-items:flex-end; }
  #nextDistribution { font-size: 0.9rem; color: #333; margin-top: 6px; opacity: 0.9; }
  @media (max-width: 600px) { .card-container { grid-template-columns: 1fr; } .game-box, .login-box { padding: 10px; } .btn { padding: 10px 20px; font-size: 14px; } }
  #stealModal .question { font-size: 1.2rem; margin-bottom: 12px; }
  #stealModal .small { font-size: 0.85rem; color: #666; margin-top:8px; }
</style>
</head>

<body>

<div class="login-box" id="loginBox">
  <h2>Login</h2>
  <input id="username" placeholder="Username" style="padding:10px; border-radius:8px; border:1px solid #ccc; width:80%;"><br><br>
  <input id="password" type="password" placeholder="Password" style="padding:10px; border-radius:8px; border:1px solid #ccc; width:80%;"><br><br>
  <label style="display:flex; align-items:center; justify-content:center; margin:10px 0;">
    <input type="checkbox" id="keepSignedIn" style="margin-right:5px;"> Keep me signed in
  </label>
  <button class="btn" onclick="login()">Login</button>
  <p id="loginStatus"></p>
</div>

<div class="game-box" id="gameBox" style="display:none;">
  <div class="header-actions">
    <div style="text-align:left;">
      <h2>Welcome <span id="userName"></span></h2>
      <div id="nextDistribution">Next distribution in: --</div>
    </div>
    <div class="header-right">
      <button class="btn btn-small" onclick="logout()">Logout</button>
      <button class="btn btn-small" onclick="refillStocksPrompt()">Refill Stocks</button>
    </div>
  </div>

  <p>Balance: $<span id="balance">0</span></p>

  <div class="user-select-buttons">
    <button class="btn btn-blue" onclick="showUserCollection('zezo')">Zezo</button>
    <button class="btn btn-blue" onclick="showUserCollection('lilly')">lilly</button>
    <button class="btn btn-blue" onclick="showUserCollection('asser')">Asser</button>
    <button class="btn btn-purple" onclick="showMyCollection()">My Base</button>
  </div>

  <div style="display:flex; flex-wrap:wrap; justify-content:center; margin-bottom:20px;">
    <button id="buyCommonBtn" class="btn" onclick="openPack('common')">Buy Common Pack (100%) ($100)</button>
    <button id="buyRareBtn" class="btn btn-blue" onclick="openPack('rare')">Buy Rare Pack (100%) ($250)</button>
    <button id="buyEpicBtn" class="btn btn-purple" onclick="openPack('epic')">Buy Epic Pack (100%) ($350)</button>
    <button id="buyLegendaryBtn" class="btn btn-gold" onclick="openPack('legendary')">Buy Legendary Pack (100%) ($1500)</button>
    <button id="buyMythicalBtn" class="btn btn-gold" onclick="openPack('mythical')">Buy Mythical Pack (??%) ($3000)</button>
    <button id="buyDivineBtn" class="btn btn-divine" onclick="openPack('divine')">Buy Divine Pack (100%) ($5000)</button>
    <button id="buyPristimaticBtn" class="btn btn-pristimatic" onclick="openPack('pristimatic')">Buy Pristimatic Pack (100%) ($7500)</button>
  </div>

  <div id="openedCard"></div>

  <h3>Your Collection</h3>
  <div id="collection" class="card-container"></div>

  <h3><span id="otherUserHeader"></span>'s Collection</h3>
  <div id="otherUserCollection" class="card-container" style="display:none;"></div>
</div>

<div id="messageBox"><p id="messageText"></p><button class="btn" onclick="closeMessage()">OK</button></div>

<div id="cardDetailsBox"><div id="cardDetailsContent"></div><button class="btn" onclick="closeCardDetails()">Close</button></div>

<div id="sendModal">
  <h3>Send Card</h3>
  <p>Send "<strong id="sendCardName"></strong>" to:</p>
  <div style="display:flex; justify-content:center; gap:10px; margin-top:8px;">
    <button class="btn btn-blue" onclick="sendCardToRecipient(currentSendCardId,'asser')">Asser</button>
    <button class="btn btn-blue" onclick="sendCardToRecipient(currentSendCardId,'lilly')">Lilly</button>
    <button class="btn btn-blue" onclick="sendCardToRecipient(currentSendCardId,'zezo')">Zezo</button>
  </div>
  <div style="margin-top:12px;"><button class="btn" onclick="closeSendModal()">Cancel</button></div>
</div>

<div id="stealModal">
  <h3 id="stealModalTitle">Steal Attempt</h3>
  <div class="question" id="stealQuestion">Question will appear here</div>
  <input id="stealAnswerInput" placeholder="Enter answer" style="padding:10px; border-radius:8px; border:1px solid #ccc; width:80%;"><br><br>
  <div style="display:flex; justify-content:center; gap:10px;">
    <button class="btn btn-blue" id="submitStealAnswerBtn" onclick="submitStealAnswer()">Submit</button>
    <button class="btn" onclick="closeStealModal()">Cancel</button>
  </div>
  <div class="small" id="stealModalHint"></div>
</div>

<div id="welcome-container" style="position:fixed; top:0; left:0; width:100%; height:100%; display:flex; align-items:center; justify-content:center; background: rgba(0,0,0,0.7); z-index:9999;">
  <button id="welcome-btn" style="font-size:24px; padding:20px 40px; border:none; border-radius:12px; background:#6a0dad; color:white; cursor:pointer; box-shadow:0 4px 12px rgba(0,0,0,0.3);">Welcome</button>
</div>

<!-- Firebase compat libs -->
<script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-database-compat.js"></script>

<script>
/* --------------------
   Firebase + Game Data
   -------------------- */
const firebaseConfig = {
  apiKey: "AIzaSyDclp6rqCZRVreOzTcxv840mXcl6nDKAv8",
  authDomain: "pack-f76c3.firebaseapp.com",
  databaseURL: "https://pack-f76c3-default-rtdb.firebaseio.com/",
  projectId: "pack-f76c3",
  storageBucket: "pack-f76c3.firebasestorage.app",
  messagingSenderId: "694325056042",
  appId: "1:694325056042:web:aae383919a2ce159892953",
  measurementId: "G-07WXQ7YQ4M"
};
firebase.initializeApp(firebaseConfig);
const db = firebase.database();

// --- Helpers ---
function toKey(name) { return String(name).replace(/[.#$\[\]\/]/g, '_'); }
function generateCardId() { return Date.now().toString() + Math.random().toString().substr(2,6); }

/* --------------------
   Game data
   -------------------- */
const accounts = { zezo: "000", asser: "230", lilly: "246", layan: "123" };

const MUTATION_TIERS = { common: {chance:0.5}, uncommon:{chance:0.24}, rare:{chance:0.15}, veryHard:{chance:0.08}, ultra:{chance:0.03} };
const MUTATIONS = { plasma:{priceIncrease:400,tier:'uncommon'}, bloom:{priceIncrease:300,tier:'common'}, choc:{priceIncrease:350,tier:'common'}, shocked:{priceIncrease:450,tier:'rare'}, rainbow:{priceIncrease:250,tier:'uncommon'}, burnt:{priceIncrease:300,tier:'uncommon'}, chilled:{priceIncrease:450,tier:'rare'}, frozen:{priceIncrease:150,tier:'common'}, brainrot:{priceIncrease:550,tier:'veryHard'}, zezoplot:{priceIncrease:650,tier:'veryHard'}, aurora:{priceIncrease:1000,tier:'ultra'}, EGYPT:{priceIncrease:3000,tier:'ultra'} };

let cardPools = {
  common: [
    { name: "asser", quantity: 50, chance: 0.25, price: 110 },
    { name: "asser eat", quantity: 50, chance: 0.15, price: 120 },
    { name: "asser angry", quantity: 50, chance: 0.15, price: 130 },
    { name: "asser cry", quantity: 50, chance: 0.10, price: 150 },
    { name: "asser sad", quantity: 50, chance: 0.10, price: 140 },
    { name: "asser happy", quantity: 50, chance: 0.15, price: 130 },
    { name: "asser sleep", quantity: 50, chance: 0.10, price: 130 }
  ],
  rare: [
    { name: "Blue Asser", quantity: 40, chance: 0.30, price: 260 },
    { name: "Asser Dragon", quantity: 40, chance: 0.25, price: 280 },
    { name: "Asser Galaxy", quantity: 35, chance: 0.20, price: 300 },
    { name: "Asser Legend", quantity: 10, chance: 0.15, price: 350 },
    { name: "Asser Mythic", quantity: 15, chance: 0.10, price: 400 }
  ],
  epic: [
    { name: "lilly eat", quantity: 50, chance: 0.15, price: 360 },
    { name: "lilly angry", quantity: 50, chance: 0.15, price: 365 },
    { name: "lilly sad", quantity: 50, chance: 0.10, price: 360 },
    { name: "lilly happy", quantity: 50, chance: 0.15, price: 380 },
    { name: "lilly sleep", quantity: 50, chance: 0.10, price: 370 },
    { name: "lilly", quantity: 50, chance: 0.25, price: 355 },
    { name: "Lilly Bomba", quantity: 10, chance: 0.10, price: 600 }
  ],
  legendary: [
    { name: "Lilly laugh", quantity: 10, chance: 0.40, price: 1550 },
    { name: "Lilly Queen", quantity: 10, chance: 0.40, price: 1550 },
    { name: "Lilly Dragon", quantity: 7, chance: 0.10, price: 1700 },
    { name: "Lilly Hero", quantity: 4, chance: 0.10, price: 1500 }
  ],
  mythical: [
    { name: "lilly PS5", quantity: 7, chance: 0.25, price: 3500 },
    { name: "asser bomba", quantity: 7, chance: 0.25, price: 4000 },
    { name: "asser gamer", quantity: 7, chance: 0.25, price: 4500 },
    { name: "PS5 CONTROLLER", quantity: 5, chance: 0.15, price: 5000 },
    { name: "asser farted", quantity: 5, chance: 0.10, price: 5000 }
  ],
  divine: [
    { name: "Zezo laugh", quantity: 15, chance: 0.10, price: 5600 },
    { name: "Zezo sad", quantity: 15, chance: 0.10, price: 5650 },
    { name: "Zezo angry", quantity: 10, chance: 0.10, price: 5800 },
    { name: "Zezo ps5", quantity: 10, chance: 0.20, price: 5700 },
    { name: "Zezo happy", quantity: 15, chance: 0.10, price: 5600 },
    { name: "Zezo smile", quantity: 5, chance: 0.10, price: 5620 },
    { name: "Zezo roblox", quantity: 5, chance: 0.10, price: 5750 },
    { name: "Zezo fart", quantity: 6, chance: 0.05, price: 6000 },
    { name: "normal zezo full", quantity: 3, chance: 0.15, price: 5850 }
  ],
  pristimatic: [
    { name: "Zezo Prismatic", quantity: 2, chance: 0.25, price: 7500 },
    { name: "Zezo Rainbow", quantity: 2, chance: 0.25, price: 7800 },
    { name: "Asser colotinni fasatennee", quantity: 2, chance: 0.20, price: 8000 },
    { name: "zezo big bomba fart", quantity: 2, chance: 0.10, price: 9000 },
    { name: "lilly kowaferr", quantity: 2, chance: 0.15, price: 8000 },
    { name: "Zezo SECRET", quantity: 2, chance: 0.05, price: 13500 }
  ]
};

const INITIAL_QUANTITIES = {};
(function captureInitialQuantities() {
  for (const packType in cardPools) {
    cardPools[packType].forEach(card => {
      INITIAL_QUANTITIES[card.name] = card.quantity;
    });
  }
})();

/* --------------------
   State
   -------------------- */
let currentUser = null;
let balance = 0;
let collection = {};
let lockedCards = {};
let currentHourlyMutation = null;
let mutationInterval = null;
let distributionInterval = null;
// changed distribution delay to 5 minutes (was 10 minutes)
let distributionDelayMs = 1000 * 60 * 5; // 5 minutes
let nextDistributionTimestamp = null;
let distributionCountdownInterval = null;

// resend / UI
let currentSendCardId = null;

// steal state
const STEAL_COOLDOWN_MS = 15 * 60 * 1000; // 15 minutes
let activeStealSession = null;
let stealRequestsListenerRef = null;

// realtime refs
let myCollectionRef = null;
let myLockedRef = null;
let myBalanceRef = null;
let otherUserRef = null;
let nextDistributionRef = null;

/* --------------------
   Utility & UI
   -------------------- */
function getCardType(cardName) {
  if (cardPools.common.some(c=>c.name===cardName)) return 'common';
  if (cardPools.rare.some(c=>c.name===cardName)) return 'rare';
  if (cardPools.epic.some(c=>c.name===cardName)) return 'epic';
  if (cardPools.legendary.some(c=>c.name===cardName)) return 'legendary';
  if (cardPools.mythical && cardPools.mythical.some(c=>c.name===cardName)) return 'mythical';
  if (cardPools.divine.some(c=>c.name===cardName)) return 'divine';
  if (cardPools.pristimatic.some(c=>c.name===cardName)) return 'pristimatic';
  return '';
}
function getBaseCardPrice(cardName) {
  const all = [...cardPools.common,...cardPools.rare,...cardPools.epic,...cardPools.legendary,...(cardPools.mythical||[]),...cardPools.divine,...cardPools.pristimatic];
  const c = all.find(x=>x.name===cardName);
  return c?c.price:0;
}
function getCardQuantity(cardName) {
  const all = [...cardPools.common,...cardPools.rare,...cardPools.epic,...cardPools.legendary,...(cardPools.mythical||[]),...cardPools.divine,...cardPools.pristimatic];
  const c = all.find(x=>x.name===cardName);
  return c?c.quantity:0;
}

function showMessage(message) {
  document.getElementById('messageText').innerText = message;
  document.getElementById('messageBox').style.display = 'block';
}
function closeMessage() { document.getElementById('messageBox').style.display = 'none'; }

function showCardDetails(cardId) {
  const card = collection[cardId] || lockedCards[cardId];
  if (!card) return;
  const mutationListHtml = card.mutations && card.mutations.length>0 ? `<div class="mutation-list"><h4>Mutations:</h4><ul>${card.mutations.map(m=>`<li>${m.name} (+${m.priceIncrease})</li>`).join('')}</ul></div>` : `<p>This card has no mutations yet.</p>`;
  const qty = getCardQuantity(card.name);
  const cardHtml = `<div class="card ${getCardType(card.name)}-card" data-card-id="${cardId}"><span class="quantity-label">x${qty}</span><h3>${card.name}</h3><p>Base Value: $${getBaseCardPrice(card.name)}</p><p>Current Value: $${card.currentPrice}</p>${mutationListHtml}</div>`;
  document.getElementById('cardDetailsContent').innerHTML = cardHtml;
  document.getElementById('cardDetailsBox').style.display = 'block';
}
function closeCardDetails() { document.getElementById('cardDetailsBox').style.display = 'none'; }

function updateDistributionCountdownUI() {
  const el = document.getElementById('nextDistribution');
  if (!el) return;
  if (!nextDistributionTimestamp) { el.innerText = 'Next distribution in: --'; return; }
  const now = Date.now();
  let diff = nextDistributionTimestamp - now;
  if (diff <= 0) { el.innerText = 'Next distribution: distributing now...'; return; }
  const mins = Math.floor(diff / 60000);
  const secs = Math.floor((diff % 60000) / 1000);
  el.innerText = mins>0 ? `Next distribution in: ${mins}m ${secs}s` : `Next distribution in: ${secs}s`;
}

/* --------------------
   Presence & Steal Requests
   -------------------- */
function setOnlinePresence() {
  if (!currentUser) return;
  const ref = db.ref(`presence/${currentUser}`);
  ref.onDisconnect().remove();
  ref.set(true).catch(()=>{});
}
function clearOnlinePresence() {
  if (!currentUser) return;
  db.ref(`presence/${currentUser}`).remove().catch(()=>{});
}

function listenForStealRequests() {
  if (!currentUser) return;
  if (stealRequestsListenerRef) { stealRequestsListenerRef.off(); stealRequestsListenerRef = null; }
  const requestsRef = db.ref(`stealRequests/${currentUser}`);
  stealRequestsListenerRef = requestsRef;
  requestsRef.on('child_added', async snap => {
    const session = snap.val();
    const sessionId = snap.key;
    if (!session) return;
    let full = session;
    if (!session.question) {
      const central = await db.ref(`stealSessions/${sessionId}`).once('value');
      full = central.val();
    }
    if (!full) {
      requestsRef.child(sessionId).remove().catch(()=>{});
      return;
    }
    showIncomingSteal(sessionId, full);
  });
}
function stopListeningForStealRequests() {
  if (stealRequestsListenerRef) { stealRequestsListenerRef.off(); stealRequestsListenerRef = null; }
}

/* --------------------
   Realtime listeners for instant UI updates
   -------------------- */
function attachMyRealtimeListeners() {
  if (!currentUser) return;
  detachMyRealtimeListeners();

  myCollectionRef = db.ref(`users/${currentUser}/collection`);
  myCollectionRef.on('value', snap => {
    collection = snap.val() || {};
    updateUI();
  });

  myLockedRef = db.ref(`users/${currentUser}/lockedCards`);
  myLockedRef.on('value', snap => {
    lockedCards = snap.val() || {};
    updateUI();
  });

  myBalanceRef = db.ref(`users/${currentUser}/balance`);
  myBalanceRef.on('value', snap => {
    const v = snap.val();
    if (v !== null && v !== undefined) balance = v;
    updateUI();
  });
}
function detachMyRealtimeListeners() {
  try {
    if (myCollectionRef) { myCollectionRef.off(); myCollectionRef = null; }
    if (myLockedRef) { myLockedRef.off(); myLockedRef = null; }
    if (myBalanceRef) { myBalanceRef.off(); myBalanceRef = null; }
  } catch (e) { console.error("detachMyRealtimeListeners err", e); }
}

/* For viewing other users in realtime */
function attachOtherUserListener(targetUser) {
  detachOtherUserListener();
  otherUserRef = db.ref(`users/${targetUser}`);
  otherUserRef.on('value', snap => {
    if (!snap.exists()) {
      document.getElementById("otherUserCollection").innerHTML = `<p>${targetUser} isn't playing this game!</p>`;
      return;
    }
    const d = snap.val();
    const otherCollection = d.collection || {};
    const otherLocked = d.lockedCards || {};
    document.getElementById("otherUserCollection").innerHTML = renderCollection(otherCollection, otherLocked, false, targetUser);
    document.getElementById("otherUserCollection").style.display = 'block';
    document.getElementById("collection").style.display = 'none';
    document.getElementById("otherUserHeader").innerText = targetUser;
    document.getElementById("otherUserHeader").style.display = 'block';
  });
}
function detachOtherUserListener() {
  if (otherUserRef) { otherUserRef.off(); otherUserRef = null; }
  document.getElementById("otherUserCollection").innerHTML = '';
  document.getElementById("otherUserCollection").style.display = 'none';
  document.getElementById("collection").style.display = 'block';
  document.getElementById("otherUserHeader").style.display = 'none';
}

/* --------------------
   Auth / Load / Save
   -------------------- */
window.onload = function() {
  const lastUser = localStorage.getItem("lastLoggedInUser");
  const keepSignedIn = localStorage.getItem("keepSignedIn");
  if (lastUser && keepSignedIn === "true") {
    document.getElementById("username").value = lastUser;
    document.getElementById("keepSignedIn").checked = true;
    const pass = accounts[lastUser];
    if (pass) { document.getElementById("password").value = pass; login(); }
  }

  // Subscribe to nextDistribution in DB so the timer updates for everyone
  nextDistributionRef = db.ref('nextDistribution');
  nextDistributionRef.on('value', snap => {
    const v = snap.val();
    if (v) nextDistributionTimestamp = Number(v);
    else nextDistributionTimestamp = null;
    updateDistributionCountdownUI();
  });
};

function login() {
  const u = document.getElementById("username").value.trim();
  const p = document.getElementById("password").value.trim();
  const keep = document.getElementById("keepSignedIn").checked;
  if (accounts[u] && accounts[u] === p) {
    currentUser = u;
    if (keep) { localStorage.setItem("lastLoggedInUser", u); localStorage.setItem("keepSignedIn","true"); } else { localStorage.removeItem("lastLoggedInUser"); localStorage.removeItem("keepSignedIn"); }
    document.getElementById("loginBox").style.display = "none";
    document.getElementById("gameBox").style.display = "block";
    document.getElementById("userName").innerText = u;
    loadUserData();
    setOnlinePresence();
    listenForStealRequests();
    attachMyRealtimeListeners();

    // Start mutation interval
    if (!mutationInterval) { mutationInterval = setInterval(applyMutations, 1000 * 60 * 30); applyMutations(); }

    // Start distribution loop (checks every second, uses DB-bound nextDistributionTimestamp)
    if (!distributionInterval) {
      distributionInterval = setInterval(async () => {
        if (!nextDistributionTimestamp) {
          // initialize if none exists (first client)
          const newTs = Date.now() + distributionDelayMs;
          await db.ref('nextDistribution').set(newTs);
          nextDistributionTimestamp = newTs;
          updateDistributionCountdownUI();
          return;
        }
        // if time to distribute for this client, call distributeMutation (applies to currentUser) and advance timestamp
        if (Date.now() >= nextDistributionTimestamp) {
          try {
            await distributeMutation(); // distributes mutation to currentUser's locked card (if any)
          } catch(e) { console.error("distributeMutation call err", e); }
          const newTs = Date.now() + distributionDelayMs;
          await db.ref('nextDistribution').set(newTs);
          nextDistributionTimestamp = newTs;
          updateDistributionCountdownUI();
        }
      }, 1000);
    }

    // Start local countdown UI update if not already started
    if (!distributionCountdownInterval) {
      distributionCountdownInterval = setInterval(updateDistributionCountdownUI, 1000);
      updateDistributionCountdownUI();
    }

  } else {
    document.getElementById("loginStatus").innerText = "Invalid credentials!";
  }
}

function logout() {
  currentUser = null; balance = 0; collection = {}; lockedCards = {};
  localStorage.removeItem("lastLoggedInUser"); localStorage.removeItem("keepSignedIn");
  document.getElementById("gameBox").style.display = "none"; document.getElementById("loginBox").style.display = "block";
  document.getElementById("username").value = ""; document.getElementById("password").value = ""; document.getElementById("loginStatus").innerText = ""; document.getElementById("keepSignedIn").checked = false;
  updateUI();
  if (mutationInterval) { clearInterval(mutationInterval); mutationInterval = null; }
  if (distributionInterval) { clearInterval(distributionInterval); distributionInterval = null; }
  if (distributionCountdownInterval) { clearInterval(distributionCountdownInterval); distributionCountdownInterval = null; }
  nextDistributionTimestamp = null; updateDistributionCountdownUI();
  clearOnlinePresence();
  stopListeningForStealRequests();
  detachMyRealtimeListeners();
  detachOtherUserListener();
}

/* --------------------
   Load user + quantities
   -------------------- */
function loadUserData() {
  db.ref("users/" + currentUser).once("value").then(snap=>{
    if (snap.exists()) {
      const data = snap.val();
      balance = data.balance || 100;
      collection = data.collection || {};
      lockedCards = data.lockedCards || {};
    } else {
      balance = 100; collection = {}; lockedCards = {}; saveUser();
    }
    loadCardQuantities();
  });
  checkNotifications();
}

function loadCardQuantities() {
  db.ref("cardQuantities").once("value").then(snap=>{
    const dbQty = snap.val() || {};
    for (const packType in cardPools) {
      cardPools[packType].forEach(card=>{
        const k = toKey(card.name);
        if (dbQty[k] !== undefined) card.quantity = dbQty[k];
      });
    }
    updateUI(); updatePackChances();
  }).catch(err => { console.error("loadCardQuantities err", err); updateUI(); });
}

function saveUser() {
  if (!currentUser) return Promise.resolve();
  return db.ref("users/" + currentUser).set({ balance: balance, collection: collection, lockedCards: lockedCards }).catch(err => { console.error("saveUser err", err); throw err; });
}

function saveCardQuantities() {
  const q = {};
  for (const packType in cardPools) {
    cardPools[packType].forEach(card => { q[toKey(card.name)] = card.quantity; });
  }
  return db.ref("cardQuantities").update(q).catch(err => console.error("saveCardQuantities err", err));
}

function checkNotifications() {
  const ref = db.ref(`notifications/${currentUser}`);
  ref.once("value").then(snap=>{ if (snap.exists()) { const notes = snap.val(); for (const k in notes) showMessage(notes[k]); ref.remove(); } });
}

/* --------------------
   UI / Collection Rendering
   -------------------- */
function updateUI() {
  document.getElementById("balance").innerText = balance;
  document.getElementById("collection").innerHTML = renderCollection(collection, lockedCards, true);
  document.getElementById("otherUserCollection").style.display = 'none';
  document.getElementById("otherUserHeader").style.display = 'none';
  updatePackChances();
}

function showMyCollection() { detachOtherUserListener(); document.getElementById("collection").style.display='block'; document.getElementById("otherUserCollection").style.display='none'; document.getElementById("otherUserHeader").style.display='none'; }

function renderCollection(cardCollection, lockedCardsObj, isMyCollection = false, ownerId = null) {
  let collHTML = "";
  const all = { ...cardCollection, ...lockedCardsObj };
  if (Object.keys(all).length === 0) return "This user has no cards yet.";
  for (let id in all) {
    const card = all[id];
    if (!card) continue;
    const cardType = getCardType(card.name);
    const isLocked = !!lockedCardsObj[id];
    const cls = isLocked ? 'locked-card' : '';
    const mutationsCount = (card.mutations && card.mutations.length) || 0;
    const mutationLabel = mutationsCount>0 ? `<span class="mutation-label">${mutationsCount}x Mutated</span>` : '';
    const qty = getCardQuantity(card.name);
    const qtyHtml = `<span class="quantity-label">x${qty}</span>`;

    let buttons = '';
    if (isMyCollection) {
      buttons = `<button class="btn btn-small" onclick="event.stopPropagation(); ${isLocked ? `unlockCard('${id}')` : `lockCard('${id}')`}">${isLocked ? 'Unlock' : 'Lock'}</button>
                 <button class="btn btn-small" onclick="event.stopPropagation(); sellCard('${id}')" ${isLocked?'disabled':''}>Sell ($${card.currentPrice})</button>
                 <button class="btn btn-small btn-blue" onclick="event.stopPropagation(); openSendModal('${id}','${escapeHtml(card.name)}')">Send</button>`;
    } else {
      const owner = ownerId || 'player';
      buttons = `<div style="opacity:0.85; font-size:0.9rem; margin-top:6px;">Owner: ${owner}</div>
                 <button class="btn btn-small btn-gold" onclick="event.stopPropagation(); attemptSteal('${id}','${owner}')">Steal</button>`;
    }

    collHTML += `<div class="card ${cardType}-card ${cls}" onclick="showCardDetails('${id}')">${mutationLabel}${qtyHtml}<h3>${card.name}</h3><p>Value: $${card.currentPrice}</p><div class="card-buttons">${buttons}</div></div>`;
  }
  return collHTML;
}

function showUserCollection(targetUser) {
  if (targetUser === currentUser) { showMessage("This is your account. Use 'My Base' to manage your cards."); return; }
  attachOtherUserListener(targetUser);
}

/* --------------------
   Lock / Unlock / Sell
   -------------------- */
function lockCard(cardId) {
  const c = collection[cardId];
  if (!c) return showMessage("Card not found in collection.");
  c.isLocked = true; c.lockTime = Date.now(); c.lastMutationTime = Date.now(); c.mutations = c.mutations||[];
  lockedCards[cardId] = c; delete collection[cardId];
  saveUser(); updateUI(); showMessage(`Card "${c.name}" has been locked.`);
}
function unlockCard(cardId) {
  const c = lockedCards[cardId];
  if (!c) return showMessage("Card not found in locked cards.");
  c.isLocked = false; c.lockTime = 0;
  collection[cardId] = c; delete lockedCards[cardId];
  saveUser(); updateUI(); showMessage(`Card "${c.name}" has been unlocked.`);
}
function sellCard(cardId) {
  const c = collection[cardId];
  if (!c) return showMessage("Card not found!");
  balance += c.currentPrice; delete collection[cardId];
  saveUser(); updateUI(); showMessage(`Sold card "${c.name}" for $${c.currentPrice}.`);
}

/* --------------------
   Pack buying / chances
   -------------------- */
function updatePackChances() {
  const packs = [
    { type: 'common', pool: cardPools.common, buttonId: 'buyCommonBtn' },
    { type: 'rare', pool: cardPools.rare, buttonId: 'buyRareBtn' },
    { type: 'epic', pool: cardPools.epic, buttonId: 'buyEpicBtn' },
    { type: 'legendary', pool: cardPools.legendary, buttonId: 'buyLegendaryBtn' },
    { type: 'mythical', pool: cardPools.mythical, buttonId: 'buyMythicalBtn' },
    { type: 'divine', pool: cardPools.divine, buttonId: 'buyDivineBtn' },
    { type: 'pristimatic', pool: cardPools.pristimatic, buttonId: 'buyPristimaticBtn' }
  ];
  packs.forEach(pack=>{
    let totalChance = 0;
    const availableCards = pack.pool.filter(card => getCardQuantity(card.name) > 0);
    availableCards.forEach(card => totalChance += card.chance);
    const chanceText = `(${Math.round(totalChance*100)}%)`;
    const packPrice = pack.type==='common'?100:pack.type==='rare'?250:pack.type==='epic'?350:pack.type==='legendary'?1500:pack.type==='mythical'?3000:pack.type==='divine'?5000:7500;
    const btn = document.getElementById(pack.buttonId);
    if (btn) {
      btn.innerText = `Buy ${pack.type.charAt(0).toUpperCase()+pack.type.slice(1)} Pack ${chanceText} ($${packPrice})`;
      btn.disabled = (balance < packPrice) || (availableCards.length === 0);
      btn.style.opacity = btn.disabled ? 0.5 : 1;
      btn.style.cursor = btn.disabled ? 'not-allowed' : 'pointer';
    }
  });
}

/* --------------------
   Mutations & Distribution
   -------------------- */
function applyMutations() {
  if (!currentUser) return;
  currentHourlyMutation = getRandomMutation();
}
function getRandomMutation() {
  const arr = Object.keys(MUTATIONS).map(k=>({name:k,priceIncrease:MUTATIONS[k].priceIncrease, chance: MUTATION_TIERS[MUTATIONS[k].tier]?MUTATION_TIERS[MUTATIONS[k].tier].chance:0}));
  const total = arr.reduce((s,i)=>s+i.chance,0);
  let r = Math.random()*total; let s=0;
  for (const it of arr) { s+=it.chance; if (r<=s) return {name:it.name, priceIncrease:it.priceIncrease}; }
  return {name:'bloom', priceIncrease:300};
}
function getRandomMutationExcluding(excludeNames=[]) {
  const keys = Object.keys(MUTATIONS).filter(k=>!excludeNames.includes(k));
  if (!keys.length) return null;
  const list = keys.map(k=>{ const m=MUTATIONS[k]; return {name:k, priceIncrease:m.priceIncrease, weight: MUTATION_TIERS[m.tier]?MUTATION_TIERS[m.tier].chance:0}; });
  const total = list.reduce((s,i)=>s+i.weight,0); if (total<=0) return null;
  let r=Math.random()*total, s=0;
  for (const it of list) { s+=it.weight; if (r<=s) return {name:it.name, priceIncrease:it.priceIncrease}; }
  return {name:list[0].name, priceIncrease:list[0].priceIncrease};
}

async function distributeMutation() {
  // Distribute only to the current logged-in user's locked cards (like before).
  if (!currentHourlyMutation || !currentUser) return;
  try {
    const userSnap = await db.ref(`users/${currentUser}`).once("value");
    if (!userSnap.exists()) return;
    const ud = userSnap.val(); const uLocked = ud.lockedCards||{};
    const eligible = [];
    for (const id in uLocked) { const c = uLocked[id]; if ((c.mutations||[]).length < 6) eligible.push({cardId:id, card:c}); }
    if (eligible.length===0) return;
    const chosen = eligible[Math.floor(Math.random()*eligible.length)];
    chosen.card.mutations = chosen.card.mutations||[];
    const existing = chosen.card.mutations.map(m=>m.name);
    let mutationToApply = null;
    if (!existing.includes(currentHourlyMutation.name)) mutationToApply = currentHourlyMutation;
    else mutationToApply = getRandomMutationExcluding(existing);
    if (!mutationToApply || existing.includes(mutationToApply.name)) { console.log("no mutation available"); return; }
    chosen.card.mutations.push(mutationToApply);
    chosen.card.currentPrice = (chosen.card.currentPrice||chosen.card.basePrice||0) + mutationToApply.priceIncrease;
    chosen.card.lastMutationTime = Date.now();
    await db.ref(`users/${currentUser}/lockedCards/${chosen.cardId}`).set(chosen.card);
    // local mirror will update via realtime listener
    showMessage(`Your card "${chosen.card.name}" gained a mutation: ${mutationToApply.name}!`);
  } catch (err) { console.error("distributeMutation err", err); }
}

/* --------------------
   Open pack (unchanged)
   -------------------- */
async function openPack(type) {
  let packPrice = 0;
  let pool = [];
  if (type === "common") { packPrice = 100; pool = cardPools.common; }
  else if (type === "rare") { packPrice = 250; pool = cardPools.rare; }
  else if (type === "epic") { packPrice = 350; pool = cardPools.epic; }
  else if (type === "legendary") { packPrice = 1500; pool = cardPools.legendary; }
  else if (type === "mythical") { packPrice = 3000; pool = cardPools.mythical; }
  else if (type === "divine") { packPrice = 5000; pool = cardPools.divine; }
  else if (type === "pristimatic") { packPrice = 7500; pool = cardPools.pristimatic; }

  if (balance < packPrice) { showMessage("You don't have enough money to buy this pack."); return; }

  // Deduct now; refund on failure
  balance -= packPrice;
  await saveUser();
  updateUI();

  try {
    // 1) Fresh quantities snapshot
    const snap = await db.ref('cardQuantities').once('value');
    const dbQty = snap.val() || {};

    // 2) Update local pool counts from server
    pool.forEach(card => {
      const k = toKey(card.name);
      if (dbQty[k] !== undefined) card.quantity = dbQty[k];
    });

    // 3) Choose only available cards
    const available = pool.filter(c => c.quantity > 0);
    if (available.length === 0) {
      balance += packPrice; await saveUser(); updateUI(); showMessage("This pack is sold out!"); return;
    }

    // pick by chance
    let rand = Math.random();
    let s = 0;
    let chosenTemplate = available[0];
    for (const c of available) { s += c.chance; if (rand <= s) { chosenTemplate = c; break; } }

    const chosenName = chosenTemplate.name;
    const safeKey = toKey(chosenName);
    const qtyRef = db.ref(`cardQuantities/${safeKey}`);

    // Transaction: if missing, initialize to template.quantity then decrement
    const txnResult = await qtyRef.transaction(current => {
      if (current === null || current === undefined) {
        if (!chosenTemplate.quantity || chosenTemplate.quantity <= 0) return; // abort
        return chosenTemplate.quantity - 1;
      }
      if (current > 0) return current - 1;
      return; // abort if zero
    }, /* applyLocally */ false);

    if (!txnResult || !txnResult.committed) {
      // refund and refresh
      balance += packPrice; await saveUser(); updateUI();
      showMessage(`Sorry — "${chosenName}" sold out. You were refunded $${packPrice}.`);
      loadCardQuantities();
      return;
    }

    // success
    let newQty = txnResult.snapshot.val(); if (newQty === null || newQty === undefined) newQty = 0;
    const newCardId = generateCardId();
    const newCard = { id: newCardId, name: chosenName, basePrice: chosenTemplate.price, currentPrice: chosenTemplate.price, isLocked: false, lockTime: 0, lastMutationTime: Date.now(), mutations: [] };
    collection[newCardId] = newCard;

    // update local pool qty
    const poolCard = pool.find(x=>x.name===chosenName);
    if (poolCard) poolCard.quantity = newQty;

    await saveUser();
    await db.ref('purchases').push({ card: chosenName, user: currentUser, time: Date.now() });
    updateUI();

    document.getElementById("openedCard").innerHTML = `<div class="card ${getCardType(newCard.name)}-card"><span class="quantity-label">x${newQty}</span><h3>${newCard.name}</h3><p>Value: $${newCard.currentPrice}</p><p>Added to your collection!</p></div>`;

  } catch (err) {
    console.error("openPack error:", err);
    balance += packPrice; await saveUser(); updateUI();
    showMessage("An error occurred while buying the pack — you were refunded.");
    loadCardQuantities();
  }
}

/* --------------------
   Send Card Flow
   -------------------- */
function escapeHtml(str) {
  return String(str || '').replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;').replace(/'/g,'&#039;');
}
function openSendModal(cardId, cardName) {
  currentSendCardId = cardId;
  document.getElementById('sendCardName').innerText = cardName || (collection[cardId] && collection[cardId].name) || '';
  document.getElementById('sendModal').style.display = 'block';
}
function closeSendModal() {
  currentSendCardId = null;
  document.getElementById('sendModal').style.display = 'none';
}

async function sendCardToRecipient(cardId, recipient) {
  try {
    if (!currentUser) { showMessage("You must be logged in to send cards."); return; }
    if (!cardId) { showMessage("No card selected."); return; }
    if (!recipient || recipient === currentUser) { showMessage("Select a valid recipient."); return; }

    const rRef = db.ref(`users/${recipient}`);
    const rSnap = await rRef.once('value');
    if (!rSnap.exists()) { showMessage("Recipient does not exist."); return; }

    let cardData = null;
    if (collection[cardId]) { cardData = collection[cardId]; delete collection[cardId]; }
    else if (lockedCards[cardId]) { cardData = lockedCards[cardId]; delete lockedCards[cardId]; }
    else { showMessage("You no longer own that card."); return; }

    cardData.isLocked = false;
    cardData.lockTime = 0;
    cardData.lastMutationTime = Date.now();

    await db.ref(`users/${currentUser}/collection`).set(collection || {});
    await db.ref(`users/${currentUser}/lockedCards`).set(lockedCards || {});
    await db.ref(`users/${recipient}/collection/${cardId}`).set(cardData);
    await db.ref(`notifications/${recipient}`).push().set(`${currentUser} sent you a card: "${cardData.name}".`);
    await saveUser();
    updateUI();
    closeSendModal();
    showMessage(`Sent "${cardData.name}" to ${recipient}.`);
  } catch (err) {
    console.error("sendCardToRecipient err", err);
    showMessage("Error sending card. Check console.");
  }
}

/* --------------------
   Steal Flow (locked + unlocked stealable)
   -------------------- */
async function getLastStealTimestamp(user) {
  const snap = await db.ref(`stealCooldowns/${user}`).once('value');
  const v = snap.val();
  return v || 0;
}

async function attemptSteal(cardId, owner) {
  try {
    if (!currentUser) { showMessage("You must be logged in to attempt a steal."); return; }
    if (!cardId) return;
    if (owner === currentUser) { showMessage("You cannot steal your own card."); return; }

    const last = await getLastStealTimestamp(currentUser);
    const now = Date.now();
    if (now - last < STEAL_COOLDOWN_MS) {
      const remain = Math.ceil((STEAL_COOLDOWN_MS - (now - last)) / 60000);
      showMessage(`You are on steal cooldown. Try again in ~${remain} minute(s).`);
      return;
    }

    const presSnap = await db.ref(`presence/${owner}`).once('value');
    if (!presSnap.exists()) { showMessage(`${owner} is offline — you can only steal from online players.`); return; }

    // Check collection first, then lockedCards
    let ownerCardSnap = await db.ref(`users/${owner}/collection/${cardId}`).once('value');
    let cardData = null;
    let cardLocation = 'collection';
    if (ownerCardSnap.exists()) {
      cardData = ownerCardSnap.val();
      cardLocation = 'collection';
    } else {
      const lockedSnap = await db.ref(`users/${owner}/lockedCards/${cardId}`).once('value');
      if (lockedSnap.exists()) {
        cardData = lockedSnap.val();
        cardLocation = 'lockedCards';
      } else {
        showMessage("That card is not available (owner doesn't have it).");
        return;
      }
    }

    // Build math question
    const a = Math.floor(Math.random()*20)+1;
    const b = Math.floor(Math.random()*20)+1;
    const op = Math.random() < 0.5 ? '+' : '-';

    const sessionId = generateCardId();
    const session = {
      sessionId,
      cardId,
      cardName: cardData.name,
      attacker: currentUser,
      defender: owner,
      cardSnapshot: cardData,
      cardLocation, // remember where it came from
      question: { a, b, op },
      createdAt: Date.now(),
      winner: null,
      resolved: false
    };

    await db.ref(`stealSessions/${sessionId}`).set(session);
    await db.ref(`stealRequests/${currentUser}/${sessionId}`).set(session);
    await db.ref(`stealRequests/${owner}/${sessionId}`).set(session);

    showIncomingSteal(sessionId, session, true);

  } catch (err) {
    console.error("attemptSteal err", err);
    showMessage("Error starting steal. Check console.");
  }
}

function showIncomingSteal(sessionId, session, isInitiator=false) {
  activeStealSession = { sessionId, session };
  const q = session.question;
  const questionText = `${q.a} ${q.op} ${q.b} = ?`;
  const title = (session.attacker === currentUser) ? `You are stealing "${session.cardName}" from ${session.defender}` : `${session.attacker} is attempting to steal "${session.cardName}" from you!`;
  document.getElementById('stealModalTitle').innerText = title;
  document.getElementById('stealQuestion').innerText = questionText;
  document.getElementById('stealAnswerInput').value = '';
  document.getElementById('stealModalHint').innerText = `Solve the question correctly as fast as you can. First correct answer wins.`;
  document.getElementById('stealModal').style.display = 'block';
  if (session.defender === currentUser) {
    const audio = new Audio('steal.mp3');
    audio.play().catch(()=>{});
  }
  setTimeout(()=>{ try { document.getElementById('stealAnswerInput').focus(); } catch(e){} }, 200);
}

function closeStealModal() {
  activeStealSession = null;
  document.getElementById('stealModal').style.display = 'none';
}

async function submitStealAnswer() {
  try {
    if (!activeStealSession) { closeStealModal(); return; }
    const sessionId = activeStealSession.sessionId;
    const session = activeStealSession.session;
    const raw = document.getElementById('stealAnswerInput').value.trim();
    if (raw === '') { document.getElementById('stealModalHint').innerText = 'Enter an answer.'; return; }
    const num = Number(raw);
    if (isNaN(num)) { document.getElementById('stealModalHint').innerText = 'Enter a numeric answer.'; return; }

    const correct = (() => {
      const q = session.question;
      return q.op === '+' ? (q.a + q.b) === num : (q.a - q.b) === num;
    })();

    if (!correct) {
      document.getElementById('stealModalHint').innerText = 'Wrong answer — try again quickly!';
      return;
    }

    await db.ref(`stealSessions/${sessionId}/answers/${currentUser}`).set({ time: Date.now(), correct: true });

    const winnerRef = db.ref(`stealSessions/${sessionId}/winner`);
    winnerRef.transaction(current => {
      if (current === null) return currentUser;
      return;
    }, async (err, committed, snap) => {
      if (err) { console.error("winner transaction err", err); return; }
      if (!committed) {
        const winner = snap && snap.val();
        if (winner === currentUser) {
          document.getElementById('stealModalHint').innerText = 'Too late — someone else solved it first.';
        } else {
          document.getElementById('stealModalHint').innerText = `Too late — ${winner} claimed the win.`;
        }
        finalizeSteal(sessionId, winner);
      } else {
        finalizeSteal(sessionId, currentUser);
      }
    });

  } catch (err) {
    console.error("submitStealAnswer err", err);
    document.getElementById('stealModalHint').innerText = 'Error submitting answer.';
  }
}

async function finalizeSteal(sessionId, winnerId) {
  try {
    const snap = await db.ref(`stealSessions/${sessionId}`).once('value');
    const sess = snap.val();
    if (!sess) return;
    if (sess.resolved) {
      await cleanupStealSession(sessionId);
      if (document.getElementById('stealModal').style.display === 'block') closeStealModal();
      return;
    }

    const attacker = sess.attacker;
    const defender = sess.defender;
    const cardId = sess.cardId;
    const cardSnapshot = sess.cardSnapshot || {};
    const cardLocation = sess.cardLocation || 'collection';

    await db.ref(`stealSessions/${sessionId}/resolved`).set(true);
    await db.ref(`stealSessions/${sessionId}/winner`).set(winnerId);
    await db.ref(`stealCooldowns/${attacker}`).set(Date.now());

    if (winnerId === attacker) {
      // lock card processing
      const lockRef = db.ref(`cardLocks/${cardId}`);
      const lockResult = await lockRef.transaction(current => {
        if (current === null) return attacker;
        return;
      }, false);

      if (!lockResult || !lockResult.committed) {
        await db.ref(`stealSessions/${sessionId}/result`).set({ success: false, message: "Card is already being processed." });
        await notifyUsersOfStealResult(sessionId, false, attacker, defender);
        await cleanupStealSession(sessionId);
        if (document.getElementById('stealModal').style.display === 'block') closeStealModal();
        return;
      }

      cardSnapshot.isLocked = false;
      cardSnapshot.lockTime = 0;
      cardSnapshot.lastMutationTime = Date.now();

      const updates = {};
      updates[`users/${attacker}/collection/${cardId}`] = cardSnapshot;
      updates[`users/${defender}/collection/${cardId}`] = null;
      updates[`users/${defender}/lockedCards/${cardId}`] = null;

      try {
        await db.ref().update(updates);
        await db.ref(`stealSessions/${sessionId}/result`).set({ success: true, message: `${attacker} stole "${cardSnapshot.name}" from ${defender}` });
        await notifyUsersOfStealResult(sessionId, true, attacker, defender);
      } catch (e) {
        console.error("atomic move failed", e);
        await db.ref(`stealSessions/${sessionId}/result`).set({ success: false, message: "Error transferring card." });
        await notifyUsersOfStealResult(sessionId, false, attacker, defender);
      } finally {
        await lockRef.remove().catch(()=>{});
        await cleanupStealSession(sessionId);
        if (currentUser === attacker || currentUser === defender) loadUserData();
        if (document.getElementById('stealModal').style.display === 'block') closeStealModal();
      }

    } else {
      await db.ref(`stealSessions/${sessionId}/result`).set({ success: false, message: `${winnerId} defended the card.` });
      await notifyUsersOfStealResult(sessionId, false, attacker, defender);
      await cleanupStealSession(sessionId);
      if (document.getElementById('stealModal').style.display === 'block') closeStealModal();
      return;
    }

  } catch (err) {
    console.error("finalizeSteal err", err);
    await db.ref(`stealSessions/${sessionId}/result`).set({ success: false, message: "Error finalizing steal." });
    await cleanupStealSession(sessionId);
    if (document.getElementById('stealModal').style.display === 'block') closeStealModal();
  }
}

async function notifyUsersOfStealResult(sessionId, success, attacker, defender) {
  try {
    const resSnap = await db.ref(`stealSessions/${sessionId}/result`).once('value');
    const res = resSnap.val();
    const msgToAttacker = success ? `You successfully stole "${res && res.message ? '' : ''}"` : `Steal attempt result: ${res && res.message ? res.message : 'Failed'}`;
    const msgToDefender = success ? `${attacker} stole a card from you: ${res && res.message ? res.message : ''}` : `You defended the steal attempt.`;
    await db.ref(`notifications/${attacker}`).push(msgToAttacker);
    await db.ref(`notifications/${defender}`).push(msgToDefender);
  } catch (e) { console.error("notifyUsersOfStealResult err", e); }
}

async function cleanupStealSession(sessionId) {
  try {
    const sessSnap = await db.ref(`stealSessions/${sessionId}`).once('value');
    const sess = sessSnap.val();
    if (!sess) {
      await db.ref(`stealRequests/${currentUser}/${sessionId}`).remove().catch(()=>{});
      return;
    }
    const attacker = sess.attacker; const defender = sess.defender;
    await db.ref(`stealRequests/${attacker}/${sessionId}`).remove().catch(()=>{});
    await db.ref(`stealRequests/${defender}/${sessionId}`).remove().catch(()=>{});
  } catch (e) { console.error("cleanupStealSession err", e); }
}

/* --------------------
   Admin / Refill
   -------------------- */
function refillStocksPrompt() {
  const code = prompt("Enter refill code:");
  if (code === null) return;
  if (String(code).trim() === "555") {
    refillStocks().then(() => {
      showMessage("Stocks refilled to initial quantities.");
    }).catch(err => {
      console.error("refillStocks error:", err);
      showMessage("Refill failed — check console.");
    });
  } else {
    showMessage("Incorrect code.");
  }
}
async function refillStocks() {
  const payload = {};
  for (const name in INITIAL_QUANTITIES) payload[toKey(name)] = INITIAL_QUANTITIES[name];
  await db.ref('cardQuantities').set(payload);
  for (const packType in cardPools) {
    cardPools[packType].forEach(card => { if (INITIAL_QUANTITIES[card.name] !== undefined) card.quantity = INITIAL_QUANTITIES[card.name]; });
  }
  updateUI(); updatePackChances();
  await db.ref('adminActions').push({ action: 'refillStocks', by: currentUser || 'unknown', time: Date.now() });
}

/* --------------------
   Small helpers / UI hooks
   -------------------- */
document.getElementById("welcome-btn").addEventListener("click", () => {
  document.getElementById("welcome-container").style.display = "none";

  // create global player once
  if (!window.gAudio) {
    window.gAudio = new Audio('g.mp3');
    window.gAudio.loop = true;
    window.gAudio.preload = 'auto';
    window.gAudio.volume = 0.9; // optional: 0.0 - 1.0
  }

  // start playback if not already playing
  if (window.gAudio.paused) window.gAudio.play().catch(()=>{});
});

const refreshBtn = document.createElement('button');
refreshBtn.id = 'refresh-btn';
refreshBtn.style = "position:fixed; top:20px; right:20px; padding:12px 20px; font-size:18px; border:none; border-radius:10px; background:#2196f3; color:white; cursor:pointer; box-shadow:0 4px 10px rgba(0,0,0,0.3); z-index:9999;";
refreshBtn.innerText = "🔄 Refresh";
refreshBtn.addEventListener("click", ()=> location.reload());
document.body.appendChild(refreshBtn);

window.addEventListener('beforeunload', () => {
  try { if (currentUser) db.ref(`presence/${currentUser}`).remove(); } catch(e){}
});

/* End of script */
</script>

</body>
</html>
